/**
 * Copyright (c) 2019-2024 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Áron Samuel Kovács <aron.kovacs@mail.muni.cz>
 * @author Ludovic Autin <ludovic.autin@gmail.com>
 */
import { TextureSpec, Values, UniformSpec, DefineSpec } from '../../mol-gl/renderable/schema';
import { WebGLContext } from '../../mol-gl/webgl/context';
import { Texture } from '../../mol-gl/webgl/texture';
import { ComputeRenderable } from '../../mol-gl/renderable';
import { ParamDefinition as PD } from '../../mol-util/param-definition';
import { RenderTarget } from '../../mol-gl/webgl/render-target';
import { DrawPass } from './draw';
import { ICamera } from '../../mol-canvas3d/camera';
import { Color } from '../../mol-util/color';
import { BackgroundPass } from './background';
import { AssetManager } from '../../mol-util/assets';
import { Light } from '../../mol-gl/renderer';
export declare const OutlinesSchema: {
    tDepthOpaque: TextureSpec<"texture">;
    tDepthTransparent: TextureSpec<"texture">;
    uTexSize: UniformSpec<"v2">;
    dOrthographic: DefineSpec<"number">;
    uNear: UniformSpec<"f">;
    uFar: UniformSpec<"f">;
    uInvProjection: UniformSpec<"m4">;
    uOutlineThreshold: UniformSpec<"f">;
    dTransparentOutline: DefineSpec<"boolean">;
    drawCount: import("../../mol-gl/renderable/schema").ValueSpec<"number">;
    instanceCount: import("../../mol-gl/renderable/schema").ValueSpec<"number">;
    aPosition: import("../../mol-gl/renderable/schema").AttributeSpec<"float32">;
    uQuadScale: UniformSpec<"v2">;
};
export type OutlinesRenderable = ComputeRenderable<Values<typeof OutlinesSchema>>;
export declare function getOutlinesRenderable(ctx: WebGLContext, depthTextureOpaque: Texture, depthTextureTransparent: Texture, transparentOutline: boolean): OutlinesRenderable;
export declare const PostprocessingParams: {
    occlusion: PD.Mapped<PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
        samples: number;
        multiScale: PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
            levels: any;
            nearThreshold: any;
            farThreshold: any;
        }>, "on">;
        radius: number;
        bias: number;
        blurKernelSize: number;
        resolutionScale: number;
        color: Color;
    }>, "on">>;
    shadow: PD.Mapped<PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
        steps: number;
        bias: number;
        maxDistance: number;
        tolerance: number;
    }>, "on">>;
    outline: PD.Mapped<PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
        scale: number;
        threshold: number;
        color: Color;
        includeTransparent: boolean;
    }>, "on">>;
    dof: PD.Mapped<PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
        blurSize: number;
        blurSpread: number;
        inFocus: number;
        PPM: number;
        center: string;
        mode: string;
    }>, "on">>;
    antialiasing: PD.Mapped<PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
        edgeThreshold: number;
        maxSearchSteps: number;
    }>, "smaa"> | PD.NamedParams<PD.Normalize<{
        edgeThresholdMin: number;
        edgeThresholdMax: number;
        iterations: number;
        subpixelQuality: number;
    }>, "fxaa">>;
    sharpening: PD.Mapped<PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
        sharpness: number;
        denoise: boolean;
    }>, "on">>;
    background: PD.Group<PD.Normalize<{
        variant: PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
            coverage: any;
            opacity: any;
            saturation: any;
            lightness: any;
            source: any;
            blur: any;
        }>, "image"> | PD.NamedParams<PD.Normalize<{
            centerColor: any;
            edgeColor: any;
            ratio: any;
            coverage: any;
        }>, "radialGradient"> | PD.NamedParams<PD.Normalize<{
            opacity: any;
            saturation: any;
            lightness: any;
            faces: any;
            blur: any;
            rotation: any;
        }>, "skybox"> | PD.NamedParams<PD.Normalize<{
            topColor: any;
            bottomColor: any;
            ratio: any;
            coverage: any;
        }>, "horizontalGradient">;
    }>>;
    bloom: PD.Mapped<PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
        strength: number;
        radius: number;
        threshold: number;
        mode: "luminosity" | "emissive";
    }>, "on">>;
};
export type PostprocessingProps = PD.Values<typeof PostprocessingParams>;
export declare class PostprocessingPass {
    private readonly webgl;
    private readonly drawPass;
    static isEnabled(props: PostprocessingProps): boolean;
    static isTransparentOutlineEnabled(props: PostprocessingProps): boolean;
    readonly target: RenderTarget;
    private readonly outlinesTarget;
    private readonly outlinesRenderable;
    private readonly shadowsTarget;
    private readonly shadowsRenderable;
    private readonly ssaoFramebuffer;
    private readonly ssaoBlurFirstPassFramebuffer;
    private readonly ssaoBlurSecondPassFramebuffer;
    private readonly downsampledDepthTarget;
    private readonly downsampleDepthRenderable;
    private readonly depthHalfTarget;
    private readonly depthHalfRenderable;
    private readonly depthQuarterTarget;
    private readonly depthQuarterRenderable;
    private readonly ssaoDepthTexture;
    private readonly ssaoDepthBlurProxyTexture;
    private readonly ssaoRenderable;
    private readonly ssaoBlurFirstPassRenderable;
    private readonly ssaoBlurSecondPassRenderable;
    private nSamples;
    private blurKernelSize;
    private readonly renderable;
    private ssaoScale;
    private calcSsaoScale;
    private levels;
    private readonly bgColor;
    readonly background: BackgroundPass;
    constructor(webgl: WebGLContext, assetManager: AssetManager, drawPass: DrawPass);
    setSize(width: number, height: number): void;
    updateState(camera: ICamera, transparentBackground: boolean, backgroundColor: Color, props: PostprocessingProps, light: Light): void;
    private occlusionOffset;
    setOcclusionOffset(x: number, y: number): void;
    private transparentBackground;
    setTransparentBackground(value: boolean): void;
    render(camera: ICamera, toDrawingBuffer: boolean, transparentBackground: boolean, backgroundColor: Color, props: PostprocessingProps, light: Light): void;
}
export declare class AntialiasingPass {
    static isEnabled(props: PostprocessingProps): boolean;
    readonly target: RenderTarget;
    private readonly internalTarget;
    private readonly fxaa;
    private readonly smaa;
    private readonly cas;
    constructor(webgl: WebGLContext, width: number, height: number);
    setSize(width: number, height: number): void;
    private _renderFxaa;
    private _renderSmaa;
    private _renderAntialiasing;
    private _renderCas;
    render(camera: ICamera, input: Texture, toDrawingBuffer: boolean | RenderTarget, props: PostprocessingProps): void;
}
