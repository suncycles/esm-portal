"use strict";
/**
 * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElementSphereMeshVisual = exports.ElementSphereImpostorVisual = exports.ElementSphereVisual = exports.ElementSphereParams = void 0;
var tslib_1 = require("tslib");
var param_definition_1 = require("../../../mol-util/param-definition");
var units_visual_1 = require("../units-visual");
var element_1 = require("./util/element");
var base_1 = require("../../../mol-geo/geometry/base");
exports.ElementSphereParams = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, units_visual_1.UnitsMeshParams), units_visual_1.UnitsSpheresParams), { sizeFactor: param_definition_1.ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }), detail: param_definition_1.ParamDefinition.Numeric(0, { min: 0, max: 3, step: 1 }, base_1.BaseGeometry.CustomQualityParamInfo), ignoreHydrogens: param_definition_1.ParamDefinition.Boolean(false), ignoreHydrogensVariant: param_definition_1.ParamDefinition.Select('all', param_definition_1.ParamDefinition.arrayToOptions(['all', 'non-polar'])), traceOnly: param_definition_1.ParamDefinition.Boolean(false), tryUseImpostor: param_definition_1.ParamDefinition.Boolean(true) });
function ElementSphereVisual(materialId, structure, props, webgl) {
    return props.tryUseImpostor && webgl && webgl.extensions.fragDepth
        ? ElementSphereImpostorVisual(materialId)
        : ElementSphereMeshVisual(materialId);
}
exports.ElementSphereVisual = ElementSphereVisual;
function ElementSphereImpostorVisual(materialId) {
    return (0, units_visual_1.UnitsSpheresVisual)({
        defaultProps: param_definition_1.ParamDefinition.getDefaultValues(exports.ElementSphereParams),
        createGeometry: element_1.createElementSphereImpostor,
        createLocationIterator: element_1.ElementIterator.fromGroup,
        getLoci: element_1.getElementLoci,
        eachLocation: element_1.eachElement,
        setUpdateState: function (state, newProps, currentProps) {
            state.createGeometry = (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens ||
                newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant ||
                newProps.traceOnly !== currentProps.traceOnly);
        },
        mustRecreate: function (structureGroup, props, webgl) {
            return !props.tryUseImpostor || !webgl;
        }
    }, materialId);
}
exports.ElementSphereImpostorVisual = ElementSphereImpostorVisual;
function ElementSphereMeshVisual(materialId) {
    return (0, units_visual_1.UnitsMeshVisual)({
        defaultProps: param_definition_1.ParamDefinition.getDefaultValues(exports.ElementSphereParams),
        createGeometry: element_1.createElementSphereMesh,
        createLocationIterator: element_1.ElementIterator.fromGroup,
        getLoci: element_1.getElementLoci,
        eachLocation: element_1.eachElement,
        setUpdateState: function (state, newProps, currentProps) {
            state.createGeometry = (newProps.sizeFactor !== currentProps.sizeFactor ||
                newProps.detail !== currentProps.detail ||
                newProps.ignoreHydrogens !== currentProps.ignoreHydrogens ||
                newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant ||
                newProps.traceOnly !== currentProps.traceOnly);
        },
        mustRecreate: function (structureGroup, props, webgl) {
            return props.tryUseImpostor && !!webgl;
        }
    }, materialId);
}
exports.ElementSphereMeshVisual = ElementSphereMeshVisual;
