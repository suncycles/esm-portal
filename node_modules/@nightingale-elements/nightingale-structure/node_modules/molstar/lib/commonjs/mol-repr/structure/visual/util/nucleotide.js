"use strict";
/**
 * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.eachNucleotideElement = exports.getNucleotideElementLoci = exports.NucleotideLocationIterator = void 0;
var structure_1 = require("../../../../mol-model/structure");
var loci_1 = require("../../../../mol-model/loci");
var location_iterator_1 = require("../../../../mol-geo/util/location-iterator");
var common_1 = require("./common");
var polymer_1 = require("./polymer");
var NucleotideLocationIterator;
(function (NucleotideLocationIterator) {
    function fromGroup(structureGroup) {
        var group = structureGroup.group, structure = structureGroup.structure;
        var u = group.units[0];
        var nucleotideElementIndices = structure_1.Unit.isAtomic(u) ? u.nucleotideElements : [];
        var groupCount = nucleotideElementIndices.length;
        var instanceCount = group.units.length;
        var location = structure_1.StructureElement.Location.create(structure);
        var getLocation = function (groupIndex, instanceIndex) {
            var unit = group.units[instanceIndex];
            location.unit = unit;
            location.element = nucleotideElementIndices[groupIndex];
            return location;
        };
        return (0, location_iterator_1.LocationIterator)(groupCount, instanceCount, 1, getLocation);
    }
    NucleotideLocationIterator.fromGroup = fromGroup;
})(NucleotideLocationIterator = exports.NucleotideLocationIterator || (exports.NucleotideLocationIterator = {}));
function getNucleotideElementLoci(pickingId, structureGroup, id) {
    var objectId = pickingId.objectId, instanceId = pickingId.instanceId, groupId = pickingId.groupId;
    if (id === objectId) {
        var structure = structureGroup.structure, group = structureGroup.group;
        var unit = group.units[instanceId];
        if (structure_1.Unit.isAtomic(unit)) {
            return (0, common_1.getResidueLoci)(structure, unit, unit.nucleotideElements[groupId]);
        }
    }
    return loci_1.EmptyLoci;
}
exports.getNucleotideElementLoci = getNucleotideElementLoci;
function selectNuclotideElements(u) { return u.nucleotideElements; }
/**
 * Mark a nucleotide element (e.g. part of a cartoon block)
 * - mark only when all its residue's elements are in a loci
 */
function eachNucleotideElement(loci, structureGroup, apply) {
    var changed = false;
    if (!structure_1.StructureElement.Loci.is(loci))
        return false;
    var structure = structureGroup.structure, group = structureGroup.group;
    if (!structure_1.Structure.areEquivalent(loci.structure, structure))
        return false;
    var unit = group.units[0];
    if (!structure_1.Unit.isAtomic(unit))
        return false;
    var nucleotideElements = unit.nucleotideElements;
    var groupCount = nucleotideElements.length;
    for (var _i = 0, _a = loci.elements; _i < _a.length; _i++) {
        var e = _a[_i];
        if (!structure_1.Unit.isAtomic(e.unit))
            continue;
        if (!group.unitIndexMap.has(e.unit.id))
            continue;
        var intervalOffset = group.unitIndexMap.get(e.unit.id) * groupCount;
        if (structure_1.Unit.isAtomic(e.unit)) {
            changed = (0, polymer_1.eachAtomicUnitTracedElement)(intervalOffset, groupCount, selectNuclotideElements, apply, e) || changed;
        }
    }
    return changed;
}
exports.eachNucleotideElement = eachNucleotideElement;
