"use strict";
/**
 * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoarsePolymerGapIterator = exports.AtomicPolymerGapIterator = exports.PolymerGapIterator = void 0;
var structure_1 = require("../../../../../mol-model/structure");
var sorted_ranges_1 = require("../../../../../mol-data/int/sorted-ranges");
var polymer_1 = require("../polymer");
/** Iterates over gaps, i.e. the stem residues/coarse elements adjacent to gaps */
function PolymerGapIterator(structure, unit) {
    switch (unit.kind) {
        case 0 /* Unit.Kind.Atomic */: return new AtomicPolymerGapIterator(structure, unit);
        case 1 /* Unit.Kind.Spheres */:
        case 2 /* Unit.Kind.Gaussians */:
            return new CoarsePolymerGapIterator(structure, unit);
    }
}
exports.PolymerGapIterator = PolymerGapIterator;
function createPolymerGapPair(structure, unit) {
    return {
        centerA: structure_1.StructureElement.Location.create(structure, unit),
        centerB: structure_1.StructureElement.Location.create(structure, unit),
    };
}
var AtomicPolymerGapIterator = /** @class */ (function () {
    function AtomicPolymerGapIterator(structure, unit) {
        this.unit = unit;
        this.hasNext = false;
        this.traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex; // can assume it won't be -1 for polymer residues
        this.gapIt = sorted_ranges_1.SortedRanges.transientSegments((0, polymer_1.getGapRanges)(unit), unit.elements);
        this.value = createPolymerGapPair(structure, unit);
        this.hasNext = this.gapIt.hasNext;
    }
    AtomicPolymerGapIterator.prototype.move = function () {
        var _a = this.unit, elements = _a.elements, residueIndex = _a.residueIndex;
        var gapSegment = this.gapIt.move();
        this.value.centerA.element = this.traceElementIndex[residueIndex[elements[gapSegment.start]]];
        this.value.centerB.element = this.traceElementIndex[residueIndex[elements[gapSegment.end - 1]]];
        this.hasNext = this.gapIt.hasNext;
        return this.value;
    };
    return AtomicPolymerGapIterator;
}());
exports.AtomicPolymerGapIterator = AtomicPolymerGapIterator;
var CoarsePolymerGapIterator = /** @class */ (function () {
    function CoarsePolymerGapIterator(structure, unit) {
        this.unit = unit;
        this.hasNext = false;
        this.gapIt = sorted_ranges_1.SortedRanges.transientSegments((0, polymer_1.getGapRanges)(unit), unit.elements);
        this.value = createPolymerGapPair(structure, unit);
        this.hasNext = this.gapIt.hasNext;
    }
    CoarsePolymerGapIterator.prototype.move = function () {
        var gapSegment = this.gapIt.move();
        this.value.centerA.element = this.unit.elements[gapSegment.start];
        this.value.centerB.element = this.unit.elements[gapSegment.end - 1];
        this.hasNext = this.gapIt.hasNext;
        return this.value;
    };
    return CoarsePolymerGapIterator;
}());
exports.CoarsePolymerGapIterator = CoarsePolymerGapIterator;
