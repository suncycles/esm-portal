"use strict";
/**
 * Copyright (c) 2018-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.eachInterBond = exports.getInterBondLoci = exports.eachIntraBond = exports.getIntraBondLoci = exports.BondIterator = exports.makeInterBondIgnoreTest = exports.makeIntraBondIgnoreTest = exports.ignoreBondType = exports.DefaultBondLineProps = exports.BondLineParams = exports.DefaultBondCylinderProps = exports.BondCylinderParams = exports.DefaultBondProps = exports.BondParams = void 0;
var tslib_1 = require("tslib");
var types_1 = require("../../../../mol-model/structure/model/types");
var structure_1 = require("../../../../mol-model/structure");
var param_definition_1 = require("../../../../mol-util/param-definition");
var location_iterator_1 = require("../../../../mol-geo/util/location-iterator");
var link_1 = require("./link");
var type_helpers_1 = require("../../../../mol-util/type-helpers");
var loci_1 = require("../../../../mol-model/loci");
var int_1 = require("../../../../mol-data/int");
var common_1 = require("./common");
exports.BondParams = {
    includeTypes: param_definition_1.ParamDefinition.MultiSelect((0, type_helpers_1.ObjectKeys)(types_1.BondType.Names), param_definition_1.ParamDefinition.objectToOptions(types_1.BondType.Names)),
    excludeTypes: param_definition_1.ParamDefinition.MultiSelect([], param_definition_1.ParamDefinition.objectToOptions(types_1.BondType.Names)),
    ignoreHydrogens: param_definition_1.ParamDefinition.Boolean(false),
    ignoreHydrogensVariant: param_definition_1.ParamDefinition.Select('all', param_definition_1.ParamDefinition.arrayToOptions(['all', 'non-polar'])),
    aromaticBonds: param_definition_1.ParamDefinition.Boolean(true, { description: 'Display aromatic bonds with dashes' }),
    multipleBonds: param_definition_1.ParamDefinition.Select('symmetric', param_definition_1.ParamDefinition.arrayToOptions(['off', 'symmetric', 'offset'])),
};
exports.DefaultBondProps = param_definition_1.ParamDefinition.getDefaultValues(exports.BondParams);
exports.BondCylinderParams = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, link_1.LinkCylinderParams), exports.BondParams), { adjustCylinderLength: param_definition_1.ParamDefinition.Boolean(false, { description: 'Shorten cylinders to reduce overlap with spheres. Useful for for transparent bonds. Not working well with aromatic bonds.' }) });
exports.DefaultBondCylinderProps = param_definition_1.ParamDefinition.getDefaultValues(exports.BondCylinderParams);
exports.BondLineParams = tslib_1.__assign(tslib_1.__assign({}, link_1.LinkLineParams), exports.BondParams);
exports.DefaultBondLineProps = param_definition_1.ParamDefinition.getDefaultValues(exports.BondLineParams);
function ignoreBondType(include, exclude, f) {
    return !types_1.BondType.is(include, f) || types_1.BondType.is(exclude, f);
}
exports.ignoreBondType = ignoreBondType;
function makeIntraBondIgnoreTest(structure, unit, props) {
    var elements = unit.elements;
    var bonds = unit.bonds;
    var a = bonds.a, b = bonds.b, edgeProps = bonds.edgeProps;
    var _flags = edgeProps.flags;
    var ignoreHydrogens = props.ignoreHydrogens, ignoreHydrogensVariant = props.ignoreHydrogensVariant, includeTypes = props.includeTypes, excludeTypes = props.excludeTypes;
    var include = types_1.BondType.fromNames(includeTypes);
    var exclude = types_1.BondType.fromNames(excludeTypes);
    var allBondTypes = types_1.BondType.isAll(include) && 0 /* BondType.Flag.None */ === exclude;
    var child = structure.child;
    var childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);
    if (child && !childUnit)
        throw new Error('expected childUnit to exist if child exists');
    if (allBondTypes && !ignoreHydrogens && !child)
        return;
    return function (edgeIndex) {
        var aI = a[edgeIndex];
        var bI = b[edgeIndex];
        if ((!!childUnit && !int_1.SortedArray.has(childUnit.elements, elements[aI]))) {
            return true;
        }
        if (!allBondTypes && ignoreBondType(include, exclude, _flags[edgeIndex])) {
            return true;
        }
        if (!ignoreHydrogens)
            return false;
        if ((0, common_1.isHydrogen)(structure, unit, elements[aI], ignoreHydrogensVariant) || (0, common_1.isHydrogen)(structure, unit, elements[bI], ignoreHydrogensVariant))
            return true;
        return false;
    };
}
exports.makeIntraBondIgnoreTest = makeIntraBondIgnoreTest;
function makeInterBondIgnoreTest(structure, props) {
    var bonds = structure.interUnitBonds;
    var edges = bonds.edges;
    var ignoreHydrogens = props.ignoreHydrogens, ignoreHydrogensVariant = props.ignoreHydrogensVariant, includeTypes = props.includeTypes, excludeTypes = props.excludeTypes;
    var include = types_1.BondType.fromNames(includeTypes);
    var exclude = types_1.BondType.fromNames(excludeTypes);
    var allBondTypes = types_1.BondType.isAll(include) && 0 /* BondType.Flag.None */ === exclude;
    var child = structure.child;
    if (allBondTypes && !ignoreHydrogens && !child)
        return;
    return function (edgeIndex) {
        if (child) {
            var b = edges[edgeIndex];
            var childUnitA = child.unitMap.get(b.unitA);
            if (!childUnitA)
                return true;
            var unitA = structure.unitMap.get(b.unitA);
            var eA = unitA.elements[b.indexA];
            if (!int_1.SortedArray.has(childUnitA.elements, eA))
                return true;
        }
        if (ignoreHydrogens) {
            var b = edges[edgeIndex];
            var uA = structure.unitMap.get(b.unitA);
            var uB = structure.unitMap.get(b.unitB);
            if ((0, common_1.isHydrogen)(structure, uA, uA.elements[b.indexA], ignoreHydrogensVariant) || (0, common_1.isHydrogen)(structure, uB, uB.elements[b.indexB], ignoreHydrogensVariant))
                return true;
        }
        if (!allBondTypes) {
            if (ignoreBondType(include, exclude, edges[edgeIndex].props.flag))
                return true;
        }
        return false;
    };
}
exports.makeInterBondIgnoreTest = makeInterBondIgnoreTest;
var BondIterator;
(function (BondIterator) {
    function fromGroup(structureGroup) {
        var group = structureGroup.group, structure = structureGroup.structure;
        var unit = group.units[0];
        var groupCount = structure_1.Unit.isAtomic(unit) ? unit.bonds.edgeCount * 2 : 0;
        var instanceCount = group.units.length;
        var location = structure_1.Bond.Location(structure, undefined, undefined, structure, undefined, undefined);
        var getLocation = function (groupIndex, instanceIndex) {
            var unit = group.units[instanceIndex];
            location.aUnit = unit;
            location.bUnit = unit;
            location.aIndex = unit.bonds.a[groupIndex];
            location.bIndex = unit.bonds.b[groupIndex];
            return location;
        };
        return (0, location_iterator_1.LocationIterator)(groupCount, instanceCount, 1, getLocation);
    }
    BondIterator.fromGroup = fromGroup;
    function fromStructure(structure) {
        var groupCount = structure.interUnitBonds.edgeCount;
        var instanceCount = 1;
        var location = structure_1.Bond.Location(structure, undefined, undefined, structure, undefined, undefined);
        var getLocation = function (groupIndex) {
            var bond = structure.interUnitBonds.edges[groupIndex];
            location.aUnit = structure.unitMap.get(bond.unitA);
            location.aIndex = bond.indexA;
            location.bUnit = structure.unitMap.get(bond.unitB);
            location.bIndex = bond.indexB;
            return location;
        };
        return (0, location_iterator_1.LocationIterator)(groupCount, instanceCount, 1, getLocation, true);
    }
    BondIterator.fromStructure = fromStructure;
})(BondIterator = exports.BondIterator || (exports.BondIterator = {}));
//
function getIntraBondLoci(pickingId, structureGroup, id) {
    var objectId = pickingId.objectId, instanceId = pickingId.instanceId, groupId = pickingId.groupId;
    if (id === objectId) {
        var structure = structureGroup.structure, group = structureGroup.group;
        var unit = group.units[instanceId];
        if (structure_1.Unit.isAtomic(unit)) {
            var target = structure.target;
            var iA = unit.bonds.a[groupId];
            var iB = unit.bonds.b[groupId];
            return structure_1.Bond.Loci(target, [
                structure_1.Bond.Location(target, unit, iA, target, unit, iB),
                structure_1.Bond.Location(target, unit, iB, target, unit, iA)
            ]);
        }
    }
    return loci_1.EmptyLoci;
}
exports.getIntraBondLoci = getIntraBondLoci;
function eachIntraBond(loci, structureGroup, apply, isMarking) {
    var changed = false;
    if (structure_1.Bond.isLoci(loci)) {
        var structure = structureGroup.structure, group = structureGroup.group;
        if (!structure_1.Structure.areEquivalent(loci.structure, structure))
            return false;
        var unit = group.units[0];
        if (!structure_1.Unit.isAtomic(unit))
            return false;
        var groupCount = unit.bonds.edgeCount * 2;
        for (var _i = 0, _a = loci.bonds; _i < _a.length; _i++) {
            var b = _a[_i];
            if (b.aUnit !== b.bUnit)
                continue;
            var unitIdx = group.unitIndexMap.get(b.aUnit.id);
            if (unitIdx !== undefined) {
                var idx = unit.bonds.getDirectedEdgeIndex(b.aIndex, b.bIndex);
                if (idx !== -1) {
                    if (apply(int_1.Interval.ofSingleton(unitIdx * groupCount + idx)))
                        changed = true;
                }
            }
        }
    }
    else if (structure_1.StructureElement.Loci.is(loci)) {
        var structure = structureGroup.structure, group = structureGroup.group;
        if (!structure_1.Structure.areEquivalent(loci.structure, structure))
            return false;
        var unit = group.units[0];
        if (!structure_1.Unit.isAtomic(unit))
            return false;
        var groupCount_1 = unit.bonds.edgeCount * 2;
        var _loop_1 = function (e) {
            var unitIdx = group.unitIndexMap.get(e.unit.id);
            if (unitIdx !== undefined) {
                var _d = unit.bonds, offset_1 = _d.offset, b_1 = _d.b;
                int_1.OrderedSet.forEach(e.indices, function (v) {
                    for (var t = offset_1[v], _t = offset_1[v + 1]; t < _t; t++) {
                        if (!isMarking || int_1.OrderedSet.has(e.indices, b_1[t])) {
                            if (apply(int_1.Interval.ofSingleton(unitIdx * groupCount_1 + t)))
                                changed = true;
                        }
                    }
                });
            }
        };
        for (var _b = 0, _c = loci.elements; _b < _c.length; _b++) {
            var e = _c[_b];
            _loop_1(e);
        }
    }
    return changed;
}
exports.eachIntraBond = eachIntraBond;
//
function getInterBondLoci(pickingId, structure, id) {
    var objectId = pickingId.objectId, groupId = pickingId.groupId;
    if (id === objectId) {
        var target = structure.target;
        var b = structure.interUnitBonds.edges[groupId];
        var uA = structure.unitMap.get(b.unitA);
        var uB = structure.unitMap.get(b.unitB);
        return structure_1.Bond.Loci(target, [
            structure_1.Bond.Location(target, uA, b.indexA, target, uB, b.indexB),
            structure_1.Bond.Location(target, uB, b.indexB, target, uA, b.indexA)
        ]);
    }
    return loci_1.EmptyLoci;
}
exports.getInterBondLoci = getInterBondLoci;
var __unitMap = new Map();
function eachInterBond(loci, structure, apply, isMarking) {
    var changed = false;
    if (structure_1.Bond.isLoci(loci)) {
        if (!structure_1.Structure.areEquivalent(loci.structure, structure))
            return false;
        for (var _i = 0, _a = loci.bonds; _i < _a.length; _i++) {
            var b = _a[_i];
            var idx = structure.interUnitBonds.getBondIndexFromLocation(b);
            if (idx !== -1) {
                if (apply(int_1.Interval.ofSingleton(idx)))
                    changed = true;
            }
        }
    }
    else if (structure_1.StructureElement.Loci.is(loci)) {
        if (!structure_1.Structure.areEquivalent(loci.structure, structure))
            return false;
        if (isMarking && loci.elements.length === 1)
            return false; // only a single unit
        for (var _b = 0, _c = loci.elements; _b < _c.length; _b++) {
            var e = _c[_b];
            __unitMap.set(e.unit.id, e.indices);
        }
        var _loop_2 = function (e) {
            var unit = e.unit;
            if (!structure_1.Unit.isAtomic(unit))
                return "continue";
            structure.interUnitBonds.getConnectedUnits(unit.id).forEach(function (b) {
                var otherLociIndices = __unitMap.get(b.unitB);
                if (!isMarking || otherLociIndices) {
                    int_1.OrderedSet.forEach(e.indices, function (v) {
                        if (!b.connectedIndices.includes(v))
                            return;
                        b.getEdges(v).forEach(function (bi) {
                            if (!isMarking || (otherLociIndices && int_1.OrderedSet.has(otherLociIndices, bi.indexB))) {
                                var idx = structure.interUnitBonds.getEdgeIndex(v, unit.id, bi.indexB, b.unitB);
                                if (apply(int_1.Interval.ofSingleton(idx)))
                                    changed = true;
                            }
                        });
                    });
                }
            });
        };
        for (var _d = 0, _e = loci.elements; _d < _e.length; _d++) {
            var e = _e[_d];
            _loop_2(e);
        }
        __unitMap.clear();
    }
    return changed;
}
exports.eachInterBond = eachInterBond;
