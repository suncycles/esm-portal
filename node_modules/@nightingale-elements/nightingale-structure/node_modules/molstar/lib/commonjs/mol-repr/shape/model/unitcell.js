"use strict";
/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnitcellRepresentation = exports.getUnitcellData = exports.UnitcellParams = void 0;
var tslib_1 = require("tslib");
var structure_1 = require("../../../mol-model/structure");
var representation_1 = require("../representation");
var shape_1 = require("../../../mol-model/shape");
var names_1 = require("../../../mol-util/color/names");
var param_definition_1 = require("../../../mol-util/param-definition");
var mesh_1 = require("../../../mol-geo/geometry/mesh/mesh");
var mesh_builder_1 = require("../../../mol-geo/geometry/mesh/mesh-builder");
var box_1 = require("../../../mol-geo/primitive/box");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var cage_1 = require("../../../mol-geo/primitive/cage");
var geometry_1 = require("../../../mol-math/geometry");
var representation_2 = require("../../representation");
var translate05 = linear_algebra_1.Mat4.fromTranslation((0, linear_algebra_1.Mat4)(), linear_algebra_1.Vec3.create(0.5, 0.5, 0.5));
var unitCage = (0, cage_1.transformCage)((0, cage_1.cloneCage)((0, box_1.BoxCage)()), translate05);
var tmpRef = (0, linear_algebra_1.Vec3)();
var tmpTranslate = (0, linear_algebra_1.Mat4)();
var CellRef = {
    origin: 'Origin',
    model: 'Model'
};
var CellAttachment = {
    corner: 'Corner',
    center: 'Center'
};
var CellParams = tslib_1.__assign(tslib_1.__assign({}, mesh_1.Mesh.Params), { cellColor: param_definition_1.ParamDefinition.Color(names_1.ColorNames.orange), cellScale: param_definition_1.ParamDefinition.Numeric(2, { min: 0.1, max: 5, step: 0.1 }), ref: param_definition_1.ParamDefinition.Select('model', param_definition_1.ParamDefinition.objectToOptions(CellRef), { isEssential: true }), attachment: param_definition_1.ParamDefinition.Select('corner', param_definition_1.ParamDefinition.objectToOptions(CellAttachment), { isEssential: true }) });
var UnitcellVisuals = {
    'mesh': function (ctx, getParams) { return (0, representation_1.ShapeRepresentation)(getUnitcellShape, mesh_1.Mesh.Utils); },
};
exports.UnitcellParams = tslib_1.__assign({}, CellParams);
function getUnitcellMesh(data, props, mesh) {
    var state = mesh_builder_1.MeshBuilder.createState(256, 128, mesh);
    var fromFractional = data.symmetry.spacegroup.cell.fromFractional;
    linear_algebra_1.Vec3.copy(tmpRef, data.ref);
    if (props.attachment === 'center') {
        linear_algebra_1.Vec3.trunc(tmpRef, tmpRef);
        linear_algebra_1.Vec3.subScalar(tmpRef, tmpRef, 0.5);
    }
    else {
        linear_algebra_1.Vec3.floor(tmpRef, tmpRef);
    }
    linear_algebra_1.Mat4.fromTranslation(tmpTranslate, tmpRef);
    var cellCage = (0, cage_1.transformCage)((0, cage_1.cloneCage)(unitCage), tmpTranslate);
    var radius = (Math.cbrt(data.symmetry.spacegroup.cell.volume) / 300) * props.cellScale;
    state.currentGroup = 1;
    mesh_builder_1.MeshBuilder.addCage(state, fromFractional, cellCage, radius, 2, 20);
    var sphere = geometry_1.Sphere3D.fromDimensionsAndTransform((0, geometry_1.Sphere3D)(), linear_algebra_1.Vec3.unit, fromFractional);
    linear_algebra_1.Vec3.transformMat4(tmpRef, tmpRef, fromFractional);
    geometry_1.Sphere3D.translate(sphere, sphere, tmpRef);
    geometry_1.Sphere3D.expand(sphere, sphere, radius);
    var m = mesh_builder_1.MeshBuilder.getMesh(state);
    m.setBoundingSphere(sphere);
    return m;
}
function getUnitcellShape(ctx, data, props, shape) {
    var geo = getUnitcellMesh(data, props, shape && shape.geometry);
    var label = structure_1.Symmetry.getUnitcellLabel(data.symmetry);
    return shape_1.Shape.create(label, data, geo, function () { return props.cellColor; }, function () { return 1; }, function () { return label; });
}
//
function getUnitcellData(model, symmetry, props) {
    var ref = (0, linear_algebra_1.Vec3)();
    if (props.ref === 'model') {
        linear_algebra_1.Vec3.transformMat4(ref, structure_1.Model.getCenter(model), symmetry.spacegroup.cell.toFractional);
    }
    return { symmetry: symmetry, ref: ref };
}
exports.getUnitcellData = getUnitcellData;
function UnitcellRepresentation(ctx, getParams) {
    return representation_2.Representation.createMulti('Unit Cell', ctx, getParams, representation_2.Representation.StateBuilder, UnitcellVisuals);
}
exports.UnitcellRepresentation = UnitcellRepresentation;
