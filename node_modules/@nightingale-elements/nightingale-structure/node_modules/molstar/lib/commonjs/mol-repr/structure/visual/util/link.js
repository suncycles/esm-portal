"use strict";
/**
 * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Zhenyu Zhang <jump2cn@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLinkLines = exports.createLinkCylinderImpostors = exports.createLinkCylinderMesh = exports.calculateShiftDir = exports.DefaultLinkLineProps = exports.LinkLineParams = exports.DefaultLinkCylinderProps = exports.LinkCylinderParams = void 0;
var linear_algebra_1 = require("../../../../mol-math/linear-algebra");
var param_definition_1 = require("../../../../mol-util/param-definition");
var mesh_1 = require("../../../../mol-geo/geometry/mesh/mesh");
var mesh_builder_1 = require("../../../../mol-geo/geometry/mesh/mesh-builder");
var cylinder_1 = require("../../../../mol-geo/geometry/mesh/builder/cylinder");
var base_1 = require("../../../../mol-geo/geometry/base");
var lines_1 = require("../../../../mol-geo/geometry/lines/lines");
var lines_builder_1 = require("../../../../mol-geo/geometry/lines/lines-builder");
var cylinders_1 = require("../../../../mol-geo/geometry/cylinders/cylinders");
var cylinders_builder_1 = require("../../../../mol-geo/geometry/cylinders/cylinders-builder");
var sphere3d_1 = require("../../../../mol-math/geometry/primitives/sphere3d");
exports.LinkCylinderParams = {
    linkScale: param_definition_1.ParamDefinition.Numeric(0.45, { min: 0, max: 1, step: 0.01 }),
    linkSpacing: param_definition_1.ParamDefinition.Numeric(1, { min: 0, max: 2, step: 0.01 }),
    linkCap: param_definition_1.ParamDefinition.Boolean(false),
    aromaticScale: param_definition_1.ParamDefinition.Numeric(0.3, { min: 0, max: 1, step: 0.01 }),
    aromaticSpacing: param_definition_1.ParamDefinition.Numeric(1.5, { min: 0, max: 3, step: 0.01 }),
    aromaticDashCount: param_definition_1.ParamDefinition.Numeric(2, { min: 2, max: 6, step: 2 }),
    dashCount: param_definition_1.ParamDefinition.Numeric(4, { min: 0, max: 10, step: 2 }),
    dashScale: param_definition_1.ParamDefinition.Numeric(0.8, { min: 0, max: 2, step: 0.1 }),
    dashCap: param_definition_1.ParamDefinition.Boolean(true),
    stubCap: param_definition_1.ParamDefinition.Boolean(true),
    radialSegments: param_definition_1.ParamDefinition.Numeric(16, { min: 2, max: 56, step: 2 }, base_1.BaseGeometry.CustomQualityParamInfo),
};
exports.DefaultLinkCylinderProps = param_definition_1.ParamDefinition.getDefaultValues(exports.LinkCylinderParams);
exports.LinkLineParams = {
    linkScale: param_definition_1.ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.1 }),
    linkSpacing: param_definition_1.ParamDefinition.Numeric(0.1, { min: 0, max: 2, step: 0.01 }),
    aromaticDashCount: param_definition_1.ParamDefinition.Numeric(2, { min: 2, max: 6, step: 2 }),
    dashCount: param_definition_1.ParamDefinition.Numeric(4, { min: 0, max: 10, step: 2 }),
};
exports.DefaultLinkLineProps = param_definition_1.ParamDefinition.getDefaultValues(exports.LinkLineParams);
var tmpV12 = (0, linear_algebra_1.Vec3)();
var tmpShiftV12 = (0, linear_algebra_1.Vec3)();
var tmpShiftV13 = (0, linear_algebra_1.Vec3)();
var up = linear_algebra_1.Vec3.create(0, 1, 0);
/** Calculate 'shift' direction that is perpendiculat to v1 - v2 and goes through v3 */
function calculateShiftDir(out, v1, v2, v3) {
    linear_algebra_1.Vec3.normalize(tmpShiftV12, linear_algebra_1.Vec3.sub(tmpShiftV12, v1, v2));
    if (v3 !== null) {
        linear_algebra_1.Vec3.sub(tmpShiftV13, v1, v3);
    }
    else {
        linear_algebra_1.Vec3.copy(tmpShiftV13, v1); // no reference point, use v1
    }
    linear_algebra_1.Vec3.normalize(tmpShiftV13, tmpShiftV13);
    // ensure v13 and v12 are not colinear
    var dp = linear_algebra_1.Vec3.dot(tmpShiftV12, tmpShiftV13);
    if (1 - Math.abs(dp) < 1e-5) {
        linear_algebra_1.Vec3.set(tmpShiftV13, 1, 0, 0);
        dp = linear_algebra_1.Vec3.dot(tmpShiftV12, tmpShiftV13);
        if (1 - Math.abs(dp) < 1e-5) {
            linear_algebra_1.Vec3.set(tmpShiftV13, 0, 1, 0);
            dp = linear_algebra_1.Vec3.dot(tmpShiftV12, tmpShiftV13);
        }
    }
    linear_algebra_1.Vec3.setMagnitude(tmpShiftV12, tmpShiftV12, dp);
    linear_algebra_1.Vec3.sub(tmpShiftV13, tmpShiftV13, tmpShiftV12);
    return linear_algebra_1.Vec3.normalize(out, tmpShiftV13);
}
exports.calculateShiftDir = calculateShiftDir;
// avoiding namespace lookup improved performance in Chrome (Aug 2020)
var v3scale = linear_algebra_1.Vec3.scale;
var v3add = linear_algebra_1.Vec3.add;
var v3sub = linear_algebra_1.Vec3.sub;
var v3setMagnitude = linear_algebra_1.Vec3.setMagnitude;
var v3dot = linear_algebra_1.Vec3.dot;
/**
 * Each edge is included twice to allow for coloring/picking
 * the half closer to the first vertex, i.e. vertex a.
 */
function createLinkCylinderMesh(ctx, linkBuilder, props, mesh) {
    var linkCount = linkBuilder.linkCount, referencePosition = linkBuilder.referencePosition, position = linkBuilder.position, style = linkBuilder.style, radius = linkBuilder.radius, ignore = linkBuilder.ignore, stub = linkBuilder.stub;
    if (!linkCount)
        return { mesh: mesh_1.Mesh.createEmpty(mesh) };
    var linkScale = props.linkScale, linkSpacing = props.linkSpacing, radialSegments = props.radialSegments, linkCap = props.linkCap, aromaticScale = props.aromaticScale, aromaticSpacing = props.aromaticSpacing, aromaticDashCount = props.aromaticDashCount, dashCount = props.dashCount, dashScale = props.dashScale, dashCap = props.dashCap, stubCap = props.stubCap;
    var vertexCountEstimate = radialSegments * 2 * linkCount * 2;
    var builderState = mesh_builder_1.MeshBuilder.createState(vertexCountEstimate, vertexCountEstimate / 4, mesh);
    var va = (0, linear_algebra_1.Vec3)();
    var vb = (0, linear_algebra_1.Vec3)();
    var vShift = (0, linear_algebra_1.Vec3)();
    var center = (0, linear_algebra_1.Vec3)();
    var count = 0;
    var cylinderProps = {
        radiusTop: 1,
        radiusBottom: 1,
        radialSegments: radialSegments,
        topCap: linkCap,
        bottomCap: linkCap
    };
    var segmentCount = dashCount + 1;
    for (var edgeIndex = 0, _eI = linkCount; edgeIndex < _eI; ++edgeIndex) {
        if (ignore && ignore(edgeIndex))
            continue;
        position(va, vb, edgeIndex);
        v3add(center, center, va);
        v3add(center, center, vb);
        count += 2;
        v3sub(tmpV12, vb, va);
        var dirFlag = v3dot(tmpV12, up) > 0;
        var linkRadius = radius(edgeIndex);
        var linkStyle = style ? style(edgeIndex) : 0 /* LinkStyle.Solid */;
        var linkStub = stubCap && (stub ? stub(edgeIndex) : false);
        var _a = dirFlag ? [linkStub, linkCap] : [linkCap, linkStub], topCap = _a[0], bottomCap = _a[1];
        builderState.currentGroup = edgeIndex;
        var aromaticSegmentCount = aromaticDashCount + 1;
        if (linkStyle === 0 /* LinkStyle.Solid */) {
            cylinderProps.radiusTop = cylinderProps.radiusBottom = linkRadius;
            cylinderProps.topCap = topCap;
            cylinderProps.bottomCap = bottomCap;
            (0, cylinder_1.addCylinder)(builderState, va, vb, 0.5, cylinderProps);
        }
        else if (linkStyle === 1 /* LinkStyle.Dashed */) {
            cylinderProps.radiusTop = cylinderProps.radiusBottom = linkRadius * dashScale;
            cylinderProps.topCap = cylinderProps.bottomCap = dashCap;
            if (segmentCount > 1) {
                (0, cylinder_1.addFixedCountDashedCylinder)(builderState, va, vb, 0.5, segmentCount, cylinderProps);
            }
            else {
                (0, cylinder_1.addCylinder)(builderState, va, vb, 0.5, cylinderProps);
            }
        }
        else if (linkStyle === 2 /* LinkStyle.Double */ || linkStyle === 3 /* LinkStyle.OffsetDouble */ || linkStyle === 4 /* LinkStyle.Triple */ || linkStyle === 5 /* LinkStyle.OffsetTriple */ || linkStyle === 7 /* LinkStyle.Aromatic */ || linkStyle === 8 /* LinkStyle.MirroredAromatic */) {
            var order = (linkStyle === 2 /* LinkStyle.Double */ || linkStyle === 3 /* LinkStyle.OffsetDouble */) ? 2 :
                (linkStyle === 4 /* LinkStyle.Triple */ || linkStyle === 5 /* LinkStyle.OffsetTriple */) ? 3 : 1.5;
            var multiRadius = linkRadius * (linkScale / (0.5 * order));
            var absOffset = (linkRadius - multiRadius) * linkSpacing;
            calculateShiftDir(vShift, va, vb, referencePosition ? referencePosition(edgeIndex) : null);
            cylinderProps.topCap = topCap;
            cylinderProps.bottomCap = bottomCap;
            if (linkStyle === 7 /* LinkStyle.Aromatic */ || linkStyle === 8 /* LinkStyle.MirroredAromatic */) {
                cylinderProps.radiusTop = cylinderProps.radiusBottom = linkRadius;
                (0, cylinder_1.addCylinder)(builderState, va, vb, 0.5, cylinderProps);
                var aromaticOffset = linkRadius + aromaticScale * linkRadius + aromaticScale * linkRadius * aromaticSpacing;
                v3setMagnitude(tmpV12, v3sub(tmpV12, vb, va), linkRadius * 0.5);
                v3add(va, va, tmpV12);
                v3sub(vb, vb, tmpV12);
                cylinderProps.radiusTop = cylinderProps.radiusBottom = linkRadius * aromaticScale;
                cylinderProps.topCap = cylinderProps.bottomCap = dashCap;
                v3setMagnitude(vShift, vShift, aromaticOffset);
                v3sub(va, va, vShift);
                v3sub(vb, vb, vShift);
                (0, cylinder_1.addFixedCountDashedCylinder)(builderState, va, vb, 0.5, aromaticSegmentCount, cylinderProps);
                if (linkStyle === 8 /* LinkStyle.MirroredAromatic */) {
                    v3setMagnitude(vShift, vShift, aromaticOffset * 2);
                    v3add(va, va, vShift);
                    v3add(vb, vb, vShift);
                    (0, cylinder_1.addFixedCountDashedCylinder)(builderState, va, vb, 0.5, aromaticSegmentCount, cylinderProps);
                }
            }
            else if (linkStyle === 3 /* LinkStyle.OffsetDouble */ || linkStyle === 5 /* LinkStyle.OffsetTriple */) {
                var multipleOffset = linkRadius + multiRadius + linkScale * linkRadius * linkSpacing;
                v3setMagnitude(vShift, vShift, multipleOffset);
                cylinderProps.radiusTop = cylinderProps.radiusBottom = linkRadius;
                (0, cylinder_1.addCylinder)(builderState, va, vb, 0.5, cylinderProps);
                v3scale(tmpV12, tmpV12, linkSpacing * linkScale * 0.2);
                v3add(va, va, tmpV12);
                v3sub(vb, vb, tmpV12);
                cylinderProps.radiusTop = cylinderProps.radiusBottom = multiRadius;
                cylinderProps.topCap = dirFlag ? linkStub : dashCap;
                cylinderProps.bottomCap = dirFlag ? dashCap : linkStub;
                v3setMagnitude(vShift, vShift, multipleOffset);
                v3sub(va, va, vShift);
                v3sub(vb, vb, vShift);
                (0, cylinder_1.addCylinder)(builderState, va, vb, 0.5, cylinderProps);
                if (order === 3) {
                    v3setMagnitude(vShift, vShift, multipleOffset * 2);
                    v3add(va, va, vShift);
                    v3add(vb, vb, vShift);
                    (0, cylinder_1.addCylinder)(builderState, va, vb, 0.5, cylinderProps);
                }
            }
            else {
                v3setMagnitude(vShift, vShift, absOffset);
                cylinderProps.radiusTop = cylinderProps.radiusBottom = multiRadius;
                if (order === 3)
                    (0, cylinder_1.addCylinder)(builderState, va, vb, 0.5, cylinderProps);
                (0, cylinder_1.addDoubleCylinder)(builderState, va, vb, 0.5, vShift, cylinderProps);
            }
        }
        else if (linkStyle === 6 /* LinkStyle.Disk */) {
            v3scale(tmpV12, tmpV12, 0.475);
            v3add(va, va, tmpV12);
            v3sub(vb, vb, tmpV12);
            cylinderProps.radiusTop = cylinderProps.radiusBottom = linkRadius;
            cylinderProps.topCap = topCap;
            cylinderProps.bottomCap = bottomCap;
            (0, cylinder_1.addCylinder)(builderState, va, vb, 0.5, cylinderProps);
        }
    }
    var oldBoundingSphere = mesh ? sphere3d_1.Sphere3D.clone(mesh.boundingSphere) : undefined;
    var m = mesh_builder_1.MeshBuilder.getMesh(builderState);
    if (count === 0)
        return { mesh: m };
    // re-use boundingSphere if it has not changed much
    linear_algebra_1.Vec3.scale(center, center, 1 / count);
    if (oldBoundingSphere && linear_algebra_1.Vec3.distance(center, oldBoundingSphere.center) / oldBoundingSphere.radius < 1.0) {
        return { mesh: m, boundingSphere: oldBoundingSphere };
    }
    else {
        return { mesh: m };
    }
}
exports.createLinkCylinderMesh = createLinkCylinderMesh;
/**
 * Each edge is included twice to allow for coloring/picking
 * the half closer to the first vertex, i.e. vertex a.
 */
function createLinkCylinderImpostors(ctx, linkBuilder, props, cylinders) {
    var linkCount = linkBuilder.linkCount, referencePosition = linkBuilder.referencePosition, position = linkBuilder.position, style = linkBuilder.style, radius = linkBuilder.radius, ignore = linkBuilder.ignore, stub = linkBuilder.stub;
    if (!linkCount)
        return { cylinders: cylinders_1.Cylinders.createEmpty(cylinders) };
    var linkScale = props.linkScale, linkSpacing = props.linkSpacing, linkCap = props.linkCap, aromaticScale = props.aromaticScale, aromaticSpacing = props.aromaticSpacing, aromaticDashCount = props.aromaticDashCount, dashCount = props.dashCount, dashScale = props.dashScale, dashCap = props.dashCap, stubCap = props.stubCap;
    var cylindersCountEstimate = linkCount * 2;
    var builder = cylinders_builder_1.CylindersBuilder.create(cylindersCountEstimate, cylindersCountEstimate / 4, cylinders);
    var va = (0, linear_algebra_1.Vec3)();
    var vb = (0, linear_algebra_1.Vec3)();
    var vm = (0, linear_algebra_1.Vec3)();
    var vShift = (0, linear_algebra_1.Vec3)();
    var center = (0, linear_algebra_1.Vec3)();
    var count = 0;
    // automatically adjust length for evenly spaced dashed cylinders
    var segmentCount = dashCount % 2 === 1 ? dashCount : dashCount + 1;
    var lengthScale = 0.5 - (0.5 / 2 / segmentCount);
    var aromaticSegmentCount = aromaticDashCount + 1;
    var aromaticLengthScale = 0.5 - (0.5 / 2 / aromaticSegmentCount);
    for (var edgeIndex = 0, _eI = linkCount; edgeIndex < _eI; ++edgeIndex) {
        if (ignore && ignore(edgeIndex))
            continue;
        position(va, vb, edgeIndex);
        v3add(center, center, va);
        v3add(center, center, vb);
        count += 2;
        var linkRadius = radius(edgeIndex);
        var linkStyle = style ? style(edgeIndex) : 0 /* LinkStyle.Solid */;
        var linkStub = stubCap && (stub ? stub(edgeIndex) : false);
        if (linkStyle === 0 /* LinkStyle.Solid */) {
            v3scale(vm, v3add(vm, va, vb), 0.5);
            builder.add(va[0], va[1], va[2], vm[0], vm[1], vm[2], 1, linkCap, linkStub, edgeIndex);
        }
        else if (linkStyle === 1 /* LinkStyle.Dashed */) {
            if (segmentCount > 1) {
                v3scale(tmpV12, v3sub(tmpV12, vb, va), lengthScale);
                v3sub(vb, vb, tmpV12);
                builder.addFixedCountDashes(va, vb, segmentCount, dashScale, dashCap, dashCap, edgeIndex);
            }
            else {
                v3scale(vm, v3add(vm, va, vb), 0.5);
                builder.add(va[0], va[1], va[2], vm[0], vm[1], vm[2], dashScale, dashCap, dashCap, edgeIndex);
            }
        }
        else if (linkStyle === 2 /* LinkStyle.Double */ || linkStyle === 3 /* LinkStyle.OffsetDouble */ || linkStyle === 4 /* LinkStyle.Triple */ || linkStyle === 5 /* LinkStyle.OffsetTriple */ || linkStyle === 7 /* LinkStyle.Aromatic */ || linkStyle === 8 /* LinkStyle.MirroredAromatic */) {
            var order = (linkStyle === 2 /* LinkStyle.Double */ || linkStyle === 3 /* LinkStyle.OffsetDouble */) ? 2 :
                (linkStyle === 4 /* LinkStyle.Triple */ || linkStyle === 5 /* LinkStyle.OffsetTriple */) ? 3 : 1.5;
            var multiScale = linkScale / (0.5 * order);
            var absOffset = (linkRadius - multiScale * linkRadius) * linkSpacing;
            v3scale(vm, v3add(vm, va, vb), 0.5);
            calculateShiftDir(vShift, va, vb, referencePosition ? referencePosition(edgeIndex) : null);
            if (linkStyle === 7 /* LinkStyle.Aromatic */ || linkStyle === 8 /* LinkStyle.MirroredAromatic */) {
                builder.add(va[0], va[1], va[2], vm[0], vm[1], vm[2], 1, linkCap, linkStub, edgeIndex);
                var aromaticOffset = linkRadius + aromaticScale * linkRadius + aromaticScale * linkRadius * aromaticSpacing;
                v3scale(tmpV12, v3sub(tmpV12, vb, va), aromaticLengthScale);
                v3sub(vb, vb, tmpV12);
                v3setMagnitude(tmpV12, v3sub(tmpV12, vb, va), linkRadius * 0.5);
                v3add(va, va, tmpV12);
                v3setMagnitude(vShift, vShift, aromaticOffset);
                v3sub(va, va, vShift);
                v3sub(vb, vb, vShift);
                builder.addFixedCountDashes(va, vb, aromaticSegmentCount, aromaticScale, dashCap, dashCap, edgeIndex);
                if (linkStyle === 8 /* LinkStyle.MirroredAromatic */) {
                    v3setMagnitude(vShift, vShift, aromaticOffset * 2);
                    v3add(va, va, vShift);
                    v3add(vb, vb, vShift);
                    builder.addFixedCountDashes(va, vb, aromaticSegmentCount, aromaticScale, dashCap, dashCap, edgeIndex);
                }
            }
            else if (linkStyle === 3 /* LinkStyle.OffsetDouble */ || linkStyle === 5 /* LinkStyle.OffsetTriple */) {
                var multipleOffset = linkRadius + multiScale * linkRadius + linkScale * linkRadius * linkSpacing;
                v3setMagnitude(vShift, vShift, multipleOffset);
                builder.add(va[0], va[1], va[2], vm[0], vm[1], vm[2], 1, linkCap, linkStub, edgeIndex);
                v3setMagnitude(tmpV12, v3sub(tmpV12, va, vb), linkRadius / 1.5);
                v3sub(va, va, tmpV12);
                if (order === 3)
                    builder.add(va[0] + vShift[0], va[1] + vShift[1], va[2] + vShift[2], vm[0] + vShift[0], vm[1] + vShift[1], vm[2] + vShift[2], multiScale, linkCap, linkStub, edgeIndex);
                builder.add(va[0] - vShift[0], va[1] - vShift[1], va[2] - vShift[2], vm[0] - vShift[0], vm[1] - vShift[1], vm[2] - vShift[2], multiScale, dashCap, linkStub, edgeIndex);
            }
            else {
                v3setMagnitude(vShift, vShift, absOffset);
                if (order === 3)
                    builder.add(va[0], va[1], va[2], vm[0], vm[1], vm[2], multiScale, linkCap, linkStub, edgeIndex);
                builder.add(va[0] + vShift[0], va[1] + vShift[1], va[2] + vShift[2], vm[0] + vShift[0], vm[1] + vShift[1], vm[2] + vShift[2], multiScale, linkCap, linkStub, edgeIndex);
                builder.add(va[0] - vShift[0], va[1] - vShift[1], va[2] - vShift[2], vm[0] - vShift[0], vm[1] - vShift[1], vm[2] - vShift[2], multiScale, linkCap, linkStub, edgeIndex);
            }
        }
        else if (linkStyle === 6 /* LinkStyle.Disk */) {
            v3scale(tmpV12, v3sub(tmpV12, vb, va), 0.475);
            v3add(va, va, tmpV12);
            v3sub(vb, vb, tmpV12);
            builder.add(va[0], va[1], va[2], vb[0], vb[1], vb[2], 1, linkCap, linkStub, edgeIndex);
        }
    }
    var oldBoundingSphere = cylinders ? sphere3d_1.Sphere3D.clone(cylinders.boundingSphere) : undefined;
    var c = builder.getCylinders();
    if (count === 0)
        return { cylinders: c };
    // re-use boundingSphere if it has not changed much
    linear_algebra_1.Vec3.scale(center, center, 1 / count);
    if (oldBoundingSphere && linear_algebra_1.Vec3.distance(center, oldBoundingSphere.center) / oldBoundingSphere.radius < 1.0) {
        return { cylinders: c, boundingSphere: oldBoundingSphere };
    }
    else {
        return { cylinders: c };
    }
}
exports.createLinkCylinderImpostors = createLinkCylinderImpostors;
/**
 * Each edge is included twice to allow for coloring/picking
 * the half closer to the first vertex, i.e. vertex a.
 */
function createLinkLines(ctx, linkBuilder, props, lines) {
    var linkCount = linkBuilder.linkCount, referencePosition = linkBuilder.referencePosition, position = linkBuilder.position, style = linkBuilder.style, ignore = linkBuilder.ignore;
    if (!linkCount)
        return { lines: lines_1.Lines.createEmpty(lines) };
    var linkScale = props.linkScale, linkSpacing = props.linkSpacing, aromaticDashCount = props.aromaticDashCount, dashCount = props.dashCount;
    var linesCountEstimate = linkCount * 2;
    var builder = lines_builder_1.LinesBuilder.create(linesCountEstimate, linesCountEstimate / 4, lines);
    var va = (0, linear_algebra_1.Vec3)();
    var vb = (0, linear_algebra_1.Vec3)();
    var vm = (0, linear_algebra_1.Vec3)();
    var vShift = (0, linear_algebra_1.Vec3)();
    var center = (0, linear_algebra_1.Vec3)();
    var count = 0;
    // automatically adjust length for evenly spaced dashed lines
    var segmentCount = dashCount % 2 === 1 ? dashCount : dashCount + 1;
    var lengthScale = 0.5 - (0.5 / 2 / segmentCount);
    var aromaticSegmentCount = aromaticDashCount + 1;
    var aromaticLengthScale = 0.5 - (0.5 / 2 / aromaticSegmentCount);
    var aromaticOffsetFactor = 4.5;
    var multipleOffsetFactor = 3;
    for (var edgeIndex = 0, _eI = linkCount; edgeIndex < _eI; ++edgeIndex) {
        if (ignore && ignore(edgeIndex))
            continue;
        position(va, vb, edgeIndex);
        v3add(center, center, va);
        v3add(center, center, vb);
        count += 2;
        var linkStyle = style ? style(edgeIndex) : 0 /* LinkStyle.Solid */;
        if (linkStyle === 0 /* LinkStyle.Solid */) {
            v3scale(vm, v3add(vm, va, vb), 0.5);
            builder.add(va[0], va[1], va[2], vm[0], vm[1], vm[2], edgeIndex);
        }
        else if (linkStyle === 1 /* LinkStyle.Dashed */) {
            if (segmentCount > 1) {
                v3scale(tmpV12, v3sub(tmpV12, vb, va), lengthScale);
                v3sub(vb, vb, tmpV12);
                builder.addFixedCountDashes(va, vb, segmentCount, edgeIndex);
            }
            else {
                v3scale(vm, v3add(vm, va, vb), 0.5);
                builder.add(va[0], va[1], va[2], vm[0], vm[1], vm[2], edgeIndex);
            }
        }
        else if (linkStyle === 2 /* LinkStyle.Double */ || linkStyle === 3 /* LinkStyle.OffsetDouble */ || linkStyle === 4 /* LinkStyle.Triple */ || linkStyle === 5 /* LinkStyle.OffsetTriple */ || linkStyle === 7 /* LinkStyle.Aromatic */ || linkStyle === 8 /* LinkStyle.MirroredAromatic */) {
            var order = linkStyle === 2 /* LinkStyle.Double */ || linkStyle === 3 /* LinkStyle.OffsetDouble */ ? 2 :
                linkStyle === 4 /* LinkStyle.Triple */ || linkStyle === 5 /* LinkStyle.OffsetTriple */ ? 3 : 1.5;
            var multiRadius = 1 * (linkScale / (0.5 * order));
            var absOffset = (1 - multiRadius) * linkSpacing;
            v3scale(vm, v3add(vm, va, vb), 0.5);
            calculateShiftDir(vShift, va, vb, referencePosition ? referencePosition(edgeIndex) : null);
            if (linkStyle === 7 /* LinkStyle.Aromatic */ || linkStyle === 8 /* LinkStyle.MirroredAromatic */) {
                builder.add(va[0], va[1], va[2], vm[0], vm[1], vm[2], edgeIndex);
                v3scale(tmpV12, v3sub(tmpV12, vb, va), aromaticLengthScale);
                v3sub(vb, vb, tmpV12);
                v3setMagnitude(vShift, vShift, absOffset * aromaticOffsetFactor);
                v3sub(va, va, vShift);
                v3sub(vb, vb, vShift);
                builder.addFixedCountDashes(va, vb, aromaticSegmentCount, edgeIndex);
                if (linkStyle === 8 /* LinkStyle.MirroredAromatic */) {
                    v3setMagnitude(vShift, vShift, absOffset * aromaticOffsetFactor * 2);
                    v3add(va, va, vShift);
                    v3add(vb, vb, vShift);
                    builder.addFixedCountDashes(va, vb, aromaticSegmentCount, edgeIndex);
                }
            }
            else if (linkStyle === 3 /* LinkStyle.OffsetDouble */ || linkStyle === 5 /* LinkStyle.OffsetTriple */) {
                v3setMagnitude(vShift, vShift, absOffset * multipleOffsetFactor);
                builder.add(va[0], va[1], va[2], vm[0], vm[1], vm[2], edgeIndex);
                v3scale(tmpV12, v3sub(tmpV12, va, vb), linkSpacing * linkScale);
                v3sub(va, va, tmpV12);
                if (order === 3)
                    builder.add(va[0] + vShift[0], va[1] + vShift[1], va[2] + vShift[2], vm[0] + vShift[0], vm[1] + vShift[1], vm[2] + vShift[2], edgeIndex);
                builder.add(va[0] - vShift[0], va[1] - vShift[1], va[2] - vShift[2], vm[0] - vShift[0], vm[1] - vShift[1], vm[2] - vShift[2], edgeIndex);
            }
            else {
                v3setMagnitude(vShift, vShift, absOffset * 1.5);
                if (order === 3)
                    builder.add(va[0], va[1], va[2], vm[0], vm[1], vm[2], edgeIndex);
                builder.add(va[0] + vShift[0], va[1] + vShift[1], va[2] + vShift[2], vm[0] + vShift[0], vm[1] + vShift[1], vm[2] + vShift[2], edgeIndex);
                builder.add(va[0] - vShift[0], va[1] - vShift[1], va[2] - vShift[2], vm[0] - vShift[0], vm[1] - vShift[1], vm[2] - vShift[2], edgeIndex);
            }
        }
        else if (linkStyle === 6 /* LinkStyle.Disk */) {
            v3scale(tmpV12, v3sub(tmpV12, vb, va), 0.475);
            v3add(va, va, tmpV12);
            v3sub(vb, vb, tmpV12);
            // TODO what to do here? Line as disk doesn't work well.
            builder.add(va[0], va[1], va[2], vb[0], vb[1], vb[2], edgeIndex);
        }
    }
    var oldBoundingSphere = lines ? sphere3d_1.Sphere3D.clone(lines.boundingSphere) : undefined;
    var l = builder.getLines();
    if (count === 0)
        return { lines: l };
    // re-use boundingSphere if it has not changed much
    linear_algebra_1.Vec3.scale(center, center, 1 / count);
    if (oldBoundingSphere && linear_algebra_1.Vec3.distance(center, oldBoundingSphere.center) / oldBoundingSphere.radius < 1.0) {
        return { lines: l, boundingSphere: oldBoundingSphere };
    }
    else {
        return { lines: l };
    }
}
exports.createLinkLines = createLinkLines;
