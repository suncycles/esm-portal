"use strict";
/**
 * Copyright (c) 2018-2023 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnitsTextureMeshVisual = exports.UnitsTextureMeshParams = exports.UnitsDirectVolumeVisual = exports.UnitsDirectVolumeParams = exports.UnitsTextVisual = exports.UnitsTextParams = exports.UnitsLinesVisual = exports.UnitsLinesParams = exports.UnitsPointsVisual = exports.UnitsPointsParams = exports.UnitsCylindersVisual = exports.UnitsCylindersParams = exports.UnitsSpheresVisual = exports.UnitsSpheresParams = exports.UnitsMeshVisual = exports.UnitsMeshParams = exports.UnitsVisual = void 0;
var tslib_1 = require("tslib");
var structure_1 = require("../../mol-model/structure");
var visual_1 = require("../visual");
var geometry_1 = require("../../mol-geo/geometry/geometry");
var theme_1 = require("../../mol-theme/theme");
var common_1 = require("./visual/util/common");
var render_object_1 = require("../../mol-gl/render-object");
var loci_1 = require("../../mol-model/loci");
var int_1 = require("../../mol-data/int");
var util_1 = require("../util");
var color_1 = require("../../mol-theme/color");
var marker_data_1 = require("../../mol-geo/geometry/marker-data");
var marker_action_1 = require("../../mol-util/marker-action");
var mol_util_1 = require("../../mol-util");
var size_data_1 = require("../../mol-geo/geometry/size-data");
var color_data_1 = require("../../mol-geo/geometry/color-data");
var mesh_1 = require("../../mol-geo/geometry/mesh/mesh");
var size_1 = require("../../mol-theme/size");
var spheres_1 = require("../../mol-geo/geometry/spheres/spheres");
var cylinders_1 = require("../../mol-geo/geometry/cylinders/cylinders");
var points_1 = require("../../mol-geo/geometry/points/points");
var lines_1 = require("../../mol-geo/geometry/lines/lines");
var text_1 = require("../../mol-geo/geometry/text/text");
var direct_volume_1 = require("../../mol-geo/geometry/direct-volume/direct-volume");
var texture_mesh_1 = require("../../mol-geo/geometry/texture-mesh/texture-mesh");
var params_1 = require("./params");
var type_helpers_1 = require("../../mol-util/type-helpers");
function createUnitsRenderObject(structureGroup, geometry, locationIt, theme, props, materialId) {
    var _a = geometry_1.Geometry.getUtils(geometry), createValues = _a.createValues, createRenderableState = _a.createRenderableState;
    var transform = (0, common_1.createUnitsTransform)(structureGroup, props.includeParent);
    var values = createValues(geometry, transform, locationIt, theme, props);
    var state = createRenderableState(props);
    return (0, render_object_1.createRenderObject)(geometry.kind, values, state, materialId);
}
function UnitsVisual(builder, materialId) {
    var defaultProps = builder.defaultProps, createGeometry = builder.createGeometry, createLocationIterator = builder.createLocationIterator, getLoci = builder.getLoci, eachLocation = builder.eachLocation, setUpdateState = builder.setUpdateState, mustRecreate = builder.mustRecreate, processValues = builder.processValues, dispose = builder.dispose;
    var _a = builder.geometryUtils, createEmptyGeometry = _a.createEmpty, updateValues = _a.updateValues, updateBoundingSphere = _a.updateBoundingSphere, updateRenderableState = _a.updateRenderableState, createPositionIterator = _a.createPositionIterator;
    var updateState = util_1.VisualUpdateState.create();
    var previousMark = { loci: loci_1.EmptyLoci, action: marker_action_1.MarkerAction.None, status: -1 };
    var renderObject;
    var newProps = Object.assign({}, defaultProps);
    var newTheme = theme_1.Theme.createEmpty();
    var newStructureGroup;
    var currentProps;
    var currentTheme;
    var currentStructureGroup;
    var geometry;
    var geometryVersion = -1;
    var locationIt;
    var positionIt;
    function prepareUpdate(theme, props, structureGroup) {
        if (!structureGroup && !currentStructureGroup) {
            throw new Error('missing structureGroup');
        }
        newProps = props;
        newTheme = theme;
        newStructureGroup = structureGroup;
        util_1.VisualUpdateState.reset(updateState);
        if (!renderObject || !currentStructureGroup) {
            // console.log('create new');
            updateState.createNew = true;
            updateState.createGeometry = true;
            return;
        }
        setUpdateState(updateState, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
        if (!structure_1.Structure.areHierarchiesEqual(currentStructureGroup.structure, newStructureGroup.structure)) {
            // console.log('new hierarchy');
            updateState.updateTransform = true;
            updateState.updateColor = true;
            updateState.updateSize = true;
        }
        if (!color_1.ColorTheme.areEqual(newTheme.color, currentTheme.color)) {
            // console.log('new colorTheme');
            updateState.updateColor = true;
        }
        if (currentStructureGroup.structure.child !== newStructureGroup.structure.child) {
            // console.log('new child');
            updateState.createGeometry = true;
        }
        if (newProps.instanceGranularity !== currentProps.instanceGranularity) {
            updateState.updateTransform = true;
        }
        if (!(0, mol_util_1.deepEqual)(newProps.unitKinds, currentProps.unitKinds)) {
            // console.log('new unitKinds');
            updateState.createGeometry = true;
        }
        if (newStructureGroup.group.transformHash !== currentStructureGroup.group.transformHash) {
            // console.log('new transformHash');
            if (newStructureGroup.group.units.length !== currentStructureGroup.group.units.length || updateState.updateColor) {
                updateState.updateTransform = true;
            }
            else {
                updateState.updateMatrix = true;
            }
        }
        // check if the operator or conformation of unit has changed
        var newUnit = newStructureGroup.group.units[0];
        var currentUnit = currentStructureGroup.group.units[0];
        if (!structure_1.Unit.areOperatorsEqual(newUnit, currentUnit)) {
            // console.log('new operators');
            updateState.updateTransform = true;
        }
        if (!structure_1.Unit.areConformationsEqual(newUnit, currentUnit)) {
            // console.log('new conformation');
            updateState.createGeometry = true;
        }
        if (updateState.updateTransform) {
            updateState.updateMatrix = true;
        }
        if (updateState.updateSize && !('uSize' in renderObject.values)) {
            updateState.createGeometry = true;
        }
        if (updateState.createGeometry || updateState.updateTransform) {
            if (currentStructureGroup.structure.hashCode !== newStructureGroup.structure.hashCode) {
                // console.log('new hashCode');
                updateState.updateColor = true;
                updateState.updateSize = true;
            }
            if (newTheme.color.granularity.startsWith('vertex') ||
                renderObject.values.dColorType.ref.value.startsWith('vertex') ||
                newTheme.color.granularity.startsWith('volume') ||
                renderObject.values.dColorType.ref.value.startsWith('volume')) {
                updateState.updateColor = true;
            }
        }
    }
    function update(newGeometry) {
        if (updateState.createNew) {
            locationIt = createLocationIterator(newStructureGroup);
            if (newGeometry) {
                renderObject = createUnitsRenderObject(newStructureGroup, newGeometry, locationIt, newTheme, newProps, materialId);
                positionIt = createPositionIterator(newGeometry, renderObject.values);
            }
            else {
                throw new Error('expected geometry to be given');
            }
        }
        else {
            if (!renderObject) {
                throw new Error('expected renderObject to be available');
            }
            if (updateState.updateTransform) {
                // console.log('update transform');
                locationIt = createLocationIterator(newStructureGroup);
                var instanceCount = locationIt.instanceCount, groupCount = locationIt.groupCount;
                if (newProps.instanceGranularity) {
                    (0, marker_data_1.createMarkers)(instanceCount, 'instance', renderObject.values);
                }
                else {
                    (0, marker_data_1.createMarkers)(instanceCount * groupCount, 'groupInstance', renderObject.values);
                }
            }
            if (updateState.updateMatrix) {
                // console.log('update matrix');
                (0, common_1.createUnitsTransform)(newStructureGroup, newProps.includeParent, renderObject.values);
            }
            if (updateState.createGeometry) {
                // console.log('update geometry');
                if (newGeometry) {
                    mol_util_1.ValueCell.updateIfChanged(renderObject.values.drawCount, geometry_1.Geometry.getDrawCount(newGeometry));
                    mol_util_1.ValueCell.updateIfChanged(renderObject.values.uVertexCount, geometry_1.Geometry.getVertexCount(newGeometry));
                    mol_util_1.ValueCell.updateIfChanged(renderObject.values.uGroupCount, geometry_1.Geometry.getGroupCount(newGeometry));
                }
                else {
                    throw new Error('expected geometry to be given');
                }
            }
            if (updateState.updateTransform || updateState.createGeometry) {
                updateBoundingSphere(renderObject.values, newGeometry || geometry);
                positionIt = createPositionIterator(newGeometry || geometry, renderObject.values);
            }
            if (updateState.updateSize) {
                // not all geometries have size data, so check here
                if ('uSize' in renderObject.values) {
                    // console.log('update size');
                    (0, size_data_1.createSizes)(locationIt, newTheme.size, renderObject.values);
                }
            }
            if (updateState.updateColor) {
                // console.log('update color');
                (0, color_data_1.createColors)(locationIt, positionIt, newTheme.color, renderObject.values);
            }
            updateValues(renderObject.values, newProps);
            updateRenderableState(renderObject.state, newProps);
        }
        currentProps = newProps;
        currentTheme = newTheme;
        currentStructureGroup = newStructureGroup;
        if (newGeometry) {
            geometry = newGeometry;
            geometryVersion += 1;
        }
    }
    function _createGeometry(ctx, unit, structure, theme, props, geometry) {
        return (0, common_1.includesUnitKind)(props.unitKinds, unit)
            ? createGeometry(ctx, unit, structure, theme, props, geometry)
            : createEmptyGeometry(geometry);
    }
    function lociIsSuperset(loci) {
        if ((0, loci_1.isEveryLoci)(loci))
            return true;
        if (structure_1.Structure.isLoci(loci) && structure_1.Structure.areRootsEquivalent(loci.structure, currentStructureGroup.structure))
            return true;
        if (structure_1.StructureElement.Loci.is(loci) && structure_1.Structure.areRootsEquivalent(loci.structure, currentStructureGroup.structure)) {
            if (structure_1.StructureElement.Loci.isWholeStructure(loci))
                return true;
        }
        return false;
    }
    function eachInstance(loci, structureGroup, apply) {
        var changed = false;
        if (structure_1.Bond.isLoci(loci)) {
            var structure = structureGroup.structure, group = structureGroup.group;
            if (!structure_1.Structure.areEquivalent(loci.structure, structure))
                return false;
            for (var _i = 0, _a = loci.bonds; _i < _a.length; _i++) {
                var b = _a[_i];
                if (b.aUnit !== b.bUnit)
                    continue;
                var unitIdx = group.unitIndexMap.get(b.aUnit.id);
                if (unitIdx !== undefined) {
                    if (apply(int_1.Interval.ofSingleton(unitIdx)))
                        changed = true;
                }
            }
        }
        else if (structure_1.StructureElement.Loci.is(loci)) {
            var structure = structureGroup.structure, group = structureGroup.group;
            if (!structure_1.Structure.areEquivalent(loci.structure, structure))
                return false;
            for (var _b = 0, _c = loci.elements; _b < _c.length; _b++) {
                var e = _c[_b];
                var unitIdx = group.unitIndexMap.get(e.unit.id);
                if (unitIdx !== undefined) {
                    if (apply(int_1.Interval.ofSingleton(unitIdx)))
                        changed = true;
                }
            }
        }
        return changed;
    }
    function lociApply(loci, apply, isMarking) {
        if (lociIsSuperset(loci)) {
            if (currentProps.instanceGranularity) {
                return apply(int_1.Interval.ofBounds(0, locationIt.instanceCount));
            }
            else {
                return apply(int_1.Interval.ofBounds(0, locationIt.groupCount * locationIt.instanceCount));
            }
        }
        else {
            if (currentProps.instanceGranularity) {
                return eachInstance(loci, currentStructureGroup, apply);
            }
            else {
                return eachLocation(loci, currentStructureGroup, apply, isMarking);
            }
        }
    }
    function finalize(ctx) {
        if (renderObject) {
            processValues === null || processValues === void 0 ? void 0 : processValues(renderObject.values, geometry, currentProps, currentTheme, ctx.webgl);
        }
    }
    return {
        get groupCount() { return locationIt ? locationIt.count : 0; },
        get renderObject() { return locationIt && locationIt.count ? renderObject : undefined; },
        get geometryVersion() { return geometryVersion; },
        createOrUpdate: function (ctx, theme, props, structureGroup) {
            prepareUpdate(theme, props, structureGroup || currentStructureGroup);
            if (updateState.createGeometry) {
                var newGeometry = _createGeometry(ctx, newStructureGroup.group.units[0], newStructureGroup.structure, newTheme, newProps, geometry);
                if ((0, type_helpers_1.isPromiseLike)(newGeometry)) {
                    return newGeometry.then(function (g) {
                        update(g);
                        finalize(ctx);
                    });
                }
                update(newGeometry);
            }
            else {
                update();
            }
            finalize(ctx);
        },
        getLoci: function (pickingId) {
            return renderObject ? getLoci(pickingId, currentStructureGroup, renderObject.id) : loci_1.EmptyLoci;
        },
        eachLocation: function (cb) {
            locationIt.reset();
            while (locationIt.hasNext) {
                var _a = locationIt.move(), location_1 = _a.location, isSecondary = _a.isSecondary;
                cb(location_1, isSecondary);
            }
        },
        mark: function (loci, action) {
            var hasInvariantId = true;
            if (structure_1.StructureElement.Loci.is(loci)) {
                hasInvariantId = false;
                var invariantId = currentStructureGroup.group.units[0].invariantId;
                for (var _i = 0, _a = loci.elements; _i < _a.length; _i++) {
                    var e = _a[_i];
                    if (e.unit.invariantId === invariantId) {
                        hasInvariantId = true;
                        break;
                    }
                }
            }
            return hasInvariantId ? visual_1.Visual.mark(renderObject, loci, action, lociApply, previousMark) : false;
        },
        setVisibility: function (visible) {
            visual_1.Visual.setVisibility(renderObject, visible);
        },
        setAlphaFactor: function (alphaFactor) {
            visual_1.Visual.setAlphaFactor(renderObject, alphaFactor);
        },
        setPickable: function (pickable) {
            visual_1.Visual.setPickable(renderObject, pickable);
        },
        setColorOnly: function (colorOnly) {
            visual_1.Visual.setColorOnly(renderObject, colorOnly);
        },
        setTransform: function (matrix, instanceMatrices) {
            visual_1.Visual.setTransform(renderObject, matrix, instanceMatrices);
        },
        setOverpaint: function (overpaint, webgl) {
            var smoothing = { geometry: geometry, props: currentProps, webgl: webgl };
            visual_1.Visual.setOverpaint(renderObject, overpaint, lociApply, true, smoothing);
        },
        setTransparency: function (transparency, webgl) {
            var smoothing = { geometry: geometry, props: currentProps, webgl: webgl };
            visual_1.Visual.setTransparency(renderObject, transparency, lociApply, true, smoothing);
        },
        setSubstance: function (substance, webgl) {
            var smoothing = { geometry: geometry, props: currentProps, webgl: webgl };
            visual_1.Visual.setSubstance(renderObject, substance, lociApply, true, smoothing);
        },
        setClipping: function (clipping) {
            visual_1.Visual.setClipping(renderObject, clipping, lociApply, true);
        },
        setThemeStrength: function (strength) {
            visual_1.Visual.setThemeStrength(renderObject, strength);
        },
        destroy: function () {
            dispose === null || dispose === void 0 ? void 0 : dispose(geometry);
            if (renderObject) {
                renderObject.state.disposed = true;
                renderObject = undefined;
            }
        },
        mustRecreate: mustRecreate
    };
}
exports.UnitsVisual = UnitsVisual;
// mesh
exports.UnitsMeshParams = tslib_1.__assign(tslib_1.__assign({}, params_1.StructureMeshParams), params_1.StructureParams);
function UnitsMeshVisual(builder, materialId) {
    return UnitsVisual(tslib_1.__assign(tslib_1.__assign({}, builder), { setUpdateState: function (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) {
            builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
            if (!size_1.SizeTheme.areEqual(newTheme.size, currentTheme.size))
                state.createGeometry = true;
        }, geometryUtils: mesh_1.Mesh.Utils }), materialId);
}
exports.UnitsMeshVisual = UnitsMeshVisual;
// spheres
exports.UnitsSpheresParams = tslib_1.__assign(tslib_1.__assign({}, params_1.StructureSpheresParams), params_1.StructureParams);
function UnitsSpheresVisual(builder, materialId) {
    return UnitsVisual(tslib_1.__assign(tslib_1.__assign({}, builder), { setUpdateState: function (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) {
            builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
            if (!size_1.SizeTheme.areEqual(newTheme.size, currentTheme.size))
                state.updateSize = true;
        }, geometryUtils: spheres_1.Spheres.Utils }), materialId);
}
exports.UnitsSpheresVisual = UnitsSpheresVisual;
// cylinders
exports.UnitsCylindersParams = tslib_1.__assign(tslib_1.__assign({}, params_1.StructureCylindersParams), params_1.StructureParams);
function UnitsCylindersVisual(builder, materialId) {
    return UnitsVisual(tslib_1.__assign(tslib_1.__assign({}, builder), { setUpdateState: function (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) {
            builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
            if (!size_1.SizeTheme.areEqual(newTheme.size, currentTheme.size))
                state.updateSize = true;
        }, geometryUtils: cylinders_1.Cylinders.Utils }), materialId);
}
exports.UnitsCylindersVisual = UnitsCylindersVisual;
// points
exports.UnitsPointsParams = tslib_1.__assign(tslib_1.__assign({}, params_1.StructurePointsParams), params_1.StructureParams);
function UnitsPointsVisual(builder, materialId) {
    return UnitsVisual(tslib_1.__assign(tslib_1.__assign({}, builder), { setUpdateState: function (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) {
            builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
            if (!size_1.SizeTheme.areEqual(newTheme.size, currentTheme.size))
                state.updateSize = true;
        }, geometryUtils: points_1.Points.Utils }), materialId);
}
exports.UnitsPointsVisual = UnitsPointsVisual;
// lines
exports.UnitsLinesParams = tslib_1.__assign(tslib_1.__assign({}, params_1.StructureLinesParams), params_1.StructureParams);
function UnitsLinesVisual(builder, materialId) {
    return UnitsVisual(tslib_1.__assign(tslib_1.__assign({}, builder), { setUpdateState: function (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) {
            builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
            if (!size_1.SizeTheme.areEqual(newTheme.size, currentTheme.size))
                state.updateSize = true;
        }, geometryUtils: lines_1.Lines.Utils }), materialId);
}
exports.UnitsLinesVisual = UnitsLinesVisual;
// text
exports.UnitsTextParams = tslib_1.__assign(tslib_1.__assign({}, params_1.StructureTextParams), params_1.StructureParams);
function UnitsTextVisual(builder, materialId) {
    return UnitsVisual(tslib_1.__assign(tslib_1.__assign({}, builder), { setUpdateState: function (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) {
            builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
            if (!size_1.SizeTheme.areEqual(newTheme.size, currentTheme.size))
                state.updateSize = true;
            if (newProps.background !== currentProps.background)
                state.createGeometry = true;
            if (newProps.backgroundMargin !== currentProps.backgroundMargin)
                state.createGeometry = true;
            if (newProps.tether !== currentProps.tether)
                state.createGeometry = true;
            if (newProps.tetherLength !== currentProps.tetherLength)
                state.createGeometry = true;
            if (newProps.tetherBaseWidth !== currentProps.tetherBaseWidth)
                state.createGeometry = true;
            if (newProps.attachment !== currentProps.attachment)
                state.createGeometry = true;
            if (newProps.fontFamily !== currentProps.fontFamily)
                state.createGeometry = true;
            if (newProps.fontQuality !== currentProps.fontQuality)
                state.createGeometry = true;
            if (newProps.fontStyle !== currentProps.fontStyle)
                state.createGeometry = true;
            if (newProps.fontVariant !== currentProps.fontVariant)
                state.createGeometry = true;
            if (newProps.fontWeight !== currentProps.fontWeight)
                state.createGeometry = true;
        }, geometryUtils: text_1.Text.Utils }), materialId);
}
exports.UnitsTextVisual = UnitsTextVisual;
// direct-volume
exports.UnitsDirectVolumeParams = tslib_1.__assign(tslib_1.__assign({}, params_1.StructureDirectVolumeParams), params_1.StructureParams);
function UnitsDirectVolumeVisual(builder, materialId) {
    return UnitsVisual(tslib_1.__assign(tslib_1.__assign({}, builder), { setUpdateState: function (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) {
            builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
            if (!size_1.SizeTheme.areEqual(newTheme.size, currentTheme.size))
                state.createGeometry = true;
        }, geometryUtils: direct_volume_1.DirectVolume.Utils }), materialId);
}
exports.UnitsDirectVolumeVisual = UnitsDirectVolumeVisual;
// texture-mesh
exports.UnitsTextureMeshParams = tslib_1.__assign(tslib_1.__assign({}, params_1.StructureTextureMeshParams), params_1.StructureParams);
function UnitsTextureMeshVisual(builder, materialId) {
    return UnitsVisual(tslib_1.__assign(tslib_1.__assign({}, builder), { setUpdateState: function (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) {
            builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
            if (!size_1.SizeTheme.areEqual(newTheme.size, currentTheme.size))
                state.createGeometry = true;
        }, geometryUtils: texture_mesh_1.TextureMesh.Utils }), materialId);
}
exports.UnitsTextureMeshVisual = UnitsTextureMeshVisual;
