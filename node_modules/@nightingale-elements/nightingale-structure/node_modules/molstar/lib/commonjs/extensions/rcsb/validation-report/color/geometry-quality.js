"use strict";
/**
 * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryQualityColorThemeProvider = exports.GeometryQualityColorTheme = exports.getGeometricQualityColorThemeParams = void 0;
var color_1 = require("../../../../mol-theme/color");
var param_definition_1 = require("../../../../mol-util/param-definition");
var color_2 = require("../../../../mol-util/color");
var structure_1 = require("../../../../mol-model/structure");
var prop_1 = require("../prop");
var legend_1 = require("../../../../mol-util/legend");
var set_1 = require("../../../../mol-util/set");
var DefaultColor = (0, color_2.Color)(0x909090);
var NoIssuesColor = (0, color_2.Color)(0x2166ac);
var OneIssueColor = (0, color_2.Color)(0xfee08b);
var TwoIssuesColor = (0, color_2.Color)(0xf46d43);
var ThreeOrMoreIssuesColor = (0, color_2.Color)(0xa50026);
var ColorLegend = (0, legend_1.TableLegend)([
    ['Data unavailable', DefaultColor],
    ['No issues', NoIssuesColor],
    ['One issue', OneIssueColor],
    ['Two issues', TwoIssuesColor],
    ['Three or more issues', ThreeOrMoreIssuesColor],
]);
function getGeometricQualityColorThemeParams(ctx) {
    var validationReport = !!ctx.structure && ctx.structure.models.length > 0 && prop_1.ValidationReportProvider.get(ctx.structure.models[0]).value;
    var options = [];
    if (validationReport) {
        var kinds_1 = new Set();
        validationReport.geometryIssues.forEach(function (v) { return v.forEach(function (k) { return kinds_1.add(k); }); });
        kinds_1.forEach(function (k) { return options.push([k, k]); });
    }
    return {
        ignore: param_definition_1.ParamDefinition.MultiSelect([], options)
    };
}
exports.getGeometricQualityColorThemeParams = getGeometricQualityColorThemeParams;
function GeometryQualityColorTheme(ctx, props) {
    var _a;
    var color = function () { return DefaultColor; };
    var validationReport = !!ctx.structure && ctx.structure.models.length > 0 ? prop_1.ValidationReportProvider.get(ctx.structure.models[0]) : void 0;
    var contextHash = validationReport === null || validationReport === void 0 ? void 0 : validationReport.version;
    var value = validationReport === null || validationReport === void 0 ? void 0 : validationReport.value;
    var model = (_a = ctx.structure) === null || _a === void 0 ? void 0 : _a.models[0];
    if (value && model) {
        var geometryIssues_1 = value.geometryIssues, clashes_1 = value.clashes, bondOutliers_1 = value.bondOutliers, angleOutliers_1 = value.angleOutliers;
        var residueIndex_1 = model.atomicHierarchy.residueAtomSegments.index;
        var polymerType_1 = model.atomicHierarchy.derived.residue.polymerType;
        var ignore_1 = new Set(props.ignore);
        var getColor_1 = function (element) {
            var rI = residueIndex_1[element];
            var value = geometryIssues_1.get(rI);
            if (value === undefined)
                return DefaultColor;
            var count = set_1.SetUtils.differenceSize(value, ignore_1);
            if (count > 0 && polymerType_1[rI] === 0 /* PolymerType.NA */) {
                count = 0;
                if (!ignore_1.has('clash') && clashes_1.getVertexEdgeCount(element) > 0)
                    count += 1;
                if (!ignore_1.has('mog-bond-outlier') && bondOutliers_1.index.has(element))
                    count += 1;
                if (!ignore_1.has('mog-angle-outlier') && angleOutliers_1.index.has(element))
                    count += 1;
            }
            switch (count) {
                case undefined: return DefaultColor;
                case 0: return NoIssuesColor;
                case 1: return OneIssueColor;
                case 2: return TwoIssuesColor;
                default: return ThreeOrMoreIssuesColor;
            }
        };
        color = function (location) {
            if (structure_1.StructureElement.Location.is(location) && location.unit.model === model) {
                return getColor_1(location.element);
            }
            else if (structure_1.Bond.isLocation(location) && location.aUnit.model === model) {
                return getColor_1(location.aUnit.elements[location.aIndex]);
            }
            return DefaultColor;
        };
    }
    return {
        factory: GeometryQualityColorTheme,
        granularity: 'group',
        preferSmoothing: true,
        color: color,
        props: props,
        contextHash: contextHash,
        description: 'Assigns residue colors according to the number of (filtered) geometry issues. Data from wwPDB Validation Report, obtained via RCSB PDB.',
        legend: ColorLegend
    };
}
exports.GeometryQualityColorTheme = GeometryQualityColorTheme;
exports.GeometryQualityColorThemeProvider = {
    name: prop_1.ValidationReport.Tag.GeometryQuality,
    label: 'Geometry Quality',
    category: color_1.ColorTheme.Category.Validation,
    factory: GeometryQualityColorTheme,
    getParams: getGeometricQualityColorThemeParams,
    defaultValues: param_definition_1.ParamDefinition.getDefaultValues(getGeometricQualityColorThemeParams({})),
    isApplicable: function (ctx) { var _a; return prop_1.ValidationReport.isApplicable((_a = ctx.structure) === null || _a === void 0 ? void 0 : _a.models[0]); },
    ensureCustomProperties: {
        attach: function (ctx, data) { return data.structure ? prop_1.ValidationReportProvider.attach(ctx, data.structure.models[0], void 0, true) : Promise.resolve(); },
        detach: function (data) { return data.structure && prop_1.ValidationReportProvider.ref(data.structure.models[0], false); }
    }
};
