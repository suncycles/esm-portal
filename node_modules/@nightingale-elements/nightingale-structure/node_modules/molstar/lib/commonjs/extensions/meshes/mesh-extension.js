"use strict";
/**
 * Copyright (c) 2018-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Adam Midlik <midlik@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMeshFromUrl = exports.MeshShapeTransformer = exports.ParseMeshlistTransformer = exports.MeshlistStateObject = exports.MeshlistData = exports.VolsegTransform = exports.FOREROUND_OPACITY = exports.BACKGROUND_OPACITY = void 0;
var tslib_1 = require("tslib");
/** Defines new types of State tree transformers for dealing with mesh data. */
var base_1 = require("../../mol-geo/geometry/base");
var mesh_1 = require("../../mol-geo/geometry/mesh/mesh");
var geometry_1 = require("../../mol-math/geometry");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var shape_1 = require("../../mol-model/shape");
var objects_1 = require("../../mol-plugin-state/objects");
var transforms_1 = require("../../mol-plugin-state/transforms");
var data_1 = require("../../mol-plugin-state/transforms/data");
var representation_1 = require("../../mol-plugin-state/transforms/representation");
var mol_state_1 = require("../../mol-state");
var mol_task_1 = require("../../mol-task");
var param_definition_1 = require("../../mol-util/param-definition");
var MeshUtils = tslib_1.__importStar(require("./mesh-utils"));
exports.BACKGROUND_OPACITY = 0.2;
exports.FOREROUND_OPACITY = 1;
exports.VolsegTransform = mol_state_1.StateTransformer.builderFactory('volseg');
var MeshlistData;
(function (MeshlistData) {
    function empty() {
        return {
            segmentId: 0,
            segmentName: 'Empty',
            detail: 0,
            meshIds: [],
            mesh: mesh_1.Mesh.createEmpty(),
        };
    }
    MeshlistData.empty = empty;
    ;
    function fromCIF(data, segmentId, segmentName, detail) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, mesh, meshIds;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, MeshUtils.meshFromCif(data)];
                    case 1:
                        _a = _b.sent(), mesh = _a.mesh, meshIds = _a.meshIds;
                        return [2 /*return*/, {
                                segmentId: segmentId,
                                segmentName: segmentName,
                                detail: detail,
                                meshIds: meshIds,
                                mesh: mesh,
                            }];
                }
            });
        });
    }
    MeshlistData.fromCIF = fromCIF;
    function stats(meshListData) {
        return "Meshlist \"".concat(meshListData.segmentName, "\" (detail ").concat(meshListData.detail, "): ").concat(meshListData.meshIds.length, " meshes, ").concat(meshListData.mesh.vertexCount, " vertices, ").concat(meshListData.mesh.triangleCount, " triangles");
    }
    MeshlistData.stats = stats;
    function getShape(data, color) {
        var mesh = data.mesh;
        var meshShape = shape_1.Shape.create(data.segmentName, data, mesh, function () { return color; }, function () { return 1; }, 
        // group => `${data.segmentName} | Segment ${data.segmentId} | Detail ${data.detail} | Mesh ${group}`,
        function (group) { return data.segmentName; });
        return meshShape;
    }
    MeshlistData.getShape = getShape;
    function combineBBoxes(boxes) {
        var result = null;
        for (var _i = 0, boxes_1 = boxes; _i < boxes_1.length; _i++) {
            var box = boxes_1[_i];
            if (!box)
                continue;
            if (result) {
                linear_algebra_1.Vec3.min(result.min, result.min, box.min);
                linear_algebra_1.Vec3.max(result.max, result.max, box.max);
            }
            else {
                result = geometry_1.Box3D.zero();
                geometry_1.Box3D.copy(result, box);
            }
        }
        return result;
    }
    MeshlistData.combineBBoxes = combineBBoxes;
    function bbox(data) {
        return MeshUtils.bbox(data.mesh);
    }
    MeshlistData.bbox = bbox;
    function allVerticesUsed(data) {
        var unusedVertices = new Set();
        for (var i = 0; i < data.mesh.vertexCount; i++) {
            unusedVertices.add(i);
        }
        for (var i = 0; i < 3 * data.mesh.triangleCount; i++) {
            var v = data.mesh.vertexBuffer.ref.value[i];
            unusedVertices.delete(v);
        }
        return unusedVertices.size === 0;
    }
    MeshlistData.allVerticesUsed = allVerticesUsed;
})(MeshlistData = exports.MeshlistData || (exports.MeshlistData = {}));
// // // // // // // // // // // // // // // // // // // // // // // //
// Raw Data -> Parsed data
var MeshlistStateObject = /** @class */ (function (_super) {
    tslib_1.__extends(MeshlistStateObject, _super);
    function MeshlistStateObject() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return MeshlistStateObject;
}(objects_1.PluginStateObject.Create({ name: 'Parsed Meshlist', typeClass: 'Object' })));
exports.MeshlistStateObject = MeshlistStateObject;
exports.ParseMeshlistTransformer = (0, exports.VolsegTransform)({
    name: 'meshlist-from-string',
    from: objects_1.PluginStateObject.Format.Cif,
    to: MeshlistStateObject,
    params: {
        label: param_definition_1.ParamDefinition.Text(MeshlistStateObject.type.name, { isHidden: true }),
        segmentId: param_definition_1.ParamDefinition.Numeric(1, {}, { isHidden: true }),
        segmentName: param_definition_1.ParamDefinition.Text('Segment'),
        detail: param_definition_1.ParamDefinition.Numeric(1, {}, { isHidden: true }),
        /** Reference to the object which manages this meshlist (e.g. `MeshStreaming.Behavior`) */
        ownerId: param_definition_1.ParamDefinition.Text('', { isHidden: true }),
    }
})({
    apply: function (_a, globalCtx) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Create Parsed Meshlist', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var meshlistData, es;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, MeshlistData.fromCIF(a.data, params.segmentId, params.segmentName, params.detail)];
                    case 1:
                        meshlistData = _a.sent();
                        meshlistData.ownerId = params.ownerId;
                        es = meshlistData.meshIds.length === 1 ? '' : 'es';
                        return [2 /*return*/, new MeshlistStateObject(meshlistData, { label: params.label, description: "".concat(meshlistData.segmentName, " (").concat(meshlistData.meshIds.length, " mesh").concat(es, ")") })];
                }
            });
        }); });
    }
});
var MeshShapeProvider;
(function (MeshShapeProvider) {
    function fromMeshlistData(meshlist, color) {
        var theColor = color !== null && color !== void 0 ? color : MeshUtils.ColorGenerator.next().value;
        return {
            label: 'Mesh',
            data: meshlist,
            params: meshShapeProviderParams,
            geometryUtils: mesh_1.Mesh.Utils,
            getShape: function (ctx, data) { return MeshlistData.getShape(data, theColor); },
        };
    }
    MeshShapeProvider.fromMeshlistData = fromMeshlistData;
})(MeshShapeProvider || (MeshShapeProvider = {}));
var meshShapeProviderParams = tslib_1.__assign(tslib_1.__assign({}, mesh_1.Mesh.Params), { quality: param_definition_1.ParamDefinition.Select('custom', base_1.VisualQualityOptions, { isEssential: true, description: 'Visual/rendering quality of the representation.' }), doubleSided: param_definition_1.ParamDefinition.Boolean(true, base_1.BaseGeometry.CustomQualityParamInfo), 
    // set `flatShaded`: true to see the real mesh vertices and triangles
    transparentBackfaces: param_definition_1.ParamDefinition.Select('on', param_definition_1.ParamDefinition.arrayToOptions(['off', 'on', 'opaque']), base_1.BaseGeometry.ShadingCategory) });
exports.MeshShapeTransformer = (0, exports.VolsegTransform)({
    name: 'shape-from-meshlist',
    display: { name: 'Shape from Meshlist', description: 'Create Shape from Meshlist data' },
    from: MeshlistStateObject,
    to: objects_1.PluginStateObject.Shape.Provider,
    params: {
        color: param_definition_1.ParamDefinition.Value(undefined), // undefined means random color
    },
})({
    apply: function (_a) {
        var a = _a.a, params = _a.params;
        var shapeProvider = MeshShapeProvider.fromMeshlistData(a.data, params.color);
        return new objects_1.PluginStateObject.Shape.Provider(shapeProvider, { label: objects_1.PluginStateObject.Shape.Provider.type.name, description: a.description });
    }
});
// // // // // // // // // // // // // // // // // // // // // // // //
/** Download data and create state tree hierarchy down to visual representation. */
function createMeshFromUrl(plugin, meshDataUrl, segmentId, detail, collapseTree, color, parent, transparentIfBboxAbove, name, ownerId) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var update, rawDataNodeRef, parsedDataNode, transparent, bbox;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    update = parent ? plugin.build().to(parent) : plugin.build().toRoot();
                    rawDataNodeRef = update.apply(data_1.Download, { url: meshDataUrl, isBinary: true, label: "Downloaded Data ".concat(segmentId) }, { state: { isCollapsed: collapseTree } }).ref;
                    return [4 /*yield*/, update.to(rawDataNodeRef)
                            .apply(transforms_1.StateTransforms.Data.ParseCif)
                            .apply(exports.ParseMeshlistTransformer, { label: undefined, segmentId: segmentId, segmentName: name !== null && name !== void 0 ? name : "Segment ".concat(segmentId), detail: detail, ownerId: ownerId }, {})
                            .commit()];
                case 1:
                    parsedDataNode = _a.sent();
                    transparent = false;
                    if (transparentIfBboxAbove !== undefined && parsedDataNode.data) {
                        bbox = MeshlistData.bbox(parsedDataNode.data) || geometry_1.Box3D.zero();
                        transparent = geometry_1.Box3D.volume(bbox) > transparentIfBboxAbove;
                    }
                    return [4 /*yield*/, plugin.build().to(parsedDataNode)
                            .apply(exports.MeshShapeTransformer, { color: color })
                            .apply(representation_1.ShapeRepresentation3D, { alpha: transparent ? exports.BACKGROUND_OPACITY : exports.FOREROUND_OPACITY }, { tags: ['mesh-segment-visual', "segment-".concat(segmentId)] })
                            .commit()];
                case 2:
                    _a.sent();
                    return [2 /*return*/, rawDataNodeRef];
            }
        });
    });
}
exports.createMeshFromUrl = createMeshFromUrl;
