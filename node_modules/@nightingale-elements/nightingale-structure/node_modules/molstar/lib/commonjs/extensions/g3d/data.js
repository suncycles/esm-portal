"use strict";
/**
 * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getG3dDataBlock = exports.getG3dHeader = void 0;
var tslib_1 = require("tslib");
var decode_1 = require("../../mol-io/common/msgpack/decode");
var mol_task_1 = require("../../mol-task");
var zip_1 = require("../../mol-util/zip/zip");
var HEADER_SIZE = 64000;
function getG3dHeader(ctx, urlOrData) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var data, last, header;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, getRawData(ctx, urlOrData, { offset: 0, size: HEADER_SIZE })];
                case 1:
                    data = _a.sent();
                    last = data.length - 1;
                    for (; last >= 0; last--) {
                        if (data[last] !== 0)
                            break;
                    }
                    header = (0, decode_1.decodeMsgPack)(data.slice(0, last + 1));
                    return [2 /*return*/, header];
            }
        });
    });
}
exports.getG3dHeader = getG3dHeader;
function getG3dDataBlock(ctx, header, urlOrData, resolution) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var data, unzipped;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!header.offsets[resolution])
                        throw new Error("Resolution ".concat(resolution, " not available."));
                    return [4 /*yield*/, getRawData(ctx, urlOrData, header.offsets[resolution])];
                case 1:
                    data = _a.sent();
                    return [4 /*yield*/, ctx.runTask(mol_task_1.Task.create('Unzip', function (ctx) { return (0, zip_1.inflate)(ctx, data); }))];
                case 2:
                    unzipped = _a.sent();
                    return [2 /*return*/, {
                            header: header,
                            resolution: resolution,
                            data: (0, decode_1.decodeMsgPack)(unzipped)
                        }];
            }
        });
    });
}
exports.getG3dDataBlock = getG3dDataBlock;
function getRawData(ctx, urlOrData, range) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(typeof urlOrData === 'string')) return [3 /*break*/, 2];
                    return [4 /*yield*/, ctx.runTask(ctx.fetch({ url: urlOrData, headers: [['Range', "bytes=".concat(range.offset, "-").concat(range.offset + range.size - 1)]], type: 'binary' }))];
                case 1: return [2 /*return*/, _a.sent()];
                case 2: return [2 /*return*/, urlOrData.slice(range.offset, range.offset + range.size)];
            }
        });
    });
}
