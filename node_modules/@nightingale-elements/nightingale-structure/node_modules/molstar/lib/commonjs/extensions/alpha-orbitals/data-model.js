"use strict";
/**
 * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGrid = exports.initCubeGrid = exports.isCubeGridData = exports.CubeGridFormat = void 0;
var tslib_1 = require("tslib");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var geometry_1 = require("../../mol-math/geometry");
var array_1 = require("../../mol-util/array");
// eslint-disable-next-line
function CubeGridFormat(grid) {
    return { name: 'custom grid', kind: 'cube-grid', data: grid };
}
exports.CubeGridFormat = CubeGridFormat;
function isCubeGridData(f) {
    return f.kind === 'cube-grid';
}
exports.isCubeGridData = isCubeGridData;
function initCubeGrid(params) {
    var geometry = params.basis.atoms.map(function (a) { return a.center; });
    var spacing = params.gridSpacing, expand = params.boxExpand;
    var count = geometry.length;
    var box = geometry_1.Box3D.expand((0, geometry_1.Box3D)(), geometry_1.Box3D.fromVec3Array((0, geometry_1.Box3D)(), geometry), linear_algebra_1.Vec3.create(expand, expand, expand));
    var size = geometry_1.Box3D.size((0, linear_algebra_1.Vec3)(), box);
    var spacingThresholds = typeof spacing === 'number' ? [[0, spacing]] : tslib_1.__spreadArray([], spacing, true);
    spacingThresholds.sort(function (a, b) { return b[0] - a[0]; });
    var s = 0.4;
    for (var i = 0; i <= spacingThresholds.length; i++) {
        s = spacingThresholds[i][1];
        if (spacingThresholds[i][0] <= count)
            break;
    }
    var dimensions = linear_algebra_1.Vec3.ceil((0, linear_algebra_1.Vec3)(), linear_algebra_1.Vec3.scale((0, linear_algebra_1.Vec3)(), size, 1 / s));
    return {
        params: params,
        box: box,
        dimensions: dimensions,
        size: size,
        npoints: dimensions[0] * dimensions[1] * dimensions[2],
        delta: linear_algebra_1.Vec3.div((0, linear_algebra_1.Vec3)(), size, linear_algebra_1.Vec3.subScalar((0, linear_algebra_1.Vec3)(), dimensions, 1)),
    };
}
exports.initCubeGrid = initCubeGrid;
var BohrToAngstromFactor = 0.529177210859;
function createGrid(gridInfo, values, axisOrder) {
    var boxSize = geometry_1.Box3D.size((0, linear_algebra_1.Vec3)(), gridInfo.box);
    var boxOrigin = linear_algebra_1.Vec3.clone(gridInfo.box.min);
    linear_algebra_1.Vec3.scale(boxSize, boxSize, BohrToAngstromFactor);
    linear_algebra_1.Vec3.scale(boxOrigin, boxOrigin, BohrToAngstromFactor);
    var scale = linear_algebra_1.Mat4.fromScaling((0, linear_algebra_1.Mat4)(), linear_algebra_1.Vec3.div((0, linear_algebra_1.Vec3)(), boxSize, linear_algebra_1.Vec3.sub((0, linear_algebra_1.Vec3)(), gridInfo.dimensions, linear_algebra_1.Vec3.create(1, 1, 1))));
    var translate = linear_algebra_1.Mat4.fromTranslation((0, linear_algebra_1.Mat4)(), boxOrigin);
    var matrix = linear_algebra_1.Mat4.mul((0, linear_algebra_1.Mat4)(), translate, scale);
    var grid = {
        transform: { kind: 'matrix', matrix: matrix },
        cells: linear_algebra_1.Tensor.create(linear_algebra_1.Tensor.Space(gridInfo.dimensions, axisOrder, Float32Array), values),
        stats: {
            min: (0, array_1.arrayMin)(values),
            max: (0, array_1.arrayMax)(values),
            mean: (0, array_1.arrayMean)(values),
            sigma: (0, array_1.arrayRms)(values),
        },
    };
    return grid;
}
exports.createGrid = createGrid;
