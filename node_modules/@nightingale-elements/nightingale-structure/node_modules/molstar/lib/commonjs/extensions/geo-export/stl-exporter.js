"use strict";
/**
 * Copyright (c) 2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Sukolsak Sakshuwong <sukolsak@stanford.edu>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StlExporter = void 0;
var tslib_1 = require("tslib");
var ascii_1 = require("../../mol-io/common/ascii");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var version_1 = require("../../mol-plugin/version");
var mesh_exporter_1 = require("./mesh-exporter");
// avoiding namespace lookup improved performance in Chrome (Aug 2020)
var v3fromArray = linear_algebra_1.Vec3.fromArray;
var v3transformMat4 = linear_algebra_1.Vec3.transformMat4;
var v3triangleNormal = linear_algebra_1.Vec3.triangleNormal;
var v3toArray = linear_algebra_1.Vec3.toArray;
var StlExporter = /** @class */ (function (_super) {
    tslib_1.__extends(StlExporter, _super);
    function StlExporter(boundingBox) {
        var _this = _super.call(this) || this;
        _this.fileExtension = 'stl';
        _this.triangleBuffers = [];
        _this.triangleCount = 0;
        var tmpV = (0, linear_algebra_1.Vec3)();
        linear_algebra_1.Vec3.add(tmpV, boundingBox.min, boundingBox.max);
        linear_algebra_1.Vec3.scale(tmpV, tmpV, -0.5);
        _this.centerTransform = linear_algebra_1.Mat4.fromTranslation((0, linear_algebra_1.Mat4)(), tmpV);
        return _this;
    }
    StlExporter.prototype.addMeshWithColors = function (input) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var values, isGeoTexture, ctx, t, tmpV, v1, v2, v3, stride, aTransform, instanceCount, instanceIndex, _a, vertices, indices, vertexCount, drawCount, vertexArray, i, triangleBuffer, dataView, i, byteOffset;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        values = input.values, isGeoTexture = input.isGeoTexture, ctx = input.ctx;
                        t = (0, linear_algebra_1.Mat4)();
                        tmpV = (0, linear_algebra_1.Vec3)();
                        v1 = (0, linear_algebra_1.Vec3)();
                        v2 = (0, linear_algebra_1.Vec3)();
                        v3 = (0, linear_algebra_1.Vec3)();
                        stride = isGeoTexture ? 4 : 3;
                        aTransform = values.aTransform.ref.value;
                        instanceCount = values.uInstanceCount.ref.value;
                        instanceIndex = 0;
                        _b.label = 1;
                    case 1:
                        if (!(instanceIndex < instanceCount)) return [3 /*break*/, 5];
                        if (!ctx.shouldUpdate) return [3 /*break*/, 3];
                        return [4 /*yield*/, ctx.update({ current: instanceIndex + 1 })];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _a = StlExporter.getInstance(input, instanceIndex), vertices = _a.vertices, indices = _a.indices, vertexCount = _a.vertexCount, drawCount = _a.drawCount;
                        linear_algebra_1.Mat4.fromArray(t, aTransform, instanceIndex * 16);
                        linear_algebra_1.Mat4.mul(t, this.centerTransform, t);
                        vertexArray = new Float32Array(vertexCount * 3);
                        for (i = 0; i < vertexCount; ++i) {
                            v3transformMat4(tmpV, v3fromArray(tmpV, vertices, i * stride), t);
                            v3toArray(tmpV, vertexArray, i * 3);
                        }
                        triangleBuffer = new ArrayBuffer(50 * drawCount);
                        dataView = new DataView(triangleBuffer);
                        for (i = 0; i < drawCount; i += 3) {
                            v3fromArray(v1, vertexArray, (isGeoTexture ? i : indices[i]) * 3);
                            v3fromArray(v2, vertexArray, (isGeoTexture ? i + 1 : indices[i + 1]) * 3);
                            v3fromArray(v3, vertexArray, (isGeoTexture ? i + 2 : indices[i + 2]) * 3);
                            v3triangleNormal(tmpV, v1, v2, v3);
                            byteOffset = 50 * i;
                            dataView.setFloat32(byteOffset, tmpV[0], true);
                            dataView.setFloat32(byteOffset + 4, tmpV[1], true);
                            dataView.setFloat32(byteOffset + 8, tmpV[2], true);
                            dataView.setFloat32(byteOffset + 12, v1[0], true);
                            dataView.setFloat32(byteOffset + 16, v1[1], true);
                            dataView.setFloat32(byteOffset + 20, v1[2], true);
                            dataView.setFloat32(byteOffset + 24, v2[0], true);
                            dataView.setFloat32(byteOffset + 28, v2[1], true);
                            dataView.setFloat32(byteOffset + 32, v2[2], true);
                            dataView.setFloat32(byteOffset + 36, v3[0], true);
                            dataView.setFloat32(byteOffset + 40, v3[1], true);
                            dataView.setFloat32(byteOffset + 44, v3[2], true);
                        }
                        this.triangleBuffers.push(triangleBuffer);
                        this.triangleCount += drawCount;
                        _b.label = 4;
                    case 4:
                        ++instanceIndex;
                        return [3 /*break*/, 1];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    StlExporter.prototype.getData = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var stl, dataView, byteOffset, _i, _a, buffer;
            return tslib_1.__generator(this, function (_b) {
                stl = new Uint8Array(84 + 50 * this.triangleCount);
                (0, ascii_1.asciiWrite)(stl, "Exported from Mol* ".concat(version_1.PLUGIN_VERSION));
                dataView = new DataView(stl.buffer);
                dataView.setUint32(80, this.triangleCount, true);
                byteOffset = 84;
                for (_i = 0, _a = this.triangleBuffers; _i < _a.length; _i++) {
                    buffer = _a[_i];
                    stl.set(new Uint8Array(buffer), byteOffset);
                    byteOffset += buffer.byteLength;
                }
                return [2 /*return*/, { stl: stl }];
            });
        });
    };
    StlExporter.prototype.getBlob = function (ctx) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = Blob.bind;
                        return [4 /*yield*/, this.getData()];
                    case 1: return [2 /*return*/, new (_a.apply(Blob, [void 0, [(_b.sent()).stl], { type: 'model/stl' }]))()];
                }
            });
        });
    };
    return StlExporter;
}(mesh_exporter_1.MeshExporter));
exports.StlExporter = StlExporter;
