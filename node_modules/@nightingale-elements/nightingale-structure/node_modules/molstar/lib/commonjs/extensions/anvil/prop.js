"use strict";
/**
 * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MembraneOrientationProvider = exports.MembraneOrientation = exports.MembraneOrientationParams = void 0;
var tslib_1 = require("tslib");
var param_definition_1 = require("../../mol-util/param-definition");
var structure_1 = require("../../mol-model/structure");
var custom_property_1 = require("../../mol-model/custom-property");
var algorithm_1 = require("./algorithm");
var custom_structure_property_1 = require("../../mol-model-props/common/custom-structure-property");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var base_1 = require("../../mol-script/runtime/query/base");
var symbol_1 = require("../../mol-script/language/symbol");
var type_1 = require("../../mol-script/language/type");
exports.MembraneOrientationParams = tslib_1.__assign({}, algorithm_1.ANVILParams);
var MembraneOrientation;
(function (MembraneOrientation) {
    var Tag;
    (function (Tag) {
        Tag["Representation"] = "membrane-orientation-3d";
    })(Tag = MembraneOrientation.Tag || (MembraneOrientation.Tag = {}));
    var pos = (0, linear_algebra_1.Vec3)();
    MembraneOrientation.symbols = {
        isTransmembrane: base_1.QuerySymbolRuntime.Dynamic((0, symbol_1.CustomPropSymbol)('computed', 'membrane-orientation.is-transmembrane', type_1.Type.Bool), function (ctx) {
            var _a = ctx.element, unit = _a.unit, structure = _a.structure;
            var _b = structure_1.StructureProperties.atom, x = _b.x, y = _b.y, z = _b.z;
            if (!structure_1.Unit.isAtomic(unit))
                return 0;
            var membraneOrientation = exports.MembraneOrientationProvider.get(structure).value;
            if (!membraneOrientation)
                return 0;
            linear_algebra_1.Vec3.set(pos, x(ctx.element), y(ctx.element), z(ctx.element));
            var _c = membraneOrientation, normalVector = _c.normalVector, planePoint1 = _c.planePoint1, planePoint2 = _c.planePoint2;
            return (0, algorithm_1.isInMembranePlane)(pos, normalVector, planePoint1, planePoint2);
        })
    };
})(MembraneOrientation || (MembraneOrientation = {}));
exports.MembraneOrientation = MembraneOrientation;
exports.MembraneOrientationProvider = custom_structure_property_1.CustomStructureProperty.createProvider({
    label: 'Membrane Orientation',
    descriptor: (0, custom_property_1.CustomPropertyDescriptor)({
        name: 'anvil_computed_membrane_orientation',
        symbols: MembraneOrientation.symbols,
        // TODO `cifExport`
    }),
    type: 'root',
    defaultParams: exports.MembraneOrientationParams,
    getParams: function (data) { return exports.MembraneOrientationParams; },
    isApplicable: function (data) { return true; },
    obtain: function (ctx, data, props) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var p;
        var _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    p = tslib_1.__assign(tslib_1.__assign({}, param_definition_1.ParamDefinition.getDefaultValues(exports.MembraneOrientationParams)), props);
                    _a = {};
                    return [4 /*yield*/, computeAnvil(ctx, data, p)];
                case 1: return [2 /*return*/, (_a.value = _b.sent(), _a)];
            }
        });
    }); }
});
function computeAnvil(ctx, data, props) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var p;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    p = tslib_1.__assign(tslib_1.__assign({}, param_definition_1.ParamDefinition.getDefaultValues(algorithm_1.ANVILParams)), props);
                    return [4 /*yield*/, (0, algorithm_1.computeANVIL)(data, p).runInContext(ctx.runtime)];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
