"use strict";
/**
 * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MembraneOrientationRepresentationProvider = exports.MembraneOrientationRepresentation = exports.getMembraneOrientationParams = exports.MembraneOrientationParams = void 0;
var tslib_1 = require("tslib");
var param_definition_1 = require("../../mol-util/param-definition");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var representation_1 = require("../../mol-repr/representation");
var structure_1 = require("../../mol-model/structure");
var representation_2 = require("../../mol-repr/structure/representation");
var representation_3 = require("../../mol-repr/shape/representation");
var shape_1 = require("../../mol-model/shape");
var lines_1 = require("../../mol-geo/geometry/lines/lines");
var mesh_1 = require("../../mol-geo/geometry/mesh/mesh");
var lines_builder_1 = require("../../mol-geo/geometry/lines/lines-builder");
var circle_1 = require("../../mol-geo/primitive/circle");
var primitive_1 = require("../../mol-geo/primitive/primitive");
var mesh_builder_1 = require("../../mol-geo/geometry/mesh/mesh-builder");
var prop_1 = require("./prop");
var marker_action_1 = require("../../mol-util/marker-action");
var label_1 = require("../../mol-theme/label");
var names_1 = require("../../mol-util/color/names");
var SharedParams = {
    color: param_definition_1.ParamDefinition.Color(names_1.ColorNames.lightgrey),
    radiusFactor: param_definition_1.ParamDefinition.Numeric(1.2, { min: 0.1, max: 3.0, step: 0.01 }, { description: 'Scale the radius of the membrane layer' })
};
var BilayerPlanesParams = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, mesh_1.Mesh.Params), SharedParams), { sectorOpacity: param_definition_1.ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }) });
var BilayerRimsParams = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, lines_1.Lines.Params), SharedParams), { lineSizeAttenuation: param_definition_1.ParamDefinition.Boolean(false), linesSize: param_definition_1.ParamDefinition.Numeric(0.5, { min: 0.01, max: 50, step: 0.01 }), dashedLines: param_definition_1.ParamDefinition.Boolean(false) });
var MembraneOrientationVisuals = {
    'bilayer-planes': function (ctx, getParams) { return (0, representation_3.ShapeRepresentation)(getBilayerPlanes, mesh_1.Mesh.Utils, { modifyState: function (s) { return (tslib_1.__assign(tslib_1.__assign({}, s), { markerActions: marker_action_1.MarkerActions.Highlighting })); }, modifyProps: function (p) { return (tslib_1.__assign(tslib_1.__assign({}, p), { alpha: p.sectorOpacity, ignoreLight: true, doubleSided: false })); } }); },
    'bilayer-rims': function (ctx, getParams) { return (0, representation_3.ShapeRepresentation)(getBilayerRims, lines_1.Lines.Utils, { modifyState: function (s) { return (tslib_1.__assign(tslib_1.__assign({}, s), { markerActions: marker_action_1.MarkerActions.Highlighting })); } }); }
};
exports.MembraneOrientationParams = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, BilayerPlanesParams), BilayerRimsParams), { visuals: param_definition_1.ParamDefinition.MultiSelect(['bilayer-planes', 'bilayer-rims'], param_definition_1.ParamDefinition.objectToOptions(MembraneOrientationVisuals)) });
function getMembraneOrientationParams(ctx, structure) {
    return param_definition_1.ParamDefinition.clone(exports.MembraneOrientationParams);
}
exports.getMembraneOrientationParams = getMembraneOrientationParams;
function MembraneOrientationRepresentation(ctx, getParams) {
    return representation_1.Representation.createMulti('Membrane Orientation', ctx, getParams, representation_2.StructureRepresentationStateBuilder, MembraneOrientationVisuals);
}
exports.MembraneOrientationRepresentation = MembraneOrientationRepresentation;
exports.MembraneOrientationRepresentationProvider = (0, representation_2.StructureRepresentationProvider)({
    name: 'membrane-orientation',
    label: 'Membrane Orientation',
    description: 'Displays a grid of points representing membrane layers.',
    factory: MembraneOrientationRepresentation,
    getParams: getMembraneOrientationParams,
    defaultValues: param_definition_1.ParamDefinition.getDefaultValues(exports.MembraneOrientationParams),
    defaultColorTheme: { name: 'shape-group' },
    defaultSizeTheme: { name: 'shape-group' },
    isApplicable: function (structure) { return structure.elementCount > 0; },
    ensureCustomProperties: {
        attach: function (ctx, structure) { return prop_1.MembraneOrientationProvider.attach(ctx, structure, void 0, true); },
        detach: function (data) { return prop_1.MembraneOrientationProvider.ref(data, false); }
    }
});
function membraneLabel(data) {
    return "".concat((0, label_1.lociLabel)(structure_1.Structure.Loci(data)), " | Membrane Orientation");
}
function getBilayerRims(ctx, data, props, shape) {
    var _a = prop_1.MembraneOrientationProvider.get(data).value, p1 = _a.planePoint1, p2 = _a.planePoint2, centroid = _a.centroid, radius = _a.radius;
    var scaledRadius = props.radiusFactor * radius;
    var builder = lines_builder_1.LinesBuilder.create(128, 64, shape === null || shape === void 0 ? void 0 : shape.geometry);
    getLayerCircle(builder, p1, centroid, scaledRadius, props);
    getLayerCircle(builder, p2, centroid, scaledRadius, props);
    return shape_1.Shape.create('Bilayer rims', data, builder.getLines(), function () { return props.color; }, function () { return props.linesSize; }, function () { return membraneLabel(data); });
}
function getLayerCircle(builder, p, centroid, radius, props, shape) {
    var circle = getCircle(p, centroid, radius);
    var indices = circle.indices, vertices = circle.vertices;
    for (var j = 0, jl = indices.length; j < jl; j += 3) {
        if (props.dashedLines && j % 2 === 1)
            continue; // draw every other segment to get dashes
        var start = indices[j] * 3;
        var end = indices[j + 1] * 3;
        var startX = vertices[start];
        var startY = vertices[start + 1];
        var startZ = vertices[start + 2];
        var endX = vertices[end];
        var endY = vertices[end + 1];
        var endZ = vertices[end + 2];
        builder.add(startX, startY, startZ, endX, endY, endZ, 0);
    }
}
var tmpMat = (0, linear_algebra_1.Mat4)();
var tmpV = (0, linear_algebra_1.Vec3)();
function getCircle(p, centroid, radius) {
    if (linear_algebra_1.Vec3.dot(linear_algebra_1.Vec3.unitY, linear_algebra_1.Vec3.sub(tmpV, p, centroid)) === 0) {
        linear_algebra_1.Mat4.targetTo(tmpMat, p, centroid, linear_algebra_1.Vec3.unitY);
    }
    else {
        linear_algebra_1.Mat4.targetTo(tmpMat, p, centroid, linear_algebra_1.Vec3.unitX);
    }
    linear_algebra_1.Mat4.setTranslation(tmpMat, p);
    linear_algebra_1.Mat4.mul(tmpMat, tmpMat, linear_algebra_1.Mat4.rotX90);
    var circle = (0, circle_1.Circle)({ radius: radius, segments: 64 });
    return (0, primitive_1.transformPrimitive)(circle, tmpMat);
}
function getBilayerPlanes(ctx, data, props, shape) {
    var _a = prop_1.MembraneOrientationProvider.get(data).value, p1 = _a.planePoint1, p2 = _a.planePoint2, centroid = _a.centroid, radius = _a.radius;
    var state = mesh_builder_1.MeshBuilder.createState(128, 64, shape && shape.geometry);
    var scaledRadius = props.radiusFactor * radius;
    getLayerPlane(state, p1, centroid, scaledRadius);
    getLayerPlane(state, p2, centroid, scaledRadius);
    return shape_1.Shape.create('Bilayer planes', data, mesh_builder_1.MeshBuilder.getMesh(state), function () { return props.color; }, function () { return 1; }, function () { return membraneLabel(data); });
}
function getLayerPlane(state, p, centroid, radius) {
    var circle = getCircle(p, centroid, radius);
    state.currentGroup = 0;
    mesh_builder_1.MeshBuilder.addPrimitive(state, linear_algebra_1.Mat4.id, circle);
    mesh_builder_1.MeshBuilder.addPrimitiveFlipped(state, linear_algebra_1.Mat4.id, circle);
}
