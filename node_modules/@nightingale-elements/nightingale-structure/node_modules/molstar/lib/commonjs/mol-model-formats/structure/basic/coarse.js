"use strict";
/**
 * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCoarse = exports.EmptyCoarse = void 0;
var tslib_1 = require("tslib");
var coarse_1 = require("../../../mol-model/structure/model/properties/coarse");
var coarse_keys_1 = require("../../../mol-model/structure/model/properties/utils/coarse-keys");
var mol_util_1 = require("../../../mol-util");
var int_1 = require("../../../mol-data/int");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var coarse_ranges_1 = require("../../../mol-model/structure/model/properties/utils/coarse-ranges");
var schema_1 = require("./schema");
exports.EmptyCoarse = { hierarchy: coarse_1.CoarseHierarchy.Empty, conformation: void 0 };
function getCoarse(data, chemicalComponentMap) {
    var ihm_sphere_obj_site = data.ihm_sphere_obj_site, ihm_gaussian_obj_site = data.ihm_gaussian_obj_site;
    if (ihm_sphere_obj_site._rowCount === 0 && ihm_gaussian_obj_site._rowCount === 0)
        return exports.EmptyCoarse;
    var sphereData = getData(ihm_sphere_obj_site);
    var sphereConformation = getSphereConformation(ihm_sphere_obj_site);
    var sphereKeys = (0, coarse_keys_1.getCoarseKeys)(sphereData, data.entities);
    var sphereRanges = (0, coarse_ranges_1.getCoarseRanges)(sphereData, chemicalComponentMap);
    var gaussianData = getData(ihm_gaussian_obj_site);
    var gaussianConformation = getGaussianConformation(ihm_gaussian_obj_site);
    var gaussianKeys = (0, coarse_keys_1.getCoarseKeys)(gaussianData, data.entities);
    var gaussianRanges = (0, coarse_ranges_1.getCoarseRanges)(gaussianData, chemicalComponentMap);
    return {
        hierarchy: {
            isDefined: true,
            spheres: tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, sphereData), sphereKeys), sphereRanges),
            gaussians: tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, gaussianData), gaussianKeys), gaussianRanges),
        },
        conformation: {
            id: mol_util_1.UUID.create22(),
            spheres: sphereConformation,
            gaussians: gaussianConformation
        }
    };
}
exports.getCoarse = getCoarse;
function getSphereConformation(data) {
    return {
        x: data.Cartn_x.toArray({ array: Float32Array }),
        y: data.Cartn_y.toArray({ array: Float32Array }),
        z: data.Cartn_z.toArray({ array: Float32Array }),
        radius: data.object_radius.toArray({ array: Float32Array }),
        rmsf: data.rmsf.toArray({ array: Float32Array })
    };
}
function getGaussianConformation(data) {
    var matrix_space = schema_1.BasicSchema.ihm_gaussian_obj_site.covariance_matrix.space;
    var covariance_matrix = [];
    var cm = data.covariance_matrix;
    for (var i = 0, _i = cm.rowCount; i < _i; i++) {
        covariance_matrix[i] = linear_algebra_1.Tensor.toMat3((0, linear_algebra_1.Mat3)(), matrix_space, cm.value(i));
    }
    return {
        x: data.mean_Cartn_x.toArray({ array: Float32Array }),
        y: data.mean_Cartn_y.toArray({ array: Float32Array }),
        z: data.mean_Cartn_z.toArray({ array: Float32Array }),
        weight: data.weight.toArray({ array: Float32Array }),
        covariance_matrix: covariance_matrix
    };
}
function getSegments(asym_id, seq_id_begin, seq_id_end) {
    var chainOffsets = [0];
    for (var i = 1, _i = asym_id.rowCount; i < _i; i++) {
        var newChain = !asym_id.areValuesEqual(i - 1, i);
        if (newChain)
            chainOffsets[chainOffsets.length] = i;
    }
    return {
        chainElementSegments: int_1.Segmentation.ofOffsets(chainOffsets, int_1.Interval.ofBounds(0, asym_id.rowCount))
    };
}
function getData(data) {
    var entity_id = data.entity_id, seq_id_begin = data.seq_id_begin, seq_id_end = data.seq_id_end, asym_id = data.asym_id;
    return tslib_1.__assign({ count: entity_id.rowCount, entity_id: entity_id, asym_id: asym_id, seq_id_begin: seq_id_begin, seq_id_end: seq_id_end }, getSegments(asym_id, seq_id_begin, seq_id_end));
}
