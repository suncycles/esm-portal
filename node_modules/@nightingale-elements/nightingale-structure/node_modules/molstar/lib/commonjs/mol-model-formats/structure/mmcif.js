"use strict";
/**
 * Copyright (c) 2017-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.trajectoryFromMmCIF = exports.MmcifFormat = void 0;
var mol_task_1 = require("../../mol-task");
var cif_1 = require("../../mol-io/reader/cif");
var parser_1 = require("./basic/parser");
var symmetry_1 = require("./property/symmetry");
var secondary_structure_1 = require("./property/secondary-structure");
var db_1 = require("../../mol-data/db");
var anisotropic_1 = require("./property/anisotropic");
var chem_comp_1 = require("./property/bonds/chem_comp");
var struct_conn_1 = require("./property/bonds/struct_conn");
var global_transform_1 = require("../../mol-model/structure/model/properties/global-transform");
var schema_1 = require("./basic/schema");
function modelSymmetryFromMmcif(model) {
    if (!MmcifFormat.is(model.sourceData))
        return;
    return symmetry_1.ModelSymmetry.fromData(model.sourceData.data.db);
}
symmetry_1.ModelSymmetry.Provider.formatRegistry.add('mmCIF', modelSymmetryFromMmcif);
function secondaryStructureFromMmcif(model) {
    if (!MmcifFormat.is(model.sourceData))
        return;
    var _a = model.sourceData.data.db, struct_conf = _a.struct_conf, struct_sheet_range = _a.struct_sheet_range;
    return secondary_structure_1.ModelSecondaryStructure.fromStruct(struct_conf, struct_sheet_range, model.atomicHierarchy);
}
secondary_structure_1.ModelSecondaryStructure.Provider.formatRegistry.add('mmCIF', secondaryStructureFromMmcif);
function atomSiteAnisotropFromMmcif(model) {
    if (!MmcifFormat.is(model.sourceData))
        return;
    var atom_site_anisotrop = model.sourceData.data.db.atom_site_anisotrop;
    var data = db_1.Table.ofColumns(anisotropic_1.AtomSiteAnisotrop.Schema, atom_site_anisotrop);
    var elementToAnsiotrop = anisotropic_1.AtomSiteAnisotrop.getElementToAnsiotrop(model.atomicConformation.atomId, atom_site_anisotrop.id);
    return { data: data, elementToAnsiotrop: elementToAnsiotrop };
}
function atomSiteAnisotropApplicableMmcif(model) {
    if (!MmcifFormat.is(model.sourceData))
        return false;
    return model.sourceData.data.db.atom_site_anisotrop.U.isDefined;
}
anisotropic_1.AtomSiteAnisotrop.Provider.formatRegistry.add('mmCIF', atomSiteAnisotropFromMmcif, atomSiteAnisotropApplicableMmcif);
function componentBondFromMmcif(model) {
    if (!MmcifFormat.is(model.sourceData))
        return;
    var chem_comp_bond = model.sourceData.data.db.chem_comp_bond;
    if (chem_comp_bond._rowCount === 0)
        return;
    return {
        data: chem_comp_bond,
        entries: chem_comp_1.ComponentBond.getEntriesFromChemCompBond(chem_comp_bond)
    };
}
chem_comp_1.ComponentBond.Provider.formatRegistry.add('mmCIF', componentBondFromMmcif);
function structConnFromMmcif(model) {
    if (!MmcifFormat.is(model.sourceData))
        return;
    var struct_conn = model.sourceData.data.db.struct_conn;
    if (struct_conn._rowCount === 0)
        return;
    var entries = struct_conn_1.StructConn.getEntriesFromStructConn(struct_conn, model);
    return {
        data: struct_conn,
        byAtomIndex: struct_conn_1.StructConn.getAtomIndexFromEntries(entries),
        entries: entries,
    };
}
struct_conn_1.StructConn.Provider.formatRegistry.add('mmCIF', structConnFromMmcif);
global_transform_1.GlobalModelTransformInfo.Provider.formatRegistry.add('mmCIF', global_transform_1.GlobalModelTransformInfo.fromMmCif, global_transform_1.GlobalModelTransformInfo.hasData);
var MmcifFormat;
(function (MmcifFormat) {
    function is(x) {
        return (x === null || x === void 0 ? void 0 : x.kind) === 'mmCIF';
    }
    MmcifFormat.is = is;
    function fromFrame(frame, db, source) {
        if (!db)
            db = cif_1.CIF.schema.mmCIF(frame);
        return { kind: 'mmCIF', name: db._name, data: { db: db, frame: frame, source: source } };
    }
    MmcifFormat.fromFrame = fromFrame;
})(MmcifFormat || (MmcifFormat = {}));
exports.MmcifFormat = MmcifFormat;
function trajectoryFromMmCIF(frame) {
    var format = MmcifFormat.fromFrame(frame);
    var basic = (0, schema_1.createBasic)(format.data.db, true);
    return mol_task_1.Task.create('Create mmCIF Model', function (ctx) { return (0, parser_1.createModels)(basic, format, ctx); });
}
exports.trajectoryFromMmCIF = trajectoryFromMmCIF;
