"use strict";
/**
 * Copyright (c) 2017-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelSymmetry = void 0;
var mmcif_1 = require("../../../mol-io/reader/cif/schema/mmcif");
var geometry_1 = require("../../../mol-math/geometry");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var assembly_1 = require("./assembly");
var property_1 = require("../common/property");
var ModelSymmetry;
(function (ModelSymmetry) {
    ModelSymmetry.Descriptor = {
        name: 'model_symmetry',
    };
    ModelSymmetry.Provider = property_1.FormatPropertyProvider.create(ModelSymmetry.Descriptor);
    function fromData(data) {
        var assemblies = (0, assembly_1.createAssemblies)(data.pdbx_struct_assembly, data.pdbx_struct_assembly_gen, data.pdbx_struct_oper_list);
        var spacegroup = getSpacegroup(data.symmetry, data.cell);
        var isNonStandardCrystalFrame = checkNonStandardCrystalFrame(data.atom_sites, spacegroup);
        return { assemblies: assemblies, spacegroup: spacegroup, isNonStandardCrystalFrame: isNonStandardCrystalFrame, ncsOperators: getNcsOperators(data.struct_ncs_oper) };
    }
    ModelSymmetry.fromData = fromData;
    function fromCell(size, anglesInRadians) {
        var spaceCell = geometry_1.SpacegroupCell.create('P 1', size, anglesInRadians);
        var spacegroup = geometry_1.Spacegroup.create(spaceCell);
        return { assemblies: [], spacegroup: spacegroup, isNonStandardCrystalFrame: false };
    }
    ModelSymmetry.fromCell = fromCell;
})(ModelSymmetry || (ModelSymmetry = {}));
exports.ModelSymmetry = ModelSymmetry;
function checkNonStandardCrystalFrame(atom_sites, spacegroup) {
    if (atom_sites._rowCount === 0)
        return false;
    // TODO: parse atom_sites transform and check if it corresponds to the toFractional matrix
    return false;
}
function getSpacegroupNameOrNumber(symmetry) {
    var groupNumber = symmetry['Int_Tables_number'].value(0);
    var groupName = symmetry['space_group_name_H-M'].value(0);
    if (!symmetry['Int_Tables_number'].isDefined)
        return groupName;
    if (!symmetry['space_group_name_H-M'].isDefined)
        return groupNumber;
    return groupName;
}
function getSpacegroup(symmetry, cell) {
    if (symmetry._rowCount === 0 || cell._rowCount === 0)
        return geometry_1.Spacegroup.ZeroP1;
    var a = cell.length_a.value(0);
    var b = cell.length_b.value(0);
    var c = cell.length_c.value(0);
    if (a === 0 || b === 0 || c === 0)
        return geometry_1.Spacegroup.ZeroP1;
    var alpha = cell.angle_alpha.value(0);
    var beta = cell.angle_beta.value(0);
    var gamma = cell.angle_gamma.value(0);
    if (alpha === 0 || beta === 0 || gamma === 0)
        return geometry_1.Spacegroup.ZeroP1;
    var nameOrNumber = getSpacegroupNameOrNumber(symmetry);
    var spaceCell = geometry_1.SpacegroupCell.create(nameOrNumber, linear_algebra_1.Vec3.create(a, b, c), linear_algebra_1.Vec3.scale((0, linear_algebra_1.Vec3)(), linear_algebra_1.Vec3.create(alpha, beta, gamma), Math.PI / 180));
    return geometry_1.Spacegroup.create(spaceCell);
}
function getNcsOperators(struct_ncs_oper) {
    if (struct_ncs_oper._rowCount === 0)
        return void 0;
    var id = struct_ncs_oper.id, matrix = struct_ncs_oper.matrix, vector = struct_ncs_oper.vector;
    var matrixSpace = mmcif_1.mmCIF_Schema.struct_ncs_oper.matrix.space, vectorSpace = mmcif_1.mmCIF_Schema.struct_ncs_oper.vector.space;
    var opers = [];
    for (var i = 0; i < struct_ncs_oper._rowCount; i++) {
        var m = linear_algebra_1.Tensor.toMat3((0, linear_algebra_1.Mat3)(), matrixSpace, matrix.value(i));
        var v = linear_algebra_1.Tensor.toVec3((0, linear_algebra_1.Vec3)(), vectorSpace, vector.value(i));
        if (!geometry_1.SymmetryOperator.checkIfRotationAndTranslation(m, v))
            continue;
        // ignore non-identity 'given' NCS operators
        if (struct_ncs_oper.code.value(i) === 'given' && !linear_algebra_1.Mat3.isIdentity(m) && !linear_algebra_1.Vec3.isZero(v))
            continue;
        var ncsId = id.value(i);
        opers[opers.length] = geometry_1.SymmetryOperator.ofRotationAndOffset("ncs_".concat(ncsId), m, v, ncsId);
    }
    return opers;
}
