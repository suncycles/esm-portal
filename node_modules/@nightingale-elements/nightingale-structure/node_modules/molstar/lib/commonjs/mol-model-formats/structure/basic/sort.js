"use strict";
/**
 * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortAtomSite = void 0;
var tslib_1 = require("tslib");
var util_1 = require("../../../mol-data/util");
var db_1 = require("../../../mol-data/db");
var array_1 = require("../../../mol-util/array");
function sortAtomSite(ctx, atom_site, start, end) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var indices, label_entity_id, label_asym_id, label_seq_id, entityBuckets, ei, _eI, chainBuckets, cI, _cI, aI;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    indices = (0, util_1.createRangeArray)(start, end - 1);
                    label_entity_id = atom_site.label_entity_id, label_asym_id = atom_site.label_asym_id, label_seq_id = atom_site.label_seq_id;
                    entityBuckets = (0, util_1.makeBuckets)(indices, label_entity_id.value);
                    if (!ctx.shouldUpdate) return [3 /*break*/, 2];
                    return [4 /*yield*/, ctx.update()];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    ei = 0, _eI = entityBuckets.length - 1;
                    _a.label = 3;
                case 3:
                    if (!(ei < _eI)) return [3 /*break*/, 10];
                    chainBuckets = (0, util_1.makeBuckets)(indices, label_asym_id.value, { start: entityBuckets[ei], end: entityBuckets[ei + 1] });
                    cI = 0, _cI = chainBuckets.length - 1;
                    _a.label = 4;
                case 4:
                    if (!(cI < _cI)) return [3 /*break*/, 7];
                    aI = chainBuckets[cI];
                    // are we in HETATM territory?
                    if (label_seq_id.valueKind(aI) !== 0 /* Column.ValueKinds.Present */)
                        return [3 /*break*/, 6];
                    (0, util_1.makeBuckets)(indices, label_seq_id.value, { sort: true, start: aI, end: chainBuckets[cI + 1] });
                    if (!ctx.shouldUpdate) return [3 /*break*/, 6];
                    return [4 /*yield*/, ctx.update()];
                case 5:
                    _a.sent();
                    _a.label = 6;
                case 6:
                    cI++;
                    return [3 /*break*/, 4];
                case 7:
                    if (!ctx.shouldUpdate) return [3 /*break*/, 9];
                    return [4 /*yield*/, ctx.update()];
                case 8:
                    _a.sent();
                    _a.label = 9;
                case 9:
                    ei++;
                    return [3 /*break*/, 3];
                case 10:
                    if ((0, array_1.arrayIsIdentity)(indices) && indices.length === atom_site._rowCount) {
                        return [2 /*return*/, { atom_site: atom_site, sourceIndex: db_1.Column.ofIntArray(indices) }];
                    }
                    return [2 /*return*/, {
                            atom_site: db_1.Table.view(atom_site, atom_site._schema, indices),
                            sourceIndex: db_1.Column.ofIntArray(indices)
                        }];
            }
        });
    });
}
exports.sortAtomSite = sortAtomSite;
