"use strict";
/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.coordinatesFromDcd = void 0;
var tslib_1 = require("tslib");
var mol_task_1 = require("../../mol-task");
var coordinates_1 = require("../../mol-model/structure/coordinates");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var misc_1 = require("../../mol-math/misc");
var cell_1 = require("../../mol-math/geometry/spacegroup/cell");
var common_1 = require("../../mol-math/linear-algebra/3d/common");
var charmmTimeUnitFactor = 20.45482949774598;
function coordinatesFromDcd(dcdFile) {
    var _this = this;
    return mol_task_1.Task.create('Parse DCD', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var header, deltaTime, offsetTime, frames, i, il, dcdFrame, frame, c;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, ctx.update('Converting to coordinates')];
                case 1:
                    _a.sent();
                    header = dcdFile.header;
                    deltaTime = header.DELTA
                        ? (0, coordinates_1.Time)(header.DELTA * charmmTimeUnitFactor, 'ps')
                        : (0, coordinates_1.Time)(1, 'step');
                    offsetTime = header.ISTART >= 1
                        ? (0, coordinates_1.Time)((header.ISTART - 1) * deltaTime.value, deltaTime.unit)
                        : (0, coordinates_1.Time)(0, deltaTime.unit);
                    frames = [];
                    for (i = 0, il = dcdFile.frames.length; i < il; ++i) {
                        dcdFrame = dcdFile.frames[i];
                        frame = {
                            elementCount: dcdFrame.elementCount,
                            time: (0, coordinates_1.Time)(offsetTime.value + deltaTime.value * i, deltaTime.unit),
                            x: dcdFrame.x,
                            y: dcdFrame.y,
                            z: dcdFrame.z,
                            xyzOrdering: { isIdentity: true }
                        };
                        if (dcdFrame.cell) {
                            c = dcdFrame.cell;
                            if (c[1] >= -1 && c[1] <= 1 && c[3] >= -1 && c[3] <= 1 && c[4] >= -1 && c[4] <= 1) {
                                frame.cell = cell_1.Cell.create(linear_algebra_1.Vec3.create(c[0], c[2], c[5]), linear_algebra_1.Vec3.create((0, misc_1.degToRad)(90 - Math.asin(c[1]) * 90 / misc_1.halfPI), (0, misc_1.degToRad)(90 - Math.asin(c[3]) * 90 / misc_1.halfPI), (0, misc_1.degToRad)(90 - Math.asin(c[4]) * 90 / misc_1.halfPI)));
                            }
                            else if (c[0] < 0 || c[1] < 0 || c[2] < 0 || c[3] < 0 || c[4] < 0 || c[5] < 0 ||
                                c[3] > 180 || c[4] > 180 || c[5] > 180) {
                                frame.cell = cell_1.Cell.fromBasis(linear_algebra_1.Vec3.create(c[0], c[1], c[3]), linear_algebra_1.Vec3.create(c[1], c[2], c[4]), linear_algebra_1.Vec3.create(c[3], c[4], c[5]));
                            }
                            else {
                                frame.cell = cell_1.Cell.create(linear_algebra_1.Vec3.create(c[0], c[2], c[5]), 
                                // interpret angles very close to 0 as 90 deg
                                linear_algebra_1.Vec3.create((0, misc_1.degToRad)((0, common_1.equalEps)(c[1], 0, common_1.EPSILON) ? 90 : c[1]), (0, misc_1.degToRad)((0, common_1.equalEps)(c[3], 0, common_1.EPSILON) ? 90 : c[3]), (0, misc_1.degToRad)((0, common_1.equalEps)(c[4], 0, common_1.EPSILON) ? 90 : c[4])));
                            }
                        }
                        frames.push(frame);
                    }
                    return [2 /*return*/, coordinates_1.Coordinates.create(frames, deltaTime, offsetTime)];
            }
        });
    }); });
}
exports.coordinatesFromDcd = coordinatesFromDcd;
