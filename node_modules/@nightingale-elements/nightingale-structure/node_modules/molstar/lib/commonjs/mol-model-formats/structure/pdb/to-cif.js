"use strict";
/**
 * Copyright (c) 2019-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.pdbToMmCif = void 0;
var tslib_1 = require("tslib");
var string_1 = require("../../../mol-util/string");
var cif_1 = require("../../../mol-io/reader/cif");
var tokenizer_1 = require("../../../mol-io/reader/common/text/tokenizer");
var assembly_1 = require("./assembly");
var secondary_structure_1 = require("./secondary-structure");
var entity_1 = require("./entity");
var component_1 = require("../common/component");
var entity_2 = require("../common/entity");
var db_1 = require("../../../mol-data/db");
var types_1 = require("../../../mol-model/structure/model/types");
var atom_site_1 = require("./atom-site");
var anisotropic_1 = require("./anisotropic");
var conect_1 = require("./conect");
var debug_1 = require("../../../mol-util/debug");
function pdbToMmCif(pdb) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var lines, data, indices, tokenizer, isPdbqt, atomCount, anisotropicCount, i, _i, s, e, atomSite, anisotropic, entityBuilder, helperCategories, heteroNames, modelNum, modelStr, conectRange, terIndices, i, _i, s, e, j, j, j, j, j, j, j, seqIds, atomIds, compIds, asymIds, componentBuilder, i, il, compId, moleculeType, atom_site, categories, _a, helperCategories_1, c;
        return tslib_1.__generator(this, function (_b) {
            lines = pdb.lines;
            data = lines.data, indices = lines.indices;
            tokenizer = (0, tokenizer_1.Tokenizer)(data);
            isPdbqt = !!pdb.isPdbqt;
            atomCount = 0;
            anisotropicCount = 0;
            for (i = 0, _i = lines.count; i < _i; i++) {
                s = indices[2 * i], e = indices[2 * i + 1];
                switch (data[s]) {
                    case 'A':
                        if ((0, string_1.substringStartsWith)(data, s, e, 'ATOM  '))
                            atomCount++;
                        else if ((0, string_1.substringStartsWith)(data, s, e, 'ANISOU'))
                            anisotropicCount++;
                        break;
                    case 'H':
                        if ((0, string_1.substringStartsWith)(data, s, e, 'HETATM'))
                            atomCount++;
                        break;
                }
            }
            atomSite = (0, atom_site_1.getAtomSiteTemplate)(data, atomCount);
            anisotropic = (0, anisotropic_1.getAnisotropicTemplate)(data, anisotropicCount);
            entityBuilder = new entity_2.EntityBuilder();
            helperCategories = [];
            heteroNames = [];
            modelNum = 0, modelStr = '';
            conectRange = undefined;
            terIndices = new Set();
            for (i = 0, _i = lines.count; i < _i; i++) {
                s = indices[2 * i], e = indices[2 * i + 1];
                switch (data[s]) {
                    case 'A':
                        if ((0, string_1.substringStartsWith)(data, s, e, 'ATOM  ')) {
                            if (!modelNum) {
                                modelNum++;
                                modelStr = '' + modelNum;
                            }
                            (0, atom_site_1.addAtom)(atomSite, modelStr, tokenizer, s, e, isPdbqt);
                        }
                        else if ((0, string_1.substringStartsWith)(data, s, e, 'ANISOU')) {
                            (0, anisotropic_1.addAnisotropic)(anisotropic, modelStr, tokenizer, s, e);
                        }
                        break;
                    case 'C':
                        if ((0, string_1.substringStartsWith)(data, s, e, 'CRYST1')) {
                            helperCategories.push.apply(helperCategories, (0, assembly_1.parseCryst1)(pdb.id || '?', data.substring(s, e)));
                        }
                        else if ((0, string_1.substringStartsWith)(data, s, e, 'CONECT')) {
                            j = i + 1;
                            while (true) {
                                s = indices[2 * j];
                                e = indices[2 * j + 1];
                                if (!(0, string_1.substringStartsWith)(data, s, e, 'CONECT'))
                                    break;
                                j++;
                            }
                            if (conectRange) {
                                if (debug_1.isDebugMode) {
                                    console.log('only single CONECT block allowed, ignoring others');
                                }
                            }
                            else {
                                conectRange = [i, j];
                            }
                            i = j - 1;
                        }
                        else if ((0, string_1.substringStartsWith)(data, s, e, 'COMPND')) {
                            j = i + 1;
                            while (true) {
                                s = indices[2 * j];
                                e = indices[2 * j + 1];
                                if (!(0, string_1.substringStartsWith)(data, s, e, 'COMPND'))
                                    break;
                                j++;
                            }
                            entityBuilder.setCompounds((0, entity_1.parseCmpnd)(lines, i, j));
                            i = j - 1;
                        }
                        break;
                    case 'H':
                        if ((0, string_1.substringStartsWith)(data, s, e, 'HETATM')) {
                            if (!modelNum) {
                                modelNum++;
                                modelStr = '' + modelNum;
                            }
                            (0, atom_site_1.addAtom)(atomSite, modelStr, tokenizer, s, e, isPdbqt);
                        }
                        else if ((0, string_1.substringStartsWith)(data, s, e, 'HELIX')) {
                            j = i + 1;
                            while (true) {
                                s = indices[2 * j];
                                e = indices[2 * j + 1];
                                if (!(0, string_1.substringStartsWith)(data, s, e, 'HELIX'))
                                    break;
                                j++;
                            }
                            helperCategories.push((0, secondary_structure_1.parseHelix)(lines, i, j));
                            i = j - 1;
                        }
                        else if ((0, string_1.substringStartsWith)(data, s, e, 'HETNAM')) {
                            j = i + 1;
                            while (true) {
                                s = indices[2 * j];
                                e = indices[2 * j + 1];
                                if (!(0, string_1.substringStartsWith)(data, s, e, 'HETNAM'))
                                    break;
                                j++;
                            }
                            heteroNames.push.apply(heteroNames, Array.from((0, entity_1.parseHetnam)(lines, i, j).entries()));
                            i = j - 1;
                        }
                        break;
                    case 'M':
                        if ((0, string_1.substringStartsWith)(data, s, e, 'MODEL ')) {
                            modelNum++;
                            modelStr = '' + modelNum;
                        }
                        if ((0, string_1.substringStartsWith)(data, s, e, 'MTRIX')) {
                            j = i + 1;
                            while (true) {
                                s = indices[2 * j];
                                e = indices[2 * j + 1];
                                if (!(0, string_1.substringStartsWith)(data, s, e, 'MTRIX'))
                                    break;
                                j++;
                            }
                            helperCategories.push.apply(helperCategories, (0, assembly_1.parseMtrix)(lines, i, j));
                            i = j - 1;
                        }
                        // TODO: MODRES records => pdbx_struct_mod_residue
                        break;
                    case 'O':
                        // TODO: ORIGX record => cif.database_PDB_matrix.origx, cif.database_PDB_matrix.origx_vector
                        break;
                    case 'R':
                        if ((0, string_1.substringStartsWith)(data, s, e, 'REMARK 350')) {
                            j = i + 1;
                            while (true) {
                                s = indices[2 * j];
                                e = indices[2 * j + 1];
                                if (!(0, string_1.substringStartsWith)(data, s, e, 'REMARK 350'))
                                    break;
                                j++;
                            }
                            helperCategories.push.apply(helperCategories, (0, assembly_1.parseRemark350)(lines, i, j));
                            i = j - 1;
                        }
                        break;
                    case 'S':
                        if ((0, string_1.substringStartsWith)(data, s, e, 'SHEET')) {
                            j = i + 1;
                            while (true) {
                                s = indices[2 * j];
                                e = indices[2 * j + 1];
                                if (!(0, string_1.substringStartsWith)(data, s, e, 'SHEET'))
                                    break;
                                j++;
                            }
                            helperCategories.push((0, secondary_structure_1.parseSheet)(lines, i, j));
                            i = j - 1;
                        }
                        // TODO: SCALE record => cif.atom_sites.fract_transf_matrix, cif.atom_sites.fract_transf_vector
                        break;
                    case 'T':
                        if ((0, string_1.substringStartsWith)(data, s, e, 'TER')) {
                            terIndices.add(atomSite.index);
                        }
                }
            }
            seqIds = db_1.Column.ofIntTokens(atomSite.auth_seq_id);
            atomIds = db_1.Column.ofStringTokens(atomSite.auth_atom_id);
            compIds = db_1.Column.ofStringTokens(atomSite.auth_comp_id);
            asymIds = db_1.Column.ofStringTokens(atomSite.auth_asym_id);
            componentBuilder = new component_1.ComponentBuilder(seqIds, atomIds);
            componentBuilder.setNames(heteroNames);
            entityBuilder.setNames(heteroNames);
            for (i = 0, il = compIds.rowCount; i < il; ++i) {
                compId = compIds.value(i);
                moleculeType = (0, types_1.getMoleculeType)(componentBuilder.add(compId, i).type, compId);
                atomSite.label_entity_id[i] = entityBuilder.getEntityId(compId, moleculeType, asymIds.value(i));
            }
            atom_site = (0, atom_site_1.getAtomSite)(atomSite, terIndices);
            if (!isPdbqt)
                delete atom_site.partial_charge;
            if (conectRange) {
                helperCategories.push((0, conect_1.parseConect)(lines, conectRange[0], conectRange[1], atom_site));
            }
            categories = {
                entity: cif_1.CifCategory.ofTable('entity', entityBuilder.getEntityTable()),
                chem_comp: cif_1.CifCategory.ofTable('chem_comp', componentBuilder.getChemCompTable()),
                atom_site: cif_1.CifCategory.ofFields('atom_site', atom_site),
                atom_site_anisotrop: cif_1.CifCategory.ofFields('atom_site_anisotrop', (0, anisotropic_1.getAnisotropic)(anisotropic))
            };
            for (_a = 0, helperCategories_1 = helperCategories; _a < helperCategories_1.length; _a++) {
                c = helperCategories_1[_a];
                categories[c.name] = c;
            }
            return [2 /*return*/, {
                    header: pdb.id || 'PDB',
                    categoryNames: Object.keys(categories),
                    categories: categories
                }];
        });
    });
}
exports.pdbToMmCif = pdbToMmCif;
