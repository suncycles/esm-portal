"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElementSequenceWrapper = void 0;
var tslib_1 = require("tslib");
var structure_1 = require("../../mol-model/structure");
var wrapper_1 = require("./wrapper");
var int_1 = require("../../mol-data/int");
var names_1 = require("../../mol-util/color/names");
var marker_action_1 = require("../../mol-util/marker-action");
var ElementSequenceWrapper = /** @class */ (function (_super) {
    tslib_1.__extends(ElementSequenceWrapper, _super);
    function ElementSequenceWrapper(data) {
        var _this = this;
        var length = 0;
        var unitIndices = new Map();
        var lociElements = [];
        for (var i = 0, il = data.units.length; i < il; ++i) {
            var unit = data.units[i];
            length += unit.elements.length;
            var indices = int_1.Interval.ofBounds(0, unit.elements.length);
            unitIndices.set(unit.id, indices);
            lociElements.push({ unit: unit, indices: indices });
        }
        var markerArray = new Uint8Array(length);
        _this = _super.call(this, data, markerArray, length) || this;
        _this.unitIndices = unitIndices;
        return _this;
    }
    ElementSequenceWrapper.prototype.residueLabel = function (seqIdx) {
        return 'X';
    };
    ElementSequenceWrapper.prototype.residueColor = function (seqIdx) {
        return names_1.ColorNames.black;
    };
    ElementSequenceWrapper.prototype.residueClass = function (seqIdx) {
        return 'msp-sequence-present';
    };
    ElementSequenceWrapper.prototype.mark = function (loci, action) {
        var changed = false;
        var _a = this.data, structure = _a.structure, units = _a.units;
        if (structure_1.StructureElement.Loci.is(loci)) {
            if (!structure_1.Structure.areRootsEquivalent(loci.structure, structure))
                return false;
            loci = structure_1.StructureElement.Loci.remap(loci, structure);
            for (var _i = 0, _b = loci.elements; _i < _b.length; _i++) {
                var e = _b[_i];
                var indices = this.unitIndices.get(e.unit.id);
                if (indices) {
                    if (int_1.OrderedSet.isSubset(indices, e.indices)) {
                        if ((0, marker_action_1.applyMarkerAction)(this.markerArray, e.indices, action))
                            changed = true;
                    }
                }
            }
        }
        else if (structure_1.Structure.isLoci(loci)) {
            if (!structure_1.Structure.areRootsEquivalent(loci.structure, structure))
                return false;
            for (var i = 0, il = units.length; i < il; ++i) {
                var indices = this.unitIndices.get(units[i].id);
                if ((0, marker_action_1.applyMarkerAction)(this.markerArray, indices, action))
                    changed = true;
            }
        }
        return changed;
    };
    ElementSequenceWrapper.prototype.getLoci = function (seqIdx) {
        var units = this.data.units;
        var lociElements = [];
        var offset = 0;
        for (var i = 0, il = units.length; i < il; ++i) {
            var unit = units[i];
            if (seqIdx < offset + unit.elements.length) {
                lociElements.push({ unit: unit, indices: int_1.Interval.ofSingleton(seqIdx - offset) });
                break;
            }
            offset += unit.elements.length;
        }
        return structure_1.StructureElement.Loci(this.data.structure, lociElements);
    };
    return ElementSequenceWrapper;
}(wrapper_1.SequenceWrapper));
exports.ElementSequenceWrapper = ElementSequenceWrapper;
