"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleSettingsControl = void 0;
var tslib_1 = require("tslib");
var jsx_runtime_1 = require("react/jsx-runtime");
/**
 * Copyright (c) 2019-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author David Sehnal <david.sehnal@gmail.com>
 */
var immer_1 = require("immer");
var rxjs_1 = require("rxjs");
var canvas3d_1 = require("../../mol-canvas3d/canvas3d");
var commands_1 = require("../../mol-plugin/commands");
var config_1 = require("../../mol-plugin/config");
var mol_state_1 = require("../../mol-state");
var color_1 = require("../../mol-util/color");
var object_1 = require("../../mol-util/object");
var param_definition_1 = require("../../mol-util/param-definition");
var param_mapping_1 = require("../../mol-util/param-mapping");
var base_1 = require("../base");
var parameters_1 = require("../controls/parameters");
var help_1 = require("./help");
var SimpleSettingsControl = /** @class */ (function (_super) {
    tslib_1.__extends(SimpleSettingsControl, _super);
    function SimpleSettingsControl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleSettingsControl.prototype.componentDidMount = function () {
        var _this = this;
        if (!this.plugin.canvas3d)
            return;
        this.subscribe(this.plugin.events.canvas3d.settingsUpdated, function () { return _this.forceUpdate(); });
        this.subscribe(this.plugin.canvas3d.camera.stateChanged.pipe((0, rxjs_1.throttleTime)(500, undefined, { leading: true, trailing: true })), function (state) {
            if (state.radiusMax !== undefined || state.radius !== undefined) {
                _this.forceUpdate();
            }
        });
    };
    SimpleSettingsControl.prototype.render = function () {
        if (!this.plugin.canvas3d)
            return null;
        return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(parameters_1.ParameterMappingControl, { mapping: SimpleSettingsMapping }), (0, jsx_runtime_1.jsx)(help_1.ViewportHelpContent, {})] });
    };
    return SimpleSettingsControl;
}(base_1.PluginUIComponent));
exports.SimpleSettingsControl = SimpleSettingsControl;
var LayoutOptions = {
    'sequence': 'Sequence',
    'log': 'Log',
    'left': 'Left Panel'
};
var SimpleSettingsParams = {
    animate: canvas3d_1.Canvas3DParams.trackball.params.animate,
    camera: canvas3d_1.Canvas3DParams.camera,
    background: param_definition_1.ParamDefinition.Group({
        color: param_definition_1.ParamDefinition.Color((0, color_1.Color)(0xFCFBF9), { label: 'Background', description: 'Custom background color' }),
        transparent: param_definition_1.ParamDefinition.Boolean(false),
        style: canvas3d_1.Canvas3DParams.postprocessing.params.background,
    }, { pivot: 'color' }),
    lighting: param_definition_1.ParamDefinition.Group({
        occlusion: canvas3d_1.Canvas3DParams.postprocessing.params.occlusion,
        shadow: canvas3d_1.Canvas3DParams.postprocessing.params.shadow,
        outline: canvas3d_1.Canvas3DParams.postprocessing.params.outline,
        fog: canvas3d_1.Canvas3DParams.cameraFog,
    }, { isFlat: true }),
    clipping: param_definition_1.ParamDefinition.Group(tslib_1.__assign({}, canvas3d_1.Canvas3DParams.cameraClipping.params), { pivot: 'radius' }),
    layout: param_definition_1.ParamDefinition.MultiSelect([], param_definition_1.ParamDefinition.objectToOptions(LayoutOptions)),
};
var SimpleSettingsMapping = (0, param_mapping_1.ParamMapping)({
    params: function (ctx) {
        var _a;
        var params = param_definition_1.ParamDefinition.clone(SimpleSettingsParams);
        var controls = (_a = ctx.spec.components) === null || _a === void 0 ? void 0 : _a.controls;
        if (controls) {
            var options = [];
            if (controls.top !== 'none')
                options.push(['sequence', LayoutOptions.sequence]);
            if (controls.bottom !== 'none')
                options.push(['log', LayoutOptions.log]);
            if (controls.left !== 'none')
                options.push(['left', LayoutOptions.left]);
            params.layout.options = options;
        }
        var bgStyles = ctx.config.get(config_1.PluginConfig.Background.Styles) || [];
        if (bgStyles.length > 0) {
            Object.assign(params.background.params.style, {
                presets: (0, object_1.deepClone)(bgStyles),
                isFlat: false, // so the presets menu is shown
            });
        }
        return params;
    },
    target: function (ctx) {
        var _a, _b;
        var c = (_a = ctx.spec.components) === null || _a === void 0 ? void 0 : _a.controls;
        var r = ctx.layout.state.regionState;
        var layout = [];
        if (r.top !== 'hidden' && (!c || c.top !== 'none'))
            layout.push('sequence');
        if (r.bottom !== 'hidden' && (!c || c.bottom !== 'none'))
            layout.push('log');
        if (r.left !== 'hidden' && (!c || c.left !== 'none'))
            layout.push('left');
        return { canvas: (_b = ctx.canvas3d) === null || _b === void 0 ? void 0 : _b.props, layout: layout };
    }
})({
    values: function (props, ctx) {
        var canvas = props.canvas;
        var renderer = canvas.renderer;
        return {
            layout: props.layout,
            animate: canvas.trackball.animate,
            camera: canvas.camera,
            background: {
                color: renderer.backgroundColor,
                transparent: canvas.transparentBackground,
                style: canvas.postprocessing.background,
            },
            lighting: {
                occlusion: canvas.postprocessing.occlusion,
                shadow: canvas.postprocessing.shadow,
                outline: canvas.postprocessing.outline,
                fog: canvas.cameraFog,
            },
            clipping: tslib_1.__assign({}, canvas.cameraClipping)
        };
    },
    update: function (s, props) {
        var canvas = props.canvas;
        canvas.trackball.animate = s.animate;
        canvas.camera = s.camera;
        canvas.transparentBackground = s.background.transparent;
        canvas.renderer.backgroundColor = s.background.color;
        canvas.postprocessing.occlusion = s.lighting.occlusion;
        canvas.postprocessing.shadow = s.lighting.shadow;
        canvas.postprocessing.outline = s.lighting.outline;
        canvas.postprocessing.background = s.background.style;
        canvas.cameraFog = s.lighting.fog;
        canvas.cameraClipping = {
            radius: s.clipping.radius,
            far: s.clipping.far,
            minNear: s.clipping.minNear,
        };
        props.layout = s.layout;
    },
    apply: function (props, ctx) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var hideLeft, state;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, commands_1.PluginCommands.Canvas3D.SetSettings(ctx, { settings: props.canvas })];
                    case 1:
                        _a.sent();
                        hideLeft = props.layout.indexOf('left') < 0;
                        state = (0, immer_1.produce)(ctx.layout.state, function (s) {
                            s.regionState.top = props.layout.indexOf('sequence') >= 0 ? 'full' : 'hidden';
                            s.regionState.bottom = props.layout.indexOf('log') >= 0 ? 'full' : 'hidden';
                            s.regionState.left = hideLeft ? 'hidden' : ctx.behaviors.layout.leftPanelTabName.value === 'none' ? 'collapsed' : 'full';
                        });
                        return [4 /*yield*/, commands_1.PluginCommands.Layout.Update(ctx, { state: state })];
                    case 2:
                        _a.sent();
                        if (hideLeft) {
                            commands_1.PluginCommands.State.SetCurrentObject(ctx, { state: ctx.state.data, ref: mol_state_1.StateTransform.RootRef });
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
});
