"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolymerSequenceWrapper = void 0;
var tslib_1 = require("tslib");
var structure_1 = require("../../mol-model/structure");
var wrapper_1 = require("./wrapper");
var int_1 = require("../../mol-data/int");
var names_1 = require("../../mol-util/color/names");
var marker_action_1 = require("../../mol-util/marker-action");
var PolymerSequenceWrapper = /** @class */ (function (_super) {
    tslib_1.__extends(PolymerSequenceWrapper, _super);
    function PolymerSequenceWrapper(data) {
        var _this = this;
        var l = structure_1.StructureElement.Location.create(data.structure, data.units[0], data.units[0].elements[0]);
        var entitySeq = data.units[0].model.sequence.byEntityKey[structure_1.StructureProperties.entity.key(l)];
        var length = entitySeq.sequence.length;
        var markerArray = new Uint8Array(length);
        _this = _super.call(this, data, markerArray, length) || this;
        _this.unitMap = new Map();
        for (var _i = 0, _a = data.units; _i < _a.length; _i++) {
            var unit = _a[_i];
            _this.unitMap.set(unit.id, unit);
        }
        _this.sequence = entitySeq.sequence;
        _this.missing = data.units[0].model.properties.missingResidues;
        _this.modelNum = data.units[0].model.modelNum;
        _this.asymId = structure_1.Unit.isAtomic(data.units[0]) ? structure_1.StructureProperties.chain.label_asym_id(l) : structure_1.StructureProperties.coarse.asym_id(l);
        var missing = [];
        for (var i = 0; i < length; ++i) {
            if (_this.missing.has(_this.modelNum, _this.asymId, _this.seqId(i)))
                missing.push(i);
        }
        _this.observed = int_1.OrderedSet.subtract(int_1.Interval.ofBounds(0, length), int_1.SortedArray.ofSortedArray(missing));
        return _this;
    }
    PolymerSequenceWrapper.prototype.seqId = function (seqIdx) {
        return this.sequence.seqId.value(seqIdx);
    };
    PolymerSequenceWrapper.prototype.residueLabel = function (seqIdx) {
        return this.sequence.label.value(seqIdx) || this.sequence.code.value(seqIdx);
    };
    PolymerSequenceWrapper.prototype.residueColor = function (seqIdx) {
        return this.missing.has(this.modelNum, this.asymId, this.seqId(seqIdx))
            ? names_1.ColorNames.grey
            : names_1.ColorNames.black;
    };
    PolymerSequenceWrapper.prototype.residueClass = function (seqIdx) {
        return this.missing.has(this.modelNum, this.asymId, this.seqId(seqIdx))
            ? 'msp-sequence-missing'
            : 'msp-sequence-present';
    };
    PolymerSequenceWrapper.prototype.mark = function (loci, action) {
        var _this = this;
        var changed = false;
        var structure = this.data.structure;
        var index = function (seqId) { return _this.sequence.index(seqId); };
        if (structure_1.StructureElement.Loci.is(loci)) {
            if (!structure_1.Structure.areRootsEquivalent(loci.structure, structure))
                return false;
            loci = structure_1.StructureElement.Loci.remap(loci, structure);
            for (var _i = 0, _a = loci.elements; _i < _a.length; _i++) {
                var e = _a[_i];
                if (!this.unitMap.has(e.unit.id))
                    continue;
                if (structure_1.Unit.isAtomic(e.unit)) {
                    changed = applyMarkerAtomic(e, action, this.markerArray, index) || changed;
                }
                else {
                    changed = applyMarkerCoarse(e, action, this.markerArray, index) || changed;
                }
            }
        }
        else if (structure_1.Structure.isLoci(loci)) {
            if (!structure_1.Structure.areRootsEquivalent(loci.structure, structure))
                return false;
            if ((0, marker_action_1.applyMarkerAction)(this.markerArray, this.observed, action))
                changed = true;
        }
        return changed;
    };
    PolymerSequenceWrapper.prototype.getLoci = function (seqIdx) {
        var query = createResidueQuery(this.data.units[0].chainGroupId, this.data.units[0].conformation.operator.name, this.seqId(seqIdx));
        return structure_1.StructureSelection.toLociWithSourceUnits(structure_1.StructureQuery.run(query, this.data.structure));
    };
    return PolymerSequenceWrapper;
}(wrapper_1.SequenceWrapper));
exports.PolymerSequenceWrapper = PolymerSequenceWrapper;
function createResidueQuery(chainGroupId, operatorName, label_seq_id) {
    return structure_1.Queries.generators.atoms({
        unitTest: function (ctx) {
            return (structure_1.StructureProperties.unit.chainGroupId(ctx.element) === chainGroupId &&
                structure_1.StructureProperties.unit.operator_name(ctx.element) === operatorName);
        },
        residueTest: function (ctx) {
            if (ctx.element.unit.kind === 0 /* Unit.Kind.Atomic */) {
                return structure_1.StructureProperties.residue.label_seq_id(ctx.element) === label_seq_id;
            }
            else {
                return (structure_1.StructureProperties.coarse.seq_id_begin(ctx.element) <= label_seq_id &&
                    structure_1.StructureProperties.coarse.seq_id_end(ctx.element) >= label_seq_id);
            }
        }
    });
}
function applyMarkerAtomic(e, action, markerArray, index) {
    var _a = e.unit, model = _a.model, elements = _a.elements;
    var residueIndex = model.atomicHierarchy.residueAtomSegments.index;
    var label_seq_id = model.atomicHierarchy.residues.label_seq_id;
    int_1.OrderedSet.forEachSegment(e.indices, function (i) { return residueIndex[elements[i]]; }, function (rI) {
        var seqId = label_seq_id.value(rI);
        (0, marker_action_1.applyMarkerActionAtPosition)(markerArray, index(seqId), action);
    });
    return true;
}
function applyMarkerCoarse(e, action, markerArray, index) {
    var _a = e.unit, model = _a.model, elements = _a.elements;
    var begin = structure_1.Unit.isSpheres(e.unit) ? model.coarseHierarchy.spheres.seq_id_begin : model.coarseHierarchy.gaussians.seq_id_begin;
    var end = structure_1.Unit.isSpheres(e.unit) ? model.coarseHierarchy.spheres.seq_id_end : model.coarseHierarchy.gaussians.seq_id_end;
    int_1.OrderedSet.forEach(e.indices, function (i) {
        var eI = elements[i];
        for (var s = index(begin.value(eI)), e_1 = index(end.value(eI)); s <= e_1; s++) {
            (0, marker_action_1.applyMarkerActionAtPosition)(markerArray, s, action);
        }
    });
    return true;
}
