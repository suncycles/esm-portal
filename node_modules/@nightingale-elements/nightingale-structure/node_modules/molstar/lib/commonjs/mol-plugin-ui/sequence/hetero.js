"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HeteroSequenceWrapper = void 0;
var tslib_1 = require("tslib");
var structure_1 = require("../../mol-model/structure");
var wrapper_1 = require("./wrapper");
var int_1 = require("../../mol-data/int");
var names_1 = require("../../mol-util/color/names");
var marker_action_1 = require("../../mol-util/marker-action");
var HeteroSequenceWrapper = /** @class */ (function (_super) {
    tslib_1.__extends(HeteroSequenceWrapper, _super);
    function HeteroSequenceWrapper(data) {
        var _this = this;
        var sequence = [];
        var sequenceIndices = new Map();
        var residueIndices = new Map();
        var seqToUnit = new Map();
        for (var i = 0, il = data.units.length; i < il; ++i) {
            var unit = data.units[i];
            var _a = unit.model.atomicHierarchy, residueAtomSegments = _a.residueAtomSegments, atoms = _a.atoms;
            var residueIt = int_1.Segmentation.transientSegments(residueAtomSegments, unit.elements);
            while (residueIt.hasNext) {
                var index = residueIt.move().index;
                sequenceIndices.set(index, sequence.length);
                residueIndices.set(sequence.length, index);
                seqToUnit.set(sequence.length, unit);
                sequence.push(atoms.label_comp_id.value(residueAtomSegments.offsets[index]));
            }
        }
        var length = sequence.length;
        var markerArray = new Uint8Array(length);
        _this = _super.call(this, data, markerArray, length) || this;
        _this.unitMap = new Map();
        for (var _i = 0, _b = data.units; _i < _b.length; _i++) {
            var unit = _b[_i];
            _this.unitMap.set(unit.id, unit);
        }
        _this.sequence = sequence;
        _this.sequenceIndices = sequenceIndices;
        _this.residueIndices = residueIndices;
        _this.seqToUnit = seqToUnit;
        return _this;
    }
    HeteroSequenceWrapper.prototype.residueLabel = function (seqIdx) {
        return this.sequence[seqIdx];
    };
    HeteroSequenceWrapper.prototype.residueColor = function (seqIdx) {
        return names_1.ColorNames.black;
    };
    HeteroSequenceWrapper.prototype.residueClass = function (seqIdx) {
        return 'msp-sequence-present';
    };
    HeteroSequenceWrapper.prototype.mark = function (loci, action) {
        var _this = this;
        var changed = false;
        var structure = this.data.structure;
        if (structure_1.StructureElement.Loci.is(loci)) {
            if (!structure_1.Structure.areRootsEquivalent(loci.structure, structure))
                return false;
            loci = structure_1.StructureElement.Loci.remap(loci, structure);
            var _loop_1 = function (e) {
                var unit = this_1.unitMap.get(e.unit.id);
                if (unit) {
                    var residueIndex_1 = e.unit.model.atomicHierarchy.residueAtomSegments.index;
                    int_1.OrderedSet.forEach(e.indices, function (v) {
                        var seqIdx = _this.sequenceIndices.get(residueIndex_1[unit.elements[v]]);
                        if (seqIdx !== undefined && (0, marker_action_1.applyMarkerAction)(_this.markerArray, int_1.Interval.ofSingleton(seqIdx), action))
                            changed = true;
                    });
                }
            };
            var this_1 = this;
            for (var _i = 0, _a = loci.elements; _i < _a.length; _i++) {
                var e = _a[_i];
                _loop_1(e);
            }
        }
        else if (structure_1.Structure.isLoci(loci)) {
            if (!structure_1.Structure.areRootsEquivalent(loci.structure, structure))
                return false;
            if ((0, marker_action_1.applyMarkerAction)(this.markerArray, int_1.Interval.ofBounds(0, this.length), action))
                changed = true;
        }
        return changed;
    };
    HeteroSequenceWrapper.prototype.getLoci = function (seqIdx) {
        var elements = [];
        var rI = this.residueIndices.get(seqIdx);
        if (rI !== undefined) {
            var unit = this.seqToUnit.get(seqIdx);
            var offsets = unit.model.atomicHierarchy.residueAtomSegments.offsets;
            var start = int_1.SortedArray.findPredecessorIndex(unit.elements, offsets[rI]);
            var end = int_1.SortedArray.findPredecessorIndex(unit.elements, offsets[rI + 1]);
            elements.push({ unit: unit, indices: int_1.Interval.ofBounds(start, end) });
        }
        return structure_1.StructureElement.Loci(this.data.structure, elements);
    };
    return HeteroSequenceWrapper;
}(wrapper_1.SequenceWrapper));
exports.HeteroSequenceWrapper = HeteroSequenceWrapper;
