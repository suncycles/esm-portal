"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValenceModel = void 0;
var tslib_1 = require("tslib");
var behavior_1 = require("../../../behavior");
var param_definition_1 = require("../../../../../mol-util/param-definition");
var valence_model_1 = require("../../../../../mol-model-props/computed/valence-model");
var objects_1 = require("../../../../../mol-plugin-state/objects");
var mol_state_1 = require("../../../../../mol-state");
var structure_1 = require("../../../../../mol-model/structure");
var int_1 = require("../../../../../mol-data/int");
var geometry_1 = require("../../../../../mol-model-props/computed/chemistry/geometry");
var array_1 = require("../../../../../mol-util/array");
exports.ValenceModel = behavior_1.PluginBehavior.create({
    name: 'computed-valence-model-prop',
    category: 'custom-props',
    display: { name: 'Valence Model' },
    ctor: /** @class */ (function (_super) {
        tslib_1.__extends(class_1, _super);
        function class_1() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.provider = valence_model_1.ValenceModelProvider;
            _this.labelProvider = {
                label: function (loci) {
                    if (!_this.params.showTooltip)
                        return void 0;
                    switch (loci.kind) {
                        case 'element-loci':
                            if (loci.elements.length === 0)
                                return void 0;
                            var labels = [];
                            var structures = _this.getStructures(loci.structure);
                            for (var _i = 0, structures_1 = structures; _i < structures_1.length; _i++) {
                                var s = structures_1[_i];
                                var valenceModel = _this.provider.get(s).value;
                                if (!valenceModel)
                                    continue;
                                var l = structure_1.StructureElement.Loci.remap(loci, s);
                                if (l.elements.length !== 1)
                                    continue;
                                var e = l.elements[0];
                                if (int_1.OrderedSet.size(e.indices) !== 1)
                                    continue;
                                var vm = valenceModel.get(e.unit.id);
                                if (!vm)
                                    continue;
                                var idx = int_1.OrderedSet.start(e.indices);
                                var charge = vm.charge[idx];
                                var idealGeometry = vm.idealGeometry[idx];
                                var implicitH = vm.implicitH[idx];
                                var totalH = vm.totalH[idx];
                                labels.push("Valence Model: <small>Charge</small> ".concat(charge, " | <small>Ideal Geometry</small> ").concat((0, geometry_1.geometryLabel)(idealGeometry), " | <small>Implicit H</small> ").concat(implicitH, " | <small>Total H</small> ").concat(totalH));
                            }
                            return labels.length ? labels.join('<br/>') : undefined;
                        default: return void 0;
                    }
                }
            };
            return _this;
        }
        class_1.prototype.getStructures = function (structure) {
            var structures = [];
            var root = this.ctx.helpers.substructureParent.get(structure);
            if (root) {
                var state = this.ctx.state.data;
                var selections = state.select(mol_state_1.StateSelection.Generators.ofType(objects_1.PluginStateObject.Molecule.Structure, root.transform.ref));
                for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {
                    var s = selections_1[_i];
                    if (s.obj)
                        (0, array_1.arraySetAdd)(structures, s.obj.data);
                }
            }
            return structures;
        };
        class_1.prototype.update = function (p) {
            var updated = (this.params.autoAttach !== p.autoAttach ||
                this.params.showTooltip !== p.showTooltip);
            this.params.autoAttach = p.autoAttach;
            this.params.showTooltip = p.showTooltip;
            this.ctx.customStructureProperties.setDefaultAutoAttach(this.provider.descriptor.name, this.params.autoAttach);
            return updated;
        };
        class_1.prototype.register = function () {
            this.ctx.customStructureProperties.register(this.provider, this.params.autoAttach);
            this.ctx.managers.lociLabels.addProvider(this.labelProvider);
        };
        class_1.prototype.unregister = function () {
            this.ctx.customStructureProperties.unregister(this.provider.descriptor.name);
            this.ctx.managers.lociLabels.removeProvider(this.labelProvider);
        };
        return class_1;
    }(behavior_1.PluginBehavior.Handler)),
    params: function () { return ({
        autoAttach: param_definition_1.ParamDefinition.Boolean(false),
        showTooltip: param_definition_1.ParamDefinition.Boolean(true)
    }); }
});
