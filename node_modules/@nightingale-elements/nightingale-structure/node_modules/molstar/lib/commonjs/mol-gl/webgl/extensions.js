"use strict";
/**
 * Copyright (c) 2018-2023 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createExtensions = void 0;
var compat_1 = require("./compat");
var debug_1 = require("../../mol-util/debug");
function createExtensions(gl) {
    var instancedArrays = (0, compat_1.getInstancedArrays)(gl);
    if (instancedArrays === null) {
        throw new Error('Could not find support for "instanced_arrays"');
    }
    var elementIndexUint = (0, compat_1.getElementIndexUint)(gl);
    if (elementIndexUint === null) {
        throw new Error('Could not find support for "element_index_uint"');
    }
    var standardDerivatives = (0, compat_1.getStandardDerivatives)(gl);
    if (standardDerivatives === null) {
        throw new Error('Could not find support for "standard_derivatives"');
    }
    var textureFloat = (0, compat_1.getTextureFloat)(gl);
    if (debug_1.isDebugMode && textureFloat === null) {
        console.log('Could not find support for "texture_float"');
    }
    var textureFloatLinear = (0, compat_1.getTextureFloatLinear)(gl);
    if (debug_1.isDebugMode && textureFloatLinear === null) {
        // TODO handle non-support downstream (no gpu gaussian calc, no gpu mc???)
        // - can't be a required extension because it is not supported by `headless-gl`
        console.log('Could not find support for "texture_float_linear"');
    }
    var textureHalfFloat = (0, compat_1.getTextureHalfFloat)(gl);
    if (debug_1.isDebugMode && textureHalfFloat === null) {
        console.log('Could not find support for "texture_half_float"');
    }
    var textureHalfFloatLinear = (0, compat_1.getTextureHalfFloatLinear)(gl);
    if (debug_1.isDebugMode && textureHalfFloatLinear === null) {
        // TODO handle non-support downstream (no gpu gaussian calc, no gpu mc???)
        // - can't be a required extension because it is not supported by `headless-gl`
        console.log('Could not find support for "texture_half_float_linear"');
    }
    var depthTexture = (0, compat_1.getDepthTexture)(gl);
    if (debug_1.isDebugMode && depthTexture === null) {
        console.log('Could not find support for "depth_texture"');
    }
    var blendMinMax = (0, compat_1.getBlendMinMax)(gl);
    if (debug_1.isDebugMode && blendMinMax === null) {
        // TODO handle non-support downstream (e.g. no gpu gaussian calc)
        // - can't be a required extension because it is not supported by `headless-gl`
        console.log('Could not find support for "blend_minmax"');
    }
    var vertexArrayObject = (0, compat_1.getVertexArrayObject)(gl);
    if (debug_1.isDebugMode && vertexArrayObject === null) {
        console.log('Could not find support for "vertex_array_object"');
    }
    var fragDepth = (0, compat_1.getFragDepth)(gl);
    if (debug_1.isDebugMode && fragDepth === null) {
        console.log('Could not find support for "frag_depth"');
    }
    var colorBufferFloat = (0, compat_1.getColorBufferFloat)(gl);
    if (debug_1.isDebugMode && colorBufferFloat === null) {
        console.log('Could not find support for "color_buffer_float"');
    }
    var colorBufferHalfFloat = (0, compat_1.getColorBufferHalfFloat)(gl);
    if (debug_1.isDebugMode && colorBufferHalfFloat === null) {
        console.log('Could not find support for "color_buffer_half_float"');
    }
    var drawBuffers = (0, compat_1.getDrawBuffers)(gl);
    if (debug_1.isDebugMode && drawBuffers === null) {
        console.log('Could not find support for "draw_buffers"');
    }
    var drawBuffersIndexed = (0, compat_1.getDrawBuffersIndexed)(gl);
    if (debug_1.isDebugMode && drawBuffersIndexed === null) {
        console.log('Could not find support for "draw_buffers_indexed"');
    }
    var shaderTextureLod = (0, compat_1.getShaderTextureLod)(gl);
    if (debug_1.isDebugMode && shaderTextureLod === null) {
        console.log('Could not find support for "shader_texture_lod"');
    }
    var sRGB = (0, compat_1.getSRGB)(gl);
    if (debug_1.isDebugMode && sRGB === null) {
        console.log('Could not find support for "sRGB"');
    }
    var disjointTimerQuery = (0, compat_1.getDisjointTimerQuery)(gl);
    if (debug_1.isDebugMode && disjointTimerQuery === null) {
        console.log('Could not find support for "disjoint_timer_query"');
    }
    var parallelShaderCompile = (0, compat_1.getParallelShaderCompile)(gl);
    if (debug_1.isDebugMode && parallelShaderCompile === null) {
        console.log('Could not find support for "parallel_shader_compile"');
    }
    var fboRenderMipmap = (0, compat_1.getFboRenderMipmap)(gl);
    if (debug_1.isDebugMode && fboRenderMipmap === null) {
        console.log('Could not find support for "fbo_render_mipmap"');
    }
    var provokingVertex = (0, compat_1.getProvokingVertex)(gl);
    if (debug_1.isDebugMode && provokingVertex === null) {
        console.log('Could not find support for "provoking_vertex"');
    }
    var noNonInstancedActiveAttribs = (0, compat_1.getNoNonInstancedActiveAttribs)(gl);
    return {
        instancedArrays: instancedArrays,
        standardDerivatives: standardDerivatives,
        elementIndexUint: elementIndexUint,
        textureFloat: textureFloat,
        textureFloatLinear: textureFloatLinear,
        textureHalfFloat: textureHalfFloat,
        textureHalfFloatLinear: textureHalfFloatLinear,
        depthTexture: depthTexture,
        blendMinMax: blendMinMax,
        vertexArrayObject: vertexArrayObject,
        fragDepth: fragDepth,
        colorBufferFloat: colorBufferFloat,
        colorBufferHalfFloat: colorBufferHalfFloat,
        drawBuffers: drawBuffers,
        drawBuffersIndexed: drawBuffersIndexed,
        shaderTextureLod: shaderTextureLod,
        sRGB: sRGB,
        disjointTimerQuery: disjointTimerQuery,
        parallelShaderCompile: parallelShaderCompile,
        fboRenderMipmap: fboRenderMipmap,
        provokingVertex: provokingVertex,
        noNonInstancedActiveAttribs: noNonInstancedActiveAttribs,
    };
}
exports.createExtensions = createExtensions;
