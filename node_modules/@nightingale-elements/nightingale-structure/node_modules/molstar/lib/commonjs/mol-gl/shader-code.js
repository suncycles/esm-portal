"use strict";
/**
 * Copyright (c) 2018-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.addShaderDefines = exports.ImageShaderCode = exports.DirectVolumeShaderCode = exports.MeshShaderCode = exports.LinesShaderCode = exports.TextShaderCode = exports.CylindersShaderCode = exports.SpheresShaderCode = exports.PointsShaderCode = exports.ShaderCode = void 0;
var id_factory_1 = require("../mol-util/id-factory");
var compat_1 = require("./webgl/compat");
var shaderCodeId = (0, id_factory_1.idFactory)();
var apply_fog_glsl_1 = require("./shader/chunks/apply-fog.glsl");
var apply_interior_color_glsl_1 = require("./shader/chunks/apply-interior-color.glsl");
var apply_light_color_glsl_1 = require("./shader/chunks/apply-light-color.glsl");
var apply_marker_color_glsl_1 = require("./shader/chunks/apply-marker-color.glsl");
var assign_clipping_varying_glsl_1 = require("./shader/chunks/assign-clipping-varying.glsl");
var assign_color_varying_glsl_1 = require("./shader/chunks/assign-color-varying.glsl");
var assign_group_glsl_1 = require("./shader/chunks/assign-group.glsl");
var assign_marker_varying_glsl_1 = require("./shader/chunks/assign-marker-varying.glsl");
var assign_material_color_glsl_1 = require("./shader/chunks/assign-material-color.glsl");
var assign_position_glsl_1 = require("./shader/chunks/assign-position.glsl");
var assign_size_glsl_1 = require("./shader/chunks/assign-size.glsl");
var check_picking_alpha_glsl_1 = require("./shader/chunks/check-picking-alpha.glsl");
var clip_instance_glsl_1 = require("./shader/chunks/clip-instance.glsl");
var clip_pixel_glsl_1 = require("./shader/chunks/clip-pixel.glsl");
var color_frag_params_glsl_1 = require("./shader/chunks/color-frag-params.glsl");
var color_vert_params_glsl_1 = require("./shader/chunks/color-vert-params.glsl");
var common_clip_glsl_1 = require("./shader/chunks/common-clip.glsl");
var common_frag_params_glsl_1 = require("./shader/chunks/common-frag-params.glsl");
var common_vert_params_glsl_1 = require("./shader/chunks/common-vert-params.glsl");
var common_glsl_1 = require("./shader/chunks/common.glsl");
var float_to_rgba_glsl_1 = require("./shader/chunks/float-to-rgba.glsl");
var light_frag_params_glsl_1 = require("./shader/chunks/light-frag-params.glsl");
var matrix_scale_glsl_1 = require("./shader/chunks/matrix-scale.glsl");
var normal_frag_params_glsl_1 = require("./shader/chunks/normal-frag-params.glsl");
var read_from_texture_glsl_1 = require("./shader/chunks/read-from-texture.glsl");
var rgba_to_float_glsl_1 = require("./shader/chunks/rgba-to-float.glsl");
var size_vert_params_glsl_1 = require("./shader/chunks/size-vert-params.glsl");
var texture3d_from_1d_trilinear_glsl_1 = require("./shader/chunks/texture3d-from-1d-trilinear.glsl");
var texture3d_from_2d_linear_glsl_1 = require("./shader/chunks/texture3d-from-2d-linear.glsl");
var texture3d_from_2d_nearest_glsl_1 = require("./shader/chunks/texture3d-from-2d-nearest.glsl");
var wboit_write_glsl_1 = require("./shader/chunks/wboit-write.glsl");
var dpoit_write_glsl_1 = require("./shader/chunks/dpoit-write.glsl");
var ShaderChunks = {
    apply_fog: apply_fog_glsl_1.apply_fog,
    apply_interior_color: apply_interior_color_glsl_1.apply_interior_color,
    apply_light_color: apply_light_color_glsl_1.apply_light_color,
    apply_marker_color: apply_marker_color_glsl_1.apply_marker_color,
    assign_clipping_varying: assign_clipping_varying_glsl_1.assign_clipping_varying,
    assign_color_varying: assign_color_varying_glsl_1.assign_color_varying,
    assign_group: assign_group_glsl_1.assign_group,
    assign_marker_varying: assign_marker_varying_glsl_1.assign_marker_varying,
    assign_material_color: assign_material_color_glsl_1.assign_material_color,
    assign_position: assign_position_glsl_1.assign_position,
    assign_size: assign_size_glsl_1.assign_size,
    check_picking_alpha: check_picking_alpha_glsl_1.check_picking_alpha,
    clip_instance: clip_instance_glsl_1.clip_instance,
    clip_pixel: clip_pixel_glsl_1.clip_pixel,
    color_frag_params: color_frag_params_glsl_1.color_frag_params,
    color_vert_params: color_vert_params_glsl_1.color_vert_params,
    common_clip: common_clip_glsl_1.common_clip,
    common_frag_params: common_frag_params_glsl_1.common_frag_params,
    common_vert_params: common_vert_params_glsl_1.common_vert_params,
    common: common_glsl_1.common,
    float_to_rgba: float_to_rgba_glsl_1.float_to_rgba,
    light_frag_params: light_frag_params_glsl_1.light_frag_params,
    matrix_scale: matrix_scale_glsl_1.matrix_scale,
    normal_frag_params: normal_frag_params_glsl_1.normal_frag_params,
    read_from_texture: read_from_texture_glsl_1.read_from_texture,
    rgba_to_float: rgba_to_float_glsl_1.rgba_to_float,
    size_vert_params: size_vert_params_glsl_1.size_vert_params,
    texture3d_from_1d_trilinear: texture3d_from_1d_trilinear_glsl_1.texture3d_from_1d_trilinear,
    texture3d_from_2d_linear: texture3d_from_2d_linear_glsl_1.texture3d_from_2d_linear,
    texture3d_from_2d_nearest: texture3d_from_2d_nearest_glsl_1.texture3d_from_2d_nearest,
    wboit_write: wboit_write_glsl_1.wboit_write,
    dpoit_write: dpoit_write_glsl_1.dpoit_write
};
var reInclude = /^(?!\/\/)\s*#include\s+(\S+)/gm;
var reUnrollLoop = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*\+\+i\s*\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
var reSingleLineComment = /[ \t]*\/\/.*\n/g;
var reMultiLineComment = /[ \t]*\/\*[\s\S]*?\*\//g;
var reMultipleLinebreaks = /\n{2,}/g;
function addIncludes(text) {
    return text
        .replace(reInclude, function (_, p1) {
        var chunk = ShaderChunks[p1];
        if (!chunk)
            throw new Error("empty chunk, '".concat(p1, "'"));
        return chunk;
    })
        .trim()
        .replace(reSingleLineComment, '\n')
        .replace(reMultiLineComment, '\n')
        .replace(reMultipleLinebreaks, '\n');
}
function unrollLoops(str) {
    return str.replace(reUnrollLoop, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
    var out = '';
    for (var i = parseInt(start); i < parseInt(end); ++i) {
        out += snippet
            .replace(/\[\s*i\s*\]/g, "[".concat(i, "]"))
            .replace(/UNROLLED_LOOP_INDEX/g, "".concat(i));
    }
    return out;
}
function replaceCounts(str, defines) {
    if (defines.dLightCount)
        str = str.replace(/dLightCount/g, "".concat(defines.dLightCount.ref.value));
    if (defines.dClipObjectCount)
        str = str.replace(/dClipObjectCount/g, "".concat(defines.dClipObjectCount.ref.value));
    return str;
}
function preprocess(str, defines) {
    return unrollLoops(replaceCounts(str, defines));
}
function ShaderCode(name, vert, frag, extensions, outTypes, ignoreDefine) {
    if (extensions === void 0) { extensions = {}; }
    if (outTypes === void 0) { outTypes = {}; }
    return { id: shaderCodeId(), name: name, vert: addIncludes(vert), frag: addIncludes(frag), extensions: extensions, outTypes: outTypes, ignoreDefine: ignoreDefine };
}
exports.ShaderCode = ShaderCode;
// Note: `drawBuffers` need to be 'optional' for wboit
function ignoreDefine(name, variant, defines) {
    var _a;
    if (variant.startsWith('color')) {
        if (name === 'dLightCount') {
            return !!((_a = defines.dIgnoreLight) === null || _a === void 0 ? void 0 : _a.ref.value);
        }
    }
    else {
        return [
            'dColorType', 'dUsePalette',
            'dLightCount',
            'dOverpaintType', 'dOverpaint',
            'dSubstanceType', 'dSubstance',
        ].includes(name);
    }
    return false;
}
;
function ignoreDefineUnlit(name, variant, defines) {
    if (name === 'dLightCount')
        return true;
    return ignoreDefine(name, variant, defines);
}
;
var points_vert_1 = require("./shader/points.vert");
var points_frag_1 = require("./shader/points.frag");
exports.PointsShaderCode = ShaderCode('points', points_vert_1.points_vert, points_frag_1.points_frag, { drawBuffers: 'optional' }, {}, ignoreDefineUnlit);
var spheres_vert_1 = require("./shader/spheres.vert");
var spheres_frag_1 = require("./shader/spheres.frag");
exports.SpheresShaderCode = ShaderCode('spheres', spheres_vert_1.spheres_vert, spheres_frag_1.spheres_frag, { fragDepth: 'required', drawBuffers: 'optional' }, {}, ignoreDefine);
var cylinders_vert_1 = require("./shader/cylinders.vert");
var cylinders_frag_1 = require("./shader/cylinders.frag");
exports.CylindersShaderCode = ShaderCode('cylinders', cylinders_vert_1.cylinders_vert, cylinders_frag_1.cylinders_frag, { fragDepth: 'required', drawBuffers: 'optional' }, {}, ignoreDefine);
var text_vert_1 = require("./shader/text.vert");
var text_frag_1 = require("./shader/text.frag");
exports.TextShaderCode = ShaderCode('text', text_vert_1.text_vert, text_frag_1.text_frag, { drawBuffers: 'optional' }, {}, ignoreDefineUnlit);
var lines_vert_1 = require("./shader/lines.vert");
var lines_frag_1 = require("./shader/lines.frag");
exports.LinesShaderCode = ShaderCode('lines', lines_vert_1.lines_vert, lines_frag_1.lines_frag, { drawBuffers: 'optional' }, {}, ignoreDefineUnlit);
var mesh_vert_1 = require("./shader/mesh.vert");
var mesh_frag_1 = require("./shader/mesh.frag");
exports.MeshShaderCode = ShaderCode('mesh', mesh_vert_1.mesh_vert, mesh_frag_1.mesh_frag, { drawBuffers: 'optional' }, {}, ignoreDefine);
var direct_volume_vert_1 = require("./shader/direct-volume.vert");
var direct_volume_frag_1 = require("./shader/direct-volume.frag");
exports.DirectVolumeShaderCode = ShaderCode('direct-volume', direct_volume_vert_1.directVolume_vert, direct_volume_frag_1.directVolume_frag, { fragDepth: 'optional', drawBuffers: 'optional' }, {}, ignoreDefine);
var image_vert_1 = require("./shader/image.vert");
var image_frag_1 = require("./shader/image.frag");
var type_helpers_1 = require("../mol-util/type-helpers");
exports.ImageShaderCode = ShaderCode('image', image_vert_1.image_vert, image_frag_1.image_frag, { drawBuffers: 'optional' }, {}, ignoreDefineUnlit);
function getDefinesCode(defines, ignore) {
    var _a;
    if (defines === undefined)
        return '';
    var variant = (((_a = defines.dRenderVariant) === null || _a === void 0 ? void 0 : _a.ref.value) || '');
    var lines = [];
    for (var name_1 in defines) {
        if (ignore === null || ignore === void 0 ? void 0 : ignore(name_1, variant, defines))
            continue;
        var define = defines[name_1];
        var v = define.ref.value;
        if (v !== undefined) {
            if (typeof v === 'string') {
                lines.push("#define ".concat(name_1, "_").concat(v));
            }
            else if (typeof v === 'number') {
                lines.push("#define ".concat(name_1, " ").concat(v));
            }
            else if (typeof v === 'boolean') {
                if (v)
                    lines.push("#define ".concat(name_1));
            }
            else {
                (0, type_helpers_1.assertUnreachable)(v);
            }
        }
    }
    return lines.join('\n') + '\n';
}
function getGlsl100VertPrefix(extensions, shaderExtensions) {
    var prefix = [];
    if (shaderExtensions.drawBuffers) {
        if (extensions.drawBuffers) {
            prefix.push('#define requiredDrawBuffers');
        }
        else if (shaderExtensions.drawBuffers === 'required') {
            throw new Error("required 'GL_EXT_draw_buffers' extension not available");
        }
    }
    return prefix.join('\n') + '\n';
}
function getGlsl100FragPrefix(extensions, shaderExtensions) {
    var prefix = [
        '#extension GL_OES_standard_derivatives : enable'
    ];
    if (shaderExtensions.fragDepth) {
        if (extensions.fragDepth) {
            prefix.push('#extension GL_EXT_frag_depth : enable');
            prefix.push('#define enabledFragDepth');
        }
        else if (shaderExtensions.fragDepth === 'required') {
            throw new Error("required 'GL_EXT_frag_depth' extension not available");
        }
    }
    if (shaderExtensions.drawBuffers) {
        if (extensions.drawBuffers) {
            prefix.push('#extension GL_EXT_draw_buffers : require');
            prefix.push('#define requiredDrawBuffers');
            prefix.push('#define gl_FragColor gl_FragData[0]');
        }
        else if (shaderExtensions.drawBuffers === 'required') {
            throw new Error("required 'GL_EXT_draw_buffers' extension not available");
        }
    }
    if (shaderExtensions.shaderTextureLod) {
        if (extensions.shaderTextureLod) {
            prefix.push('#extension GL_EXT_shader_texture_lod : enable');
            prefix.push('#define enabledShaderTextureLod');
        }
        else if (shaderExtensions.shaderTextureLod === 'required') {
            throw new Error("required 'GL_EXT_shader_texture_lod' extension not available");
        }
    }
    if (extensions.depthTexture) {
        prefix.push('#define depthTextureSupport');
    }
    return prefix.join('\n') + '\n';
}
var glsl300VertPrefixCommon = "\n#define attribute in\n#define varying out\n#define texture2D texture\n";
var glsl300FragPrefixCommon = "\n#define varying in\n#define texture2D texture\n#define textureCube texture\n#define texture2DLodEXT textureLod\n#define textureCubeLodEXT textureLod\n\n#define gl_FragColor out_FragData0\n#define gl_FragDepthEXT gl_FragDepth\n\n#define depthTextureSupport\n";
function getGlsl300VertPrefix(extensions, shaderExtensions) {
    var prefix = [
        '#version 300 es',
    ];
    if (shaderExtensions.drawBuffers) {
        if (extensions.drawBuffers) {
            prefix.push('#define requiredDrawBuffers');
        }
    }
    if (extensions.noNonInstancedActiveAttribs) {
        prefix.push('#define noNonInstancedActiveAttribs');
    }
    prefix.push(glsl300VertPrefixCommon);
    return prefix.join('\n') + '\n';
}
function getGlsl300FragPrefix(gl, extensions, shaderExtensions, outTypes) {
    var prefix = [
        '#version 300 es',
        "layout(location = 0) out highp ".concat(outTypes[0] || 'vec4', " out_FragData0;")
    ];
    if (shaderExtensions.fragDepth) {
        if (extensions.fragDepth) {
            prefix.push('#define enabledFragDepth');
        }
    }
    if (shaderExtensions.drawBuffers) {
        if (extensions.drawBuffers) {
            prefix.push('#define requiredDrawBuffers');
            var maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);
            for (var i = 1, il = maxDrawBuffers; i < il; ++i) {
                prefix.push("layout(location = ".concat(i, ") out highp ").concat(outTypes[i] || 'vec4', " out_FragData").concat(i, ";"));
            }
        }
    }
    if (shaderExtensions.shaderTextureLod) {
        if (extensions.shaderTextureLod) {
            prefix.push('#define enabledShaderTextureLod');
        }
    }
    prefix.push(glsl300FragPrefixCommon);
    return prefix.join('\n') + '\n';
}
function transformGlsl300Frag(frag) {
    return frag.replace(/gl_FragData\[([0-9]+)\]/g, 'out_FragData$1');
}
function addShaderDefines(gl, extensions, defines, shaders) {
    var vertHeader = getDefinesCode(defines, shaders.ignoreDefine);
    var fragHeader = getDefinesCode(defines, shaders.ignoreDefine);
    var vertPrefix = (0, compat_1.isWebGL2)(gl)
        ? getGlsl300VertPrefix(extensions, shaders.extensions)
        : getGlsl100VertPrefix(extensions, shaders.extensions);
    var fragPrefix = (0, compat_1.isWebGL2)(gl)
        ? getGlsl300FragPrefix(gl, extensions, shaders.extensions, shaders.outTypes)
        : getGlsl100FragPrefix(extensions, shaders.extensions);
    var frag = (0, compat_1.isWebGL2)(gl) ? transformGlsl300Frag(shaders.frag) : shaders.frag;
    return {
        id: shaderCodeId(),
        name: shaders.name,
        vert: "".concat(vertPrefix).concat(vertHeader).concat(preprocess(shaders.vert, defines)),
        frag: "".concat(fragPrefix).concat(fragHeader).concat(preprocess(frag, defines)),
        extensions: shaders.extensions,
        outTypes: shaders.outTypes
    };
}
exports.addShaderDefines = addShaderDefines;
