"use strict";
/**
 * Copyright (c) 2017-2022 Mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeInterUnitBonds = void 0;
var tslib_1 = require("tslib");
var structure_1 = require("../../structure");
var unit_1 = require("../../unit");
var common_1 = require("./common");
var data_1 = require("./data");
var int_1 = require("../../../../../mol-data/int");
var linear_algebra_1 = require("../../../../../mol-math/linear-algebra");
var bonds_1 = require("../../../model/properties/atomic/bonds");
var index_pair_1 = require("../../../../../mol-model-formats/structure/property/bonds/index-pair");
var inter_unit_graph_1 = require("../../../../../mol-math/graph/inter-unit-graph");
var struct_conn_1 = require("../../../../../mol-model-formats/structure/property/bonds/struct_conn");
var common_2 = require("../../../../../mol-math/linear-algebra/3d/common");
var model_1 = require("../../../model");
// avoiding namespace lookup improved performance in Chrome (Aug 2020)
var v3distance = linear_algebra_1.Vec3.distance;
var v3set = linear_algebra_1.Vec3.set;
var v3squaredDistance = linear_algebra_1.Vec3.squaredDistance;
var v3transformMat4 = linear_algebra_1.Vec3.transformMat4;
var tmpDistVecA = (0, linear_algebra_1.Vec3)();
var tmpDistVecB = (0, linear_algebra_1.Vec3)();
function getDistance(unitA, indexA, unitB, indexB) {
    unitA.conformation.position(indexA, tmpDistVecA);
    unitB.conformation.position(indexB, tmpDistVecB);
    return v3distance(tmpDistVecA, tmpDistVecB);
}
var _imageTransform = (0, linear_algebra_1.Mat4)();
var _imageA = (0, linear_algebra_1.Vec3)();
function findPairBonds(unitA, unitB, props, builder) {
    var maxRadius = props.maxRadius;
    var atomsA = unitA.elements, residueIndexA = unitA.residueIndex;
    var _a = unitA.model.atomicConformation, xA = _a.x, yA = _a.y, zA = _a.z;
    var atomsB = unitB.elements, residueIndexB = unitB.residueIndex;
    var atomCount = unitA.elements.length;
    var _b = unitA.model.atomicHierarchy.atoms, type_symbolA = _b.type_symbol, label_alt_idA = _b.label_alt_id, label_atom_idA = _b.label_atom_id, label_comp_idA = _b.label_comp_id;
    var _c = unitB.model.atomicHierarchy.atoms, type_symbolB = _c.type_symbol, label_alt_idB = _c.label_alt_id, label_atom_idB = _c.label_atom_id, label_comp_idB = _c.label_comp_id;
    var auth_seq_idA = unitA.model.atomicHierarchy.residues.auth_seq_id;
    var auth_seq_idB = unitB.model.atomicHierarchy.residues.auth_seq_id;
    var occupancyA = unitA.model.atomicConformation.occupancy;
    var occupancyB = unitB.model.atomicConformation.occupancy;
    var hasOccupancy = occupancyA.isDefined && occupancyB.isDefined;
    var structConn = unitA.model === unitB.model && struct_conn_1.StructConn.Provider.get(unitA.model);
    var indexPairs = !props.forceCompute && unitA.model === unitB.model && index_pair_1.IndexPairBonds.Provider.get(unitA.model);
    var sourceIndex = unitA.model.atomicHierarchy.atomSourceIndex;
    var invertedIndex = (indexPairs ? model_1.Model.getInvertedAtomSourceIndex(unitB.model) : { invertedIndex: void 0 }).invertedIndex;
    var structConnExhaustive = unitA.model === unitB.model && struct_conn_1.StructConn.isExhaustive(unitA.model);
    // the lookup queries need to happen in the "unitB space".
    // that means _imageA = inverseOperB(operA(aI))
    var imageTransform = linear_algebra_1.Mat4.mul(_imageTransform, unitB.conformation.operator.inverse, unitA.conformation.operator.matrix);
    var isNotIdentity = !linear_algebra_1.Mat4.isIdentity(imageTransform);
    var _d = unitB.boundary.sphere, bCenter = _d.center, bRadius = _d.radius;
    var testDistanceSq = (bRadius + maxRadius) * (bRadius + maxRadius);
    builder.startUnitPair(unitA.id, unitB.id);
    var opKeyA = unitA.conformation.operator.key;
    var opKeyB = unitB.conformation.operator.key;
    for (var _aI = 0; _aI < atomCount; _aI++) {
        var aI = atomsA[_aI];
        v3set(_imageA, xA[aI], yA[aI], zA[aI]);
        if (isNotIdentity)
            v3transformMat4(_imageA, _imageA, imageTransform);
        if (v3squaredDistance(_imageA, bCenter) > testDistanceSq)
            continue;
        if (!props.forceCompute && indexPairs) {
            var maxDistance = indexPairs.maxDistance;
            var _e = indexPairs.bonds, offset = _e.offset, b = _e.b, _f = _e.edgeProps, order = _f.order, distance = _f.distance, flag = _f.flag, key = _f.key, operatorA = _f.operatorA, operatorB = _f.operatorB;
            var srcA = sourceIndex.value(aI);
            var aeI_1 = (0, common_1.getElementIdx)(type_symbolA.value(aI));
            for (var i = offset[srcA], il = offset[srcA + 1]; i < il; ++i) {
                var bI = invertedIndex[b[i]];
                var _bI = int_1.SortedArray.indexOf(unitB.elements, bI);
                if (_bI < 0)
                    continue;
                var opA = operatorA[i];
                var opB = operatorB[i];
                if ((opA >= 0 && opA !== opKeyA && opA !== opKeyB) ||
                    (opB >= 0 && opB !== opKeyB && opB !== opKeyA))
                    continue;
                var beI = (0, common_1.getElementIdx)(type_symbolA.value(bI));
                var d = distance[i];
                var dist = getDistance(unitA, aI, unitB, bI);
                var add = false;
                if (d >= 0) {
                    add = (0, common_2.equalEps)(dist, d, 0.3);
                }
                else if (maxDistance >= 0) {
                    add = dist < maxDistance;
                }
                else {
                    var pairingThreshold = (0, common_1.getPairingThreshold)(aeI_1, beI, (0, common_1.getElementThreshold)(aeI_1), (0, common_1.getElementThreshold)(beI));
                    add = dist < pairingThreshold;
                    if ((0, common_1.isHydrogen)(aeI_1) && (0, common_1.isHydrogen)(beI)) {
                        // TODO handle molecular hydrogen
                        add = false;
                    }
                }
                if (add) {
                    builder.add(_aI, _bI, { order: order[i], flag: flag[i], key: key[i] });
                }
            }
            continue; // assume `indexPairs` supplies all bonds
        }
        var structConnEntries = props.forceCompute ? void 0 : structConn && structConn.byAtomIndex.get(aI);
        if (structConnEntries && structConnEntries.length) {
            var added = false;
            for (var _g = 0, structConnEntries_1 = structConnEntries; _g < structConnEntries_1.length; _g++) {
                var se = structConnEntries_1[_g];
                var partnerA = se.partnerA, partnerB = se.partnerB;
                var p = partnerA.atomIndex === aI ? partnerB : partnerA;
                var _bI = int_1.SortedArray.indexOf(unitB.elements, p.atomIndex);
                if (_bI < 0)
                    continue;
                // check if the bond is within MAX_RADIUS for this pair of units
                if (getDistance(unitA, aI, unitB, p.atomIndex) > maxRadius)
                    continue;
                builder.add(_aI, _bI, { order: se.order, flag: se.flags, key: se.rowIndex });
                added = true;
            }
            // assume, for an atom, that if any inter unit bond is given
            // all are given and thus we don't need to compute any other
            if (added)
                continue;
        }
        if (structConnExhaustive)
            continue;
        var occA = occupancyA.value(aI);
        var lookup3d = unitB.lookup3d;
        var _h = lookup3d.find(_imageA[0], _imageA[1], _imageA[2], maxRadius), indices = _h.indices, count = _h.count, squaredDistances = _h.squaredDistances;
        if (count === 0)
            continue;
        var aeI = (0, common_1.getElementIdx)(type_symbolA.value(aI));
        var isHa = (0, common_1.isHydrogen)(aeI);
        var thresholdA = (0, common_1.getElementThreshold)(aeI);
        var altA = label_alt_idA.value(aI);
        var metalA = common_1.MetalsSet.has(aeI);
        var atomIdA = label_atom_idA.value(aI);
        var compIdA = label_comp_idA.value(residueIndexA[aI]);
        for (var ni = 0; ni < count; ni++) {
            var _bI = indices[ni];
            var bI = atomsB[_bI];
            var altB = label_alt_idB.value(bI);
            if (altA && altB && altA !== altB)
                continue;
            // Do not include bonds between images of the same residue with partial occupancy.
            // TODO: is this condition good enough?
            // - It works for cases like 3WQJ (label_asym_id: I) which have partial occupancy.
            // - Does NOT work for cases like 1RB8 (DC 7) with full occupancy.
            if (hasOccupancy && occupancyB.value(bI) < 1 && occA < 1) {
                if (auth_seq_idA.value(aI) === auth_seq_idB.value(bI)) {
                    continue;
                }
            }
            var beI = (0, common_1.getElementIdx)(type_symbolB.value(bI));
            var isHb = (0, common_1.isHydrogen)(beI);
            if (isHa && isHb)
                continue;
            var isMetal = (metalA || common_1.MetalsSet.has(beI)) && !(isHa || isHb);
            var dist = Math.sqrt(squaredDistances[ni]);
            if (dist === 0)
                continue;
            var pairingThreshold = (0, common_1.getPairingThreshold)(aeI, beI, thresholdA, (0, common_1.getElementThreshold)(beI));
            if (dist <= pairingThreshold) {
                var atomIdB = label_atom_idB.value(bI);
                var compIdB = label_comp_idB.value(residueIndexB[bI]);
                builder.add(_aI, _bI, {
                    order: (0, bonds_1.getInterBondOrderFromTable)(compIdA, compIdB, atomIdA, atomIdB),
                    flag: (isMetal ? 2 /* BondType.Flag.MetallicCoordination */ : 1 /* BondType.Flag.Covalent */) | 32 /* BondType.Flag.Computed */,
                    key: -1
                });
            }
        }
    }
    builder.finishUnitPair();
}
var DefaultInterBondComputationProps = tslib_1.__assign(tslib_1.__assign({}, common_1.DefaultBondComputationProps), { ignoreWater: true, ignoreIon: true });
function findBonds(structure, props) {
    var builder = new inter_unit_graph_1.InterUnitGraph.Builder();
    var hasIndexPairBonds = structure.models.some(function (m) { return index_pair_1.IndexPairBonds.Provider.get(m); });
    var hasExhaustiveStructConn = structure.models.some(function (m) { return struct_conn_1.StructConn.isExhaustive(m); });
    if (props.noCompute || (structure.isCoarseGrained && !hasIndexPairBonds && !hasExhaustiveStructConn)) {
        return new data_1.InterUnitBonds(builder.getMap());
    }
    structure_1.Structure.eachUnitPair(structure, function (unitA, unitB) {
        findPairBonds(unitA, unitB, props, builder);
    }, {
        maxRadius: props.maxRadius,
        validUnit: function (unit) { return props.validUnit(unit); },
        validUnitPair: function (unitA, unitB) { return props.validUnitPair(structure, unitA, unitB); }
    });
    return new data_1.InterUnitBonds(builder.getMap());
}
function computeInterUnitBonds(structure, props) {
    var p = tslib_1.__assign(tslib_1.__assign({}, DefaultInterBondComputationProps), props);
    return findBonds(structure, tslib_1.__assign(tslib_1.__assign({}, p), { validUnit: (props && props.validUnit) || (function (u) { return unit_1.Unit.isAtomic(u); }), validUnitPair: (props && props.validUnitPair) || (function (s, a, b) {
            var mtA = a.model.atomicHierarchy.derived.residue.moleculeType;
            var mtB = b.model.atomicHierarchy.derived.residue.moleculeType;
            var notWater = ((!unit_1.Unit.isAtomic(a) || mtA[a.residueIndex[a.elements[0]]] !== 2 /* MoleculeType.Water */) &&
                (!unit_1.Unit.isAtomic(b) || mtB[b.residueIndex[b.elements[0]]] !== 2 /* MoleculeType.Water */));
            var sameModel = a.model === b.model;
            var notIonA = (!unit_1.Unit.isAtomic(a) || mtA[a.residueIndex[a.elements[0]]] !== 3 /* MoleculeType.Ion */) || (sameModel && hasStructConnRecord(a));
            var notIonB = (!unit_1.Unit.isAtomic(b) || mtB[b.residueIndex[b.elements[0]]] !== 3 /* MoleculeType.Ion */) || (sameModel && hasStructConnRecord(b));
            var notIon = notIonA && notIonB;
            return structure_1.Structure.validUnitPair(s, a, b) && (notWater || !p.ignoreWater) && (notIon || !p.ignoreIon);
        }) }));
}
exports.computeInterUnitBonds = computeInterUnitBonds;
function hasStructConnRecord(unit) {
    if (!unit_1.Unit.isAtomic(unit))
        return false;
    var elements = unit.elements;
    var structConn = struct_conn_1.StructConn.Provider.get(unit.model);
    if (structConn) {
        for (var i = 0, _i = elements.length; i < _i; i++) {
            if (structConn.byAtomIndex.get(elements[i])) {
                return true;
            }
        }
    }
    return false;
}
