"use strict";
/**
 * Copyright (c) 2017-2018 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.copy_source_mmCifCategory = exports.copy_mmCif_category = exports.getUniqueEntityIndicesFromStructures = exports.getUniqueEntityIdsFromStructures = exports.getUniqueResidueNamesFromStructures = exports.getModelMmCifCategory = void 0;
var set_1 = require("../../../../mol-util/set");
var generic_1 = require("../../../../mol-data/generic");
var util_1 = require("../../../../mol-data/util");
var cif_1 = require("../../../../mol-io/writer/cif");
var mmcif_1 = require("../../../../mol-model-formats/structure/mmcif");
var cif_2 = require("../../../../mol-io/reader/cif");
function getModelMmCifCategory(model, name) {
    if (!mmcif_1.MmcifFormat.is(model.sourceData))
        return;
    return model.sourceData.data.db[name];
}
exports.getModelMmCifCategory = getModelMmCifCategory;
function getUniqueResidueNamesFromStructures(structures) {
    return set_1.SetUtils.unionMany.apply(set_1.SetUtils, structures.map(function (s) { return s.uniqueResidueNames; }));
}
exports.getUniqueResidueNamesFromStructures = getUniqueResidueNamesFromStructures;
function getUniqueEntityIdsFromStructures(structures) {
    if (structures.length === 0)
        return new Set();
    var names = structures[0].model.entities.data.id;
    return new Set(getUniqueEntityIndicesFromStructures(structures).map(function (i) { return names.value(i); }));
}
exports.getUniqueEntityIdsFromStructures = getUniqueEntityIdsFromStructures;
function getUniqueEntityIndicesFromStructures(structures) {
    if (structures.length === 0)
        return [];
    if (structures.length === 1)
        return structures[0].entityIndices;
    var ret = generic_1.UniqueArray.create();
    for (var _i = 0, structures_1 = structures; _i < structures_1.length; _i++) {
        var s = structures_1[_i];
        for (var _a = 0, _b = s.entityIndices; _a < _b.length; _a++) {
            var e = _b[_a];
            generic_1.UniqueArray.add(ret, e, e);
        }
    }
    (0, util_1.sortArray)(ret.array);
    return ret.array;
}
exports.getUniqueEntityIndicesFromStructures = getUniqueEntityIndicesFromStructures;
function copy_mmCif_category(name, condition) {
    return {
        name: name,
        instance: function (_a) {
            var structures = _a.structures;
            if (condition && !condition(structures[0]))
                return cif_1.CifWriter.Category.Empty;
            var model = structures[0].model;
            if (!mmcif_1.MmcifFormat.is(model.sourceData))
                return cif_1.CifWriter.Category.Empty;
            var table = model.sourceData.data.db[name];
            if (!table || !table._rowCount)
                return cif_1.CifWriter.Category.Empty;
            return cif_1.CifWriter.Category.ofTable(table);
        }
    };
}
exports.copy_mmCif_category = copy_mmCif_category;
function copy_source_mmCifCategory(encoder, ctx, category) {
    if (!mmcif_1.MmcifFormat.is(ctx.firstModel.sourceData))
        return;
    var fs = cif_1.CifWriter.fields();
    if (encoder.isBinary) {
        for (var _i = 0, _a = category.fieldNames; _i < _a.length; _i++) {
            var f = _a[_i];
            // TODO: this could be optimized
            var field = classifyField(f, category.getField(f));
            fs.add(field);
        }
    }
    else {
        var _loop_1 = function (f) {
            var field = category.getField(f);
            fs.str(f, function (row) { return field.str(row); });
        };
        for (var _b = 0, _c = category.fieldNames; _b < _c.length; _b++) {
            var f = _c[_b];
            _loop_1(f);
        }
    }
    var fields = fs.getFields();
    return {
        name: category.name,
        instance: function () {
            return { fields: fields, source: [{ data: void 0, rowCount: category.rowCount }] };
        }
    };
}
exports.copy_source_mmCifCategory = copy_source_mmCifCategory;
function classifyField(name, field) {
    var type = (0, cif_2.getCifFieldType)(field);
    if (type['@type'] === 'str') {
        return { name: name, type: 0 /* CifWriter.Field.Type.Str */, value: field.str, valueKind: field.valueKind };
    }
    else if (type['@type'] === 'float') {
        return cif_1.CifWriter.Field.float(name, field.float, { valueKind: field.valueKind, typedArray: Float64Array });
    }
    else {
        return cif_1.CifWriter.Field.int(name, field.int, { valueKind: field.valueKind, typedArray: Int32Array });
    }
}
