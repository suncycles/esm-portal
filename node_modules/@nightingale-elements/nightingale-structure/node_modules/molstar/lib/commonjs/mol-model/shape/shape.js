"use strict";
/**
 * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShapeGroup = exports.Shape = void 0;
var mol_util_1 = require("../../mol-util");
var int_1 = require("../../mol-data/int");
var geometry_1 = require("../../mol-geo/geometry/geometry");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var geometry_2 = require("../../mol-math/geometry");
var centroid_helper_1 = require("../../mol-math/geometry/centroid-helper");
var shape_group_1 = require("../../mol-theme/size/shape-group");
var shape_group_2 = require("../../mol-theme/color/shape-group");
var transform_data_1 = require("../../mol-geo/geometry/transform-data");
var render_object_1 = require("../../mol-gl/render-object");
var location_iterator_1 = require("../../mol-geo/util/location-iterator");
var Shape;
(function (Shape) {
    function create(name, sourceData, geometry, getColor, getSize, getLabel, transforms) {
        return {
            id: mol_util_1.UUID.create22(),
            name: name,
            sourceData: sourceData,
            geometry: geometry,
            transforms: transforms || [linear_algebra_1.Mat4.identity()],
            get groupCount() { return geometry_1.Geometry.getGroupCount(geometry); },
            getColor: getColor,
            getSize: getSize,
            getLabel: getLabel
        };
    }
    Shape.create = create;
    function getTheme(shape) {
        return {
            color: (0, shape_group_2.ShapeGroupColorTheme)({ shape: shape }, {}),
            size: (0, shape_group_1.ShapeGroupSizeTheme)({ shape: shape }, {})
        };
    }
    Shape.getTheme = getTheme;
    function groupIterator(shape) {
        var instanceCount = shape.transforms.length;
        var location = ShapeGroup.Location(shape);
        var getLocation = function (groupIndex, instanceIndex) {
            location.group = groupIndex;
            location.instance = instanceIndex;
            return location;
        };
        return (0, location_iterator_1.LocationIterator)(shape.groupCount, instanceCount, 1, getLocation);
    }
    Shape.groupIterator = groupIterator;
    function createTransform(transforms, transformData) {
        var transformArray = transformData && transformData.aTransform.ref.value.length >= transforms.length * 16 ? transformData.aTransform.ref.value : new Float32Array(transforms.length * 16);
        for (var i = 0, il = transforms.length; i < il; ++i) {
            linear_algebra_1.Mat4.toArray(transforms[i], transformArray, i * 16);
        }
        return (0, transform_data_1.createTransform)(transformArray, transforms.length, transformData);
    }
    Shape.createTransform = createTransform;
    function createRenderObject(shape, props) {
        props;
        var theme = Shape.getTheme(shape);
        var utils = geometry_1.Geometry.getUtils(shape.geometry);
        var materialId = (0, render_object_1.getNextMaterialId)();
        var locationIt = groupIterator(shape);
        var transform = Shape.createTransform(shape.transforms);
        var values = utils.createValues(shape.geometry, transform, locationIt, theme, props);
        var state = utils.createRenderableState(props);
        return (0, render_object_1.createRenderObject)(shape.geometry.kind, values, state, materialId);
    }
    Shape.createRenderObject = createRenderObject;
    function Loci(shape) { return { kind: 'shape-loci', shape: shape }; }
    Shape.Loci = Loci;
    function isLoci(x) { return !!x && x.kind === 'shape-loci'; }
    Shape.isLoci = isLoci;
    function areLociEqual(a, b) { return a.shape === b.shape; }
    Shape.areLociEqual = areLociEqual;
    function isLociEmpty(loci) { return loci.shape.groupCount === 0; }
    Shape.isLociEmpty = isLociEmpty;
})(Shape = exports.Shape || (exports.Shape = {}));
var ShapeGroup;
(function (ShapeGroup) {
    function Location(shape, group, instance) {
        if (group === void 0) { group = 0; }
        if (instance === void 0) { instance = 0; }
        return { kind: 'group-location', shape: shape, group: group, instance: instance };
    }
    ShapeGroup.Location = Location;
    function isLocation(x) {
        return !!x && x.kind === 'group-location';
    }
    ShapeGroup.isLocation = isLocation;
    function Loci(shape, groups) {
        return { kind: 'group-loci', shape: shape, groups: groups };
    }
    ShapeGroup.Loci = Loci;
    function isLoci(x) {
        return !!x && x.kind === 'group-loci';
    }
    ShapeGroup.isLoci = isLoci;
    function areLociEqual(a, b) {
        if (a.shape !== b.shape)
            return false;
        if (a.groups.length !== b.groups.length)
            return false;
        for (var i = 0, il = a.groups.length; i < il; ++i) {
            var _a = a.groups[i], idsA = _a.ids, instanceA = _a.instance;
            var _b = b.groups[i], idsB = _b.ids, instanceB = _b.instance;
            if (instanceA !== instanceB)
                return false;
            if (!int_1.OrderedSet.areEqual(idsA, idsB))
                return false;
        }
        return true;
    }
    ShapeGroup.areLociEqual = areLociEqual;
    function isLociEmpty(loci) {
        return size(loci) === 0 ? true : false;
    }
    ShapeGroup.isLociEmpty = isLociEmpty;
    function size(loci) {
        var size = 0;
        for (var _i = 0, _a = loci.groups; _i < _a.length; _i++) {
            var group = _a[_i];
            size += int_1.OrderedSet.size(group.ids);
        }
        return size;
    }
    ShapeGroup.size = size;
    var sphereHelper = new centroid_helper_1.CentroidHelper(), tmpPos = linear_algebra_1.Vec3.zero();
    function sphereHelperInclude(groups, mapping, positions, transforms) {
        var indices = mapping.indices, offsets = mapping.offsets;
        var _loop_1 = function (ids, instance) {
            int_1.OrderedSet.forEach(ids, function (v) {
                for (var i = offsets[v], il = offsets[v + 1]; i < il; ++i) {
                    linear_algebra_1.Vec3.fromArray(tmpPos, positions, indices[i] * 3);
                    linear_algebra_1.Vec3.transformMat4(tmpPos, tmpPos, transforms[instance]);
                    sphereHelper.includeStep(tmpPos);
                }
            });
        };
        for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
            var _a = groups_1[_i], ids = _a.ids, instance = _a.instance;
            _loop_1(ids, instance);
        }
    }
    function sphereHelperRadius(groups, mapping, positions, transforms) {
        var indices = mapping.indices, offsets = mapping.offsets;
        var _loop_2 = function (ids, instance) {
            int_1.OrderedSet.forEach(ids, function (v) {
                for (var i = offsets[v], il = offsets[v + 1]; i < il; ++i) {
                    linear_algebra_1.Vec3.fromArray(tmpPos, positions, indices[i] * 3);
                    linear_algebra_1.Vec3.transformMat4(tmpPos, tmpPos, transforms[instance]);
                    sphereHelper.radiusStep(tmpPos);
                }
            });
        };
        for (var _i = 0, groups_2 = groups; _i < groups_2.length; _i++) {
            var _a = groups_2[_i], ids = _a.ids, instance = _a.instance;
            _loop_2(ids, instance);
        }
    }
    function getBoundingSphere(loci, boundingSphere) {
        if (!boundingSphere)
            boundingSphere = (0, geometry_2.Sphere3D)();
        sphereHelper.reset();
        var padding = 0;
        var _a = loci.shape, geometry = _a.geometry, transforms = _a.transforms;
        if (geometry.kind === 'mesh' || geometry.kind === 'points') {
            var positions = geometry.kind === 'mesh'
                ? geometry.vertexBuffer.ref.value
                : geometry.centerBuffer.ref.value;
            sphereHelperInclude(loci.groups, geometry.groupMapping, positions, transforms);
            sphereHelper.finishedIncludeStep();
            sphereHelperRadius(loci.groups, geometry.groupMapping, positions, transforms);
        }
        else if (geometry.kind === 'lines') {
            var start = geometry.startBuffer.ref.value;
            var end = geometry.endBuffer.ref.value;
            sphereHelperInclude(loci.groups, geometry.groupMapping, start, transforms);
            sphereHelperInclude(loci.groups, geometry.groupMapping, end, transforms);
            sphereHelper.finishedIncludeStep();
            sphereHelperRadius(loci.groups, geometry.groupMapping, start, transforms);
            sphereHelperRadius(loci.groups, geometry.groupMapping, end, transforms);
        }
        else if (geometry.kind === 'spheres' || geometry.kind === 'text') {
            var positions = geometry.centerBuffer.ref.value;
            sphereHelperInclude(loci.groups, geometry.groupMapping, positions, transforms);
            sphereHelper.finishedIncludeStep();
            sphereHelperRadius(loci.groups, geometry.groupMapping, positions, transforms);
            var _loop_3 = function (ids, instance) {
                int_1.OrderedSet.forEach(ids, function (v) {
                    var value = loci.shape.getSize(v, instance);
                    if (padding < value)
                        padding = value;
                });
            };
            for (var _i = 0, _b = loci.groups; _i < _b.length; _i++) {
                var _c = _b[_i], ids = _c.ids, instance = _c.instance;
                _loop_3(ids, instance);
            }
        }
        else {
            // use whole shape bounding-sphere for other geometry kinds
            return geometry_2.Sphere3D.copy(boundingSphere, geometry.boundingSphere);
        }
        linear_algebra_1.Vec3.copy(boundingSphere.center, sphereHelper.center);
        boundingSphere.radius = Math.sqrt(sphereHelper.radiusSq);
        geometry_2.Sphere3D.expand(boundingSphere, boundingSphere, padding);
        return boundingSphere;
    }
    ShapeGroup.getBoundingSphere = getBoundingSphere;
})(ShapeGroup = exports.ShapeGroup || (exports.ShapeGroup = {}));
