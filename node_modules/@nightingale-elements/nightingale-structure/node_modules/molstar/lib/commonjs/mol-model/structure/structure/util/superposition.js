"use strict";
/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPositionTable = exports.alignAndSuperpose = exports.superpose = void 0;
var tslib_1 = require("tslib");
var minimize_rmsd_1 = require("../../../../mol-math/linear-algebra/3d/minimize-rmsd");
var element_1 = require("../element");
var int_1 = require("../../../../mol-data/int");
var sequence_1 = require("../../../sequence/alignment/sequence");
var properties_1 = require("../properties");
function superpose(xs) {
    var ret = [];
    if (xs.length <= 0)
        return ret;
    var n = getMinSize(xs);
    var input = {
        a: getPositionTable(xs[0], n),
        b: getPositionTable(xs[1], n)
    };
    ret[0] = minimize_rmsd_1.MinimizeRmsd.compute(input);
    for (var i = 2; i < xs.length; i++) {
        input.b = getPositionTable(xs[i], n);
        input.centerB = void 0;
        ret.push(minimize_rmsd_1.MinimizeRmsd.compute(input));
    }
    return ret;
}
exports.superpose = superpose;
var reProtein = /(polypeptide|cyclic-pseudo-peptide)/i;
function alignAndSuperpose(xs) {
    var ret = [];
    if (xs.length <= 0)
        return ret;
    var l = element_1.StructureElement.Loci.getFirstLocation(xs[0]);
    var subtype = properties_1.StructureProperties.entity.subtype(l);
    var substMatrix = subtype.match(reProtein) ? 'blosum62' : 'default';
    for (var i = 1; i < xs.length; i++) {
        var _a = sequence_1.AlignSequences.compute({
            a: xs[0].elements[0],
            b: xs[i].elements[0],
        }, { substMatrix: substMatrix }), a = _a.a, b = _a.b, score = _a.score;
        var lociA = element_1.StructureElement.Loci(xs[0].structure, [a]);
        var lociB = element_1.StructureElement.Loci(xs[i].structure, [b]);
        var n = int_1.OrderedSet.size(a.indices);
        ret.push(tslib_1.__assign(tslib_1.__assign({}, minimize_rmsd_1.MinimizeRmsd.compute({
            a: getPositionTable(lociA, n),
            b: getPositionTable(lociB, n)
        })), { alignmentScore: score }));
    }
    return ret;
}
exports.alignAndSuperpose = alignAndSuperpose;
function getPositionTable(xs, n) {
    var ret = minimize_rmsd_1.MinimizeRmsd.Positions.empty(n);
    var o = 0;
    for (var _a = 0, _b = xs.elements; _a < _b.length; _a++) {
        var u = _b[_a];
        var unit = u.unit, indices = u.indices;
        var elements = unit.elements;
        var _c = unit.conformation, x = _c.x, y = _c.y, z = _c.z;
        for (var i = 0, _i = int_1.OrderedSet.size(indices); i < _i; i++) {
            var e = elements[int_1.OrderedSet.getAt(indices, i)];
            ret.x[o] = x(e);
            ret.y[o] = y(e);
            ret.z[o] = z(e);
            o++;
            if (o >= n)
                break;
        }
        if (o >= n)
            break;
    }
    return ret;
}
exports.getPositionTable = getPositionTable;
function getMinSize(xs) {
    if (xs.length === 0)
        return 0;
    var s = element_1.StructureElement.Loci.size(xs[0]);
    for (var i = 1; i < xs.length; i++) {
        var t = element_1.StructureElement.Loci.size(xs[i]);
        if (t < s)
            s = t;
    }
    return s;
}
