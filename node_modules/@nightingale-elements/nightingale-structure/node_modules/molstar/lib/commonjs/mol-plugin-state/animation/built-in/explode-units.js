"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimateUnitsExplode = void 0;
var tslib_1 = require("tslib");
var commands_1 = require("../../../mol-plugin/commands");
var mol_state_1 = require("../../../mol-state");
var param_definition_1 = require("../../../mol-util/param-definition");
var objects_1 = require("../../objects");
var transforms_1 = require("../../transforms");
var model_1 = require("../model");
exports.AnimateUnitsExplode = model_1.PluginStateAnimation.create({
    name: 'built-in.animate-units-explode',
    display: { name: 'Explode Units' },
    params: function () { return ({
        durationInMs: param_definition_1.ParamDefinition.Numeric(3000, { min: 100, max: 10000, step: 100 })
    }); },
    initialState: function () { return ({ t: 0 }); },
    setup: function (_, __, plugin) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var state, reprs, update, changed, _i, reprs_1, r, explodes;
            return tslib_1.__generator(this, function (_a) {
                state = plugin.state.data;
                reprs = state.select(mol_state_1.StateSelection.Generators.ofType(objects_1.PluginStateObject.Molecule.Structure.Representation3D));
                update = state.build();
                changed = false;
                for (_i = 0, reprs_1 = reprs; _i < reprs_1.length; _i++) {
                    r = reprs_1[_i];
                    explodes = state.select(mol_state_1.StateSelection.Generators.ofTransformer(transforms_1.StateTransforms.Representation.ExplodeStructureRepresentation3D, r.transform.ref));
                    if (explodes.length > 0)
                        continue;
                    changed = true;
                    update.to(r.transform.ref)
                        .apply(transforms_1.StateTransforms.Representation.ExplodeStructureRepresentation3D, { t: 0 }, { tags: 'animate-units-explode' });
                }
                if (!changed)
                    return [2 /*return*/];
                return [2 /*return*/, update.commit({ doNotUpdateCurrent: true })];
            });
        });
    },
    teardown: function (_, __, plugin) {
        var state = plugin.state.data;
        var reprs = state.select(mol_state_1.StateSelection.Generators.ofType(objects_1.PluginStateObject.Molecule.Structure.Representation3DState)
            .withTag('animate-units-explode'));
        if (reprs.length === 0)
            return;
        var update = state.build();
        for (var _i = 0, reprs_2 = reprs; _i < reprs_2.length; _i++) {
            var r = reprs_2[_i];
            update.delete(r.transform.ref);
        }
        return update.commit();
    },
    apply: function (animState, t, ctx) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var state, anims, update, d, newTime, _i, anims_1, m;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        state = ctx.plugin.state.data;
                        anims = state.select(mol_state_1.StateSelection.Generators.ofTransformer(transforms_1.StateTransforms.Representation.ExplodeStructureRepresentation3D));
                        if (anims.length === 0) {
                            return [2 /*return*/, { kind: 'finished' }];
                        }
                        update = state.build();
                        d = (t.current - t.lastApplied) / ctx.params.durationInMs;
                        newTime = (animState.t + d) % 1;
                        for (_i = 0, anims_1 = anims; _i < anims_1.length; _i++) {
                            m = anims_1[_i];
                            update.to(m).update({ t: newTime });
                        }
                        return [4 /*yield*/, commands_1.PluginCommands.State.Update(ctx.plugin, { state: state, tree: update, options: { doNotLogTiming: true } })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, { kind: 'next', state: { t: newTime } }];
                }
            });
        });
    }
});
