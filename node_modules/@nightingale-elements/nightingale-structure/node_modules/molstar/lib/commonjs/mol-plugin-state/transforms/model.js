"use strict";
/**
 * Copyright (c) 2018-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructureComplexElementTypes = exports.ShapeFromPly = exports.CustomStructureProperties = exports.CustomModelProperties = exports.StructureComponent = exports.StructureComplexElement = exports.StructureSelectionFromBundle = exports.StructureSelectionFromScript = exports.MultiStructureSelectionFromExpression = exports.StructureSelectionFromExpression = exports.TransformStructureConformation = exports.StructureFromModel = exports.StructureFromTrajectory = exports.ModelFromTrajectory = exports.TrajectoryFromCifCore = exports.TrajectoryFromCube = exports.TrajectoryFromMOL2 = exports.TrajectoryFromSDF = exports.TrajectoryFromMOL = exports.TrajectoryFromXYZ = exports.TrajectoryFromGRO = exports.TrajectoryFromPDB = exports.TrajectoryFromMmCif = exports.TrajectoryFromBlob = exports.TrajectoryFromModelAndCoordinates = exports.TopologyFromTop = exports.TopologyFromPrmtop = exports.TopologyFromPsf = exports.CoordinatesFromNctraj = exports.CoordinatesFromTrr = exports.CoordinatesFromXtc = exports.CoordinatesFromDcd = void 0;
var tslib_1 = require("tslib");
var parser_1 = require("../../mol-io/reader/dcd/parser");
var parser_2 = require("../../mol-io/reader/gro/parser");
var parser_3 = require("../../mol-io/reader/pdb/parser");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var ply_1 = require("../../mol-model-formats/shape/ply");
var dcd_1 = require("../../mol-model-formats/structure/dcd");
var gro_1 = require("../../mol-model-formats/structure/gro");
var mmcif_1 = require("../../mol-model-formats/structure/mmcif");
var pdb_1 = require("../../mol-model-formats/structure/pdb");
var psf_1 = require("../../mol-model-formats/structure/psf");
var structure_1 = require("../../mol-model/structure");
var builder_1 = require("../../mol-script/language/builder");
var script_1 = require("../../mol-script/script");
var mol_state_1 = require("../../mol-state");
var mol_task_1 = require("../../mol-task");
var mol_util_1 = require("../../mol-util");
var param_definition_1 = require("../../mol-util/param-definition");
var root_structure_1 = require("../helpers/root-structure");
var structure_component_1 = require("../helpers/structure-component");
var structure_query_1 = require("../helpers/structure-query");
var structure_selection_query_1 = require("../helpers/structure-selection-query");
var objects_1 = require("../objects");
var parser_4 = require("../../mol-io/reader/mol/parser");
var mol_1 = require("../../mol-model-formats/structure/mol");
var cif_core_1 = require("../../mol-model-formats/structure/cif-core");
var cube_1 = require("../../mol-model-formats/structure/cube");
var parser_5 = require("../../mol-io/reader/mol2/parser");
var mol2_1 = require("../../mol-model-formats/structure/mol2");
var parser_6 = require("../../mol-io/reader/xtc/parser");
var xtc_1 = require("../../mol-model-formats/structure/xtc");
var parser_7 = require("../../mol-io/reader/xyz/parser");
var xyz_1 = require("../../mol-model-formats/structure/xyz");
var parser_8 = require("../../mol-io/reader/sdf/parser");
var sdf_1 = require("../../mol-model-formats/structure/sdf");
var type_helpers_1 = require("../../mol-util/type-helpers");
var parser_9 = require("../../mol-io/reader/trr/parser");
var trr_1 = require("../../mol-model-formats/structure/trr");
var parser_10 = require("../../mol-io/reader/nctraj/parser");
var nctraj_1 = require("../../mol-model-formats/structure/nctraj");
var prmtop_1 = require("../../mol-model-formats/structure/prmtop");
var top_1 = require("../../mol-model-formats/structure/top");
var CoordinatesFromDcd = objects_1.PluginStateTransform.BuiltIn({
    name: 'coordinates-from-dcd',
    display: { name: 'Parse DCD', description: 'Parse DCD binary data.' },
    from: [objects_1.PluginStateObject.Data.Binary],
    to: objects_1.PluginStateObject.Molecule.Coordinates
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse DCD', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var parsed, coordinates;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_1.parseDcd)(a.data).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, dcd_1.coordinatesFromDcd)(parsed.result).runInContext(ctx)];
                    case 2:
                        coordinates = _a.sent();
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Coordinates(coordinates, { label: a.label, description: 'Coordinates' })];
                }
            });
        }); });
    }
});
exports.CoordinatesFromDcd = CoordinatesFromDcd;
var CoordinatesFromXtc = objects_1.PluginStateTransform.BuiltIn({
    name: 'coordinates-from-xtc',
    display: { name: 'Parse XTC', description: 'Parse XTC binary data.' },
    from: [objects_1.PluginStateObject.Data.Binary],
    to: objects_1.PluginStateObject.Molecule.Coordinates
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse XTC', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var parsed, coordinates;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_6.parseXtc)(a.data).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, xtc_1.coordinatesFromXtc)(parsed.result).runInContext(ctx)];
                    case 2:
                        coordinates = _a.sent();
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Coordinates(coordinates, { label: a.label, description: 'Coordinates' })];
                }
            });
        }); });
    }
});
exports.CoordinatesFromXtc = CoordinatesFromXtc;
var CoordinatesFromTrr = objects_1.PluginStateTransform.BuiltIn({
    name: 'coordinates-from-trr',
    display: { name: 'Parse TRR', description: 'Parse TRR binary data.' },
    from: [objects_1.PluginStateObject.Data.Binary],
    to: objects_1.PluginStateObject.Molecule.Coordinates
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse TRR', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var parsed, coordinates;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_9.parseTrr)(a.data).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, trr_1.coordinatesFromTrr)(parsed.result).runInContext(ctx)];
                    case 2:
                        coordinates = _a.sent();
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Coordinates(coordinates, { label: a.label, description: 'Coordinates' })];
                }
            });
        }); });
    }
});
exports.CoordinatesFromTrr = CoordinatesFromTrr;
var CoordinatesFromNctraj = objects_1.PluginStateTransform.BuiltIn({
    name: 'coordinates-from-nctraj',
    display: { name: 'Parse NCTRAJ', description: 'Parse NCTRAJ binary data.' },
    from: [objects_1.PluginStateObject.Data.Binary],
    to: objects_1.PluginStateObject.Molecule.Coordinates
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse NCTRAJ', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var parsed, coordinates;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_10.parseNctraj)(a.data).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, nctraj_1.coordinatesFromNctraj)(parsed.result).runInContext(ctx)];
                    case 2:
                        coordinates = _a.sent();
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Coordinates(coordinates, { label: a.label, description: 'Coordinates' })];
                }
            });
        }); });
    }
});
exports.CoordinatesFromNctraj = CoordinatesFromNctraj;
var TopologyFromPsf = objects_1.PluginStateTransform.BuiltIn({
    name: 'topology-from-psf',
    display: { name: 'PSF Topology', description: 'Create topology from PSF.' },
    from: [objects_1.PluginStateObject.Format.Psf],
    to: objects_1.PluginStateObject.Molecule.Topology
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Create Topology', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var topology;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, psf_1.topologyFromPsf)(a.data).runInContext(ctx)];
                    case 1:
                        topology = _a.sent();
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Topology(topology, { label: topology.label || a.label, description: 'Topology' })];
                }
            });
        }); });
    }
});
exports.TopologyFromPsf = TopologyFromPsf;
var TopologyFromPrmtop = objects_1.PluginStateTransform.BuiltIn({
    name: 'topology-from-prmtop',
    display: { name: 'PRMTOP Topology', description: 'Create topology from PRMTOP.' },
    from: [objects_1.PluginStateObject.Format.Prmtop],
    to: objects_1.PluginStateObject.Molecule.Topology
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Create Topology', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var topology;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, prmtop_1.topologyFromPrmtop)(a.data).runInContext(ctx)];
                    case 1:
                        topology = _a.sent();
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Topology(topology, { label: topology.label || a.label, description: 'Topology' })];
                }
            });
        }); });
    }
});
exports.TopologyFromPrmtop = TopologyFromPrmtop;
var TopologyFromTop = objects_1.PluginStateTransform.BuiltIn({
    name: 'topology-from-top',
    display: { name: 'TOP Topology', description: 'Create topology from TOP.' },
    from: [objects_1.PluginStateObject.Format.Top],
    to: objects_1.PluginStateObject.Molecule.Topology
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Create Topology', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var topology;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, top_1.topologyFromTop)(a.data).runInContext(ctx)];
                    case 1:
                        topology = _a.sent();
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Topology(topology, { label: topology.label || a.label, description: 'Topology' })];
                }
            });
        }); });
    }
});
exports.TopologyFromTop = TopologyFromTop;
function getTrajectory(ctx, obj, coordinates) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var topology, model;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(obj.type === objects_1.PluginStateObject.Molecule.Topology.type)) return [3 /*break*/, 2];
                    topology = obj.data;
                    return [4 /*yield*/, structure_1.Model.trajectoryFromTopologyAndCoordinates(topology, coordinates).runInContext(ctx)];
                case 1: return [2 /*return*/, _a.sent()];
                case 2:
                    if (obj.type === objects_1.PluginStateObject.Molecule.Model.type) {
                        model = obj.data;
                        return [2 /*return*/, structure_1.Model.trajectoryFromModelAndCoordinates(model, coordinates)];
                    }
                    _a.label = 3;
                case 3: throw new Error('no model/topology found');
            }
        });
    });
}
var TrajectoryFromModelAndCoordinates = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-model-and-coordinates',
    display: { name: 'Trajectory from Topology & Coordinates', description: 'Create a trajectory from existing model/topology and coordinates.' },
    from: objects_1.PluginStateObject.Root,
    to: objects_1.PluginStateObject.Molecule.Trajectory,
    params: {
        modelRef: param_definition_1.ParamDefinition.Text('', { isHidden: true }),
        coordinatesRef: param_definition_1.ParamDefinition.Text('', { isHidden: true }),
    }
})({
    apply: function (_a) {
        var _this = this;
        var params = _a.params, dependencies = _a.dependencies;
        return mol_task_1.Task.create('Create trajectory from model/topology and coordinates', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var coordinates, trajectory, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        coordinates = dependencies[params.coordinatesRef].data;
                        return [4 /*yield*/, getTrajectory(ctx, dependencies[params.modelRef], coordinates)];
                    case 1:
                        trajectory = _a.sent();
                        props = { label: 'Trajectory', description: "".concat(trajectory.frameCount, " model").concat(trajectory.frameCount === 1 ? '' : 's') };
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(trajectory, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromModelAndCoordinates = TrajectoryFromModelAndCoordinates;
var TrajectoryFromBlob = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-blob',
    display: { name: 'Parse Blob', description: 'Parse format blob into a single trajectory.' },
    from: objects_1.PluginStateObject.Format.Blob,
    to: objects_1.PluginStateObject.Molecule.Trajectory
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse Format Blob', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var models, _i, _a, e, block, xs, i, x, i, props;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        models = [];
                        _i = 0, _a = a.data;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 7];
                        e = _a[_i];
                        if (e.kind !== 'cif')
                            return [3 /*break*/, 6];
                        block = e.data.blocks[0];
                        return [4 /*yield*/, (0, mmcif_1.trajectoryFromMmCIF)(block).runInContext(ctx)];
                    case 2:
                        xs = _b.sent();
                        if (xs.frameCount === 0)
                            throw new Error('No models found.');
                        i = 0;
                        _b.label = 3;
                    case 3:
                        if (!(i < xs.frameCount)) return [3 /*break*/, 6];
                        return [4 /*yield*/, mol_task_1.Task.resolveInContext(xs.getFrameAtIndex(i), ctx)];
                    case 4:
                        x = _b.sent();
                        models.push(x);
                        _b.label = 5;
                    case 5:
                        i++;
                        return [3 /*break*/, 3];
                    case 6:
                        _i++;
                        return [3 /*break*/, 1];
                    case 7:
                        for (i = 0; i < models.length; i++) {
                            structure_1.Model.TrajectoryInfo.set(models[i], { index: i, size: models.length });
                        }
                        props = { label: 'Trajectory', description: "".concat(models.length, " model").concat(models.length === 1 ? '' : 's') };
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(new structure_1.ArrayTrajectory(models), props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromBlob = TrajectoryFromBlob;
function trajectoryProps(trajectory) {
    var first = trajectory.representative;
    return { label: "".concat(first.entry), description: "".concat(trajectory.frameCount, " model").concat(trajectory.frameCount === 1 ? '' : 's') };
}
var TrajectoryFromMmCif = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-mmcif',
    display: { name: 'Trajectory from mmCIF', description: 'Identify and create all separate models in the specified CIF data block' },
    from: objects_1.PluginStateObject.Format.Cif,
    to: objects_1.PluginStateObject.Molecule.Trajectory,
    params: function (a) {
        if (!a) {
            return {
                loadAllBlocks: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Boolean(false, { description: 'If True, ignore Block Header parameter and parse all datablocks into a single trajectory.' })),
                blockHeader: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text(void 0, { description: 'Header of the block to parse. If none is specifed, the 1st data block in the file is used.', hideIf: function (p) { return p.loadAllBlocks === true; } })),
            };
        }
        var blocks = a.data.blocks;
        return {
            loadAllBlocks: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Boolean(false, { description: 'If True, ignore Block Header parameter and parse all data blocks into a single trajectory.' })),
            blockHeader: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Select(blocks[0] && blocks[0].header, blocks.map(function (b) { return [b.header, b.header]; }), { description: 'Header of the block to parse', hideIf: function (p) { return p.loadAllBlocks === true; } })),
        };
    }
})({
    isApplicable: function (a) { return a.data.blocks.length > 0; },
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Parse mmCIF', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var trajectory, models, _i, _a, block, t, i, _b, _c, header_1, block, props;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!params.loadAllBlocks) return [3 /*break*/, 10];
                        models = [];
                        _i = 0, _a = a.data.blocks;
                        _d.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 9];
                        block = _a[_i];
                        if (!ctx.shouldUpdate) return [3 /*break*/, 3];
                        return [4 /*yield*/, ctx.update("Parsing ".concat(block.header, "..."))];
                    case 2:
                        _d.sent();
                        _d.label = 3;
                    case 3: return [4 /*yield*/, (0, mmcif_1.trajectoryFromMmCIF)(block).runInContext(ctx)];
                    case 4:
                        t = _d.sent();
                        i = 0;
                        _d.label = 5;
                    case 5:
                        if (!(i < t.frameCount)) return [3 /*break*/, 8];
                        _c = (_b = models).push;
                        return [4 /*yield*/, mol_task_1.Task.resolveInContext(t.getFrameAtIndex(i), ctx)];
                    case 6:
                        _c.apply(_b, [_d.sent()]);
                        _d.label = 7;
                    case 7:
                        i++;
                        return [3 /*break*/, 5];
                    case 8:
                        _i++;
                        return [3 /*break*/, 1];
                    case 9:
                        trajectory = new structure_1.ArrayTrajectory(models);
                        return [3 /*break*/, 12];
                    case 10:
                        header_1 = params.blockHeader || a.data.blocks[0].header;
                        block = a.data.blocks.find(function (b) { return b.header === header_1; });
                        if (!block)
                            throw new Error("Data block '".concat([header_1], "' not found."));
                        return [4 /*yield*/, (0, mmcif_1.trajectoryFromMmCIF)(block).runInContext(ctx)];
                    case 11:
                        trajectory = _d.sent();
                        _d.label = 12;
                    case 12:
                        if (trajectory.frameCount === 0)
                            throw new Error('No models found.');
                        props = trajectoryProps(trajectory);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(trajectory, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromMmCif = TrajectoryFromMmCif;
var TrajectoryFromPDB = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-pdb',
    display: { name: 'Parse PDB', description: 'Parse PDB string and create trajectory.' },
    from: [objects_1.PluginStateObject.Data.String],
    to: objects_1.PluginStateObject.Molecule.Trajectory,
    params: {
        isPdbqt: param_definition_1.ParamDefinition.Boolean(false)
    }
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Parse PDB', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var parsed, models, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_3.parsePDB)(a.data, a.label, params.isPdbqt).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, pdb_1.trajectoryFromPDB)(parsed.result).runInContext(ctx)];
                    case 2:
                        models = _a.sent();
                        props = trajectoryProps(models);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(models, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromPDB = TrajectoryFromPDB;
var TrajectoryFromGRO = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-gro',
    display: { name: 'Parse GRO', description: 'Parse GRO string and create trajectory.' },
    from: [objects_1.PluginStateObject.Data.String],
    to: objects_1.PluginStateObject.Molecule.Trajectory
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse GRO', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var parsed, models, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_2.parseGRO)(a.data).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, gro_1.trajectoryFromGRO)(parsed.result).runInContext(ctx)];
                    case 2:
                        models = _a.sent();
                        props = trajectoryProps(models);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(models, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromGRO = TrajectoryFromGRO;
var TrajectoryFromXYZ = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-xyz',
    display: { name: 'Parse XYZ', description: 'Parse XYZ string and create trajectory.' },
    from: [objects_1.PluginStateObject.Data.String],
    to: objects_1.PluginStateObject.Molecule.Trajectory
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse XYZ', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var parsed, models, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_7.parseXyz)(a.data).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, xyz_1.trajectoryFromXyz)(parsed.result).runInContext(ctx)];
                    case 2:
                        models = _a.sent();
                        props = trajectoryProps(models);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(models, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromXYZ = TrajectoryFromXYZ;
var TrajectoryFromMOL = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-mol',
    display: { name: 'Parse MOL', description: 'Parse MOL string and create trajectory.' },
    from: [objects_1.PluginStateObject.Data.String],
    to: objects_1.PluginStateObject.Molecule.Trajectory
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse MOL', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var parsed, models, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_4.parseMol)(a.data).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, mol_1.trajectoryFromMol)(parsed.result).runInContext(ctx)];
                    case 2:
                        models = _a.sent();
                        props = trajectoryProps(models);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(models, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromMOL = TrajectoryFromMOL;
var TrajectoryFromSDF = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-sdf',
    display: { name: 'Parse SDF', description: 'Parse SDF string and create trajectory.' },
    from: [objects_1.PluginStateObject.Data.String],
    to: objects_1.PluginStateObject.Molecule.Trajectory
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse SDF', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var parsed, models, _i, _a, compound, traj_1, i, _b, _c, traj, props;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, (0, parser_8.parseSdf)(a.data).runInContext(ctx)];
                    case 1:
                        parsed = _d.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        models = [];
                        _i = 0, _a = parsed.result.compounds;
                        _d.label = 2;
                    case 2:
                        if (!(_i < _a.length)) return [3 /*break*/, 8];
                        compound = _a[_i];
                        return [4 /*yield*/, (0, sdf_1.trajectoryFromSdf)(compound).runInContext(ctx)];
                    case 3:
                        traj_1 = _d.sent();
                        i = 0;
                        _d.label = 4;
                    case 4:
                        if (!(i < traj_1.frameCount)) return [3 /*break*/, 7];
                        _c = (_b = models).push;
                        return [4 /*yield*/, mol_task_1.Task.resolveInContext(traj_1.getFrameAtIndex(i), ctx)];
                    case 5:
                        _c.apply(_b, [_d.sent()]);
                        _d.label = 6;
                    case 6:
                        i++;
                        return [3 /*break*/, 4];
                    case 7:
                        _i++;
                        return [3 /*break*/, 2];
                    case 8:
                        traj = new structure_1.ArrayTrajectory(models);
                        props = trajectoryProps(traj);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(traj, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromSDF = TrajectoryFromSDF;
var TrajectoryFromMOL2 = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-mol2',
    display: { name: 'Parse MOL2', description: 'Parse MOL2 string and create trajectory.' },
    from: [objects_1.PluginStateObject.Data.String],
    to: objects_1.PluginStateObject.Molecule.Trajectory
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse MOL2', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var parsed, models, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_5.parseMol2)(a.data, a.label).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, mol2_1.trajectoryFromMol2)(parsed.result).runInContext(ctx)];
                    case 2:
                        models = _a.sent();
                        props = trajectoryProps(models);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(models, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromMOL2 = TrajectoryFromMOL2;
var TrajectoryFromCube = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-cube',
    display: { name: 'Parse Cube', description: 'Parse Cube file to create a trajectory.' },
    from: objects_1.PluginStateObject.Format.Cube,
    to: objects_1.PluginStateObject.Molecule.Trajectory
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse MOL', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var models, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, cube_1.trajectoryFromCube)(a.data).runInContext(ctx)];
                    case 1:
                        models = _a.sent();
                        props = trajectoryProps(models);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(models, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromCube = TrajectoryFromCube;
var TrajectoryFromCifCore = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-cif-core',
    display: { name: 'Parse CIF Core', description: 'Identify and create all separate models in the specified CIF data block' },
    from: objects_1.PluginStateObject.Format.Cif,
    to: objects_1.PluginStateObject.Molecule.Trajectory,
    params: function (a) {
        if (!a) {
            return {
                blockHeader: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text(void 0, { description: 'Header of the block to parse. If none is specifed, the 1st data block in the file is used.' }))
            };
        }
        var blocks = a.data.blocks;
        return {
            blockHeader: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Select(blocks[0] && blocks[0].header, blocks.map(function (b) { return [b.header, b.header]; }), { description: 'Header of the block to parse' }))
        };
    }
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Parse CIF Core', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var header, block, models, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        header = params.blockHeader || a.data.blocks[0].header;
                        block = a.data.blocks.find(function (b) { return b.header === header; });
                        if (!block)
                            throw new Error("Data block '".concat([header], "' not found."));
                        return [4 /*yield*/, (0, cif_core_1.trajectoryFromCifCore)(block).runInContext(ctx)];
                    case 1:
                        models = _a.sent();
                        if (models.frameCount === 0)
                            throw new Error('No models found.');
                        props = trajectoryProps(models);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(models, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromCifCore = TrajectoryFromCifCore;
var plus1 = function (v) { return v + 1; }, minus1 = function (v) { return v - 1; };
var ModelFromTrajectory = objects_1.PluginStateTransform.BuiltIn({
    name: 'model-from-trajectory',
    display: { name: 'Molecular Model', description: 'Create a molecular model from specified index in a trajectory.' },
    from: objects_1.PluginStateObject.Molecule.Trajectory,
    to: objects_1.PluginStateObject.Molecule.Model,
    params: function (a) {
        if (!a) {
            return { modelIndex: param_definition_1.ParamDefinition.Numeric(0, {}, { description: 'Zero-based index of the model', immediateUpdate: true }) };
        }
        return { modelIndex: param_definition_1.ParamDefinition.Converted(plus1, minus1, param_definition_1.ParamDefinition.Numeric(1, { min: 1, max: a.data.frameCount, step: 1 }, { description: 'Model Index', immediateUpdate: true })) };
    }
})({
    isApplicable: function (a) { return a.data.frameCount > 0; },
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Model from Trajectory', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var modelIndex, model, label, description;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        modelIndex = params.modelIndex % a.data.frameCount;
                        if (modelIndex < 0)
                            modelIndex += a.data.frameCount;
                        return [4 /*yield*/, mol_task_1.Task.resolveInContext(a.data.getFrameAtIndex(modelIndex), ctx)];
                    case 1:
                        model = _a.sent();
                        label = "Model ".concat(modelIndex + 1);
                        description = a.data.frameCount === 1 ? undefined : "of ".concat(a.data.frameCount);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Model(model, { label: label, description: description })];
                }
            });
        }); });
    },
    interpolate: function (a, b, t) {
        var modelIndex = t >= 1 ? b.modelIndex : a.modelIndex + Math.floor((b.modelIndex - a.modelIndex + 1) * t);
        return { modelIndex: modelIndex };
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customProperties.dispose();
    }
});
exports.ModelFromTrajectory = ModelFromTrajectory;
var StructureFromTrajectory = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-from-trajectory',
    display: { name: 'Structure from Trajectory', description: 'Create a molecular structure from a trajectory.' },
    from: objects_1.PluginStateObject.Molecule.Trajectory,
    to: objects_1.PluginStateObject.Molecule.Structure
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Build Structure', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var s, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, structure_1.Structure.ofTrajectory(a.data, ctx)];
                    case 1:
                        s = _a.sent();
                        props = { label: 'Ensemble', description: structure_1.Structure.elementDescription(s) };
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Structure(s, props)];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureFromTrajectory = StructureFromTrajectory;
var StructureFromModel = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-from-model',
    display: { name: 'Structure', description: 'Create a molecular structure (model, assembly, or symmetry) from the specified model.' },
    from: objects_1.PluginStateObject.Molecule.Model,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: function (a) { return root_structure_1.RootStructureDefinition.getParams(a && a.data); }
})({
    canAutoUpdate: function (_a) {
        var oldParams = _a.oldParams, newParams = _a.newParams;
        return root_structure_1.RootStructureDefinition.canAutoUpdate(oldParams.type, newParams.type);
    },
    apply: function (_a, plugin) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Build Structure', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, root_structure_1.RootStructureDefinition.create(plugin, ctx, a.data, params && params.type)];
            });
        }); });
    },
    update: function (_a) {
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams;
        if (!(0, mol_util_1.deepEqual)(oldParams, newParams))
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        if (b.data.model === a.data)
            return mol_state_1.StateTransformer.UpdateResult.Unchanged;
        if (!structure_1.Model.areHierarchiesEqual(a.data, b.data.model))
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        b.data = b.data.remapModel(a.data);
        return mol_state_1.StateTransformer.UpdateResult.Updated;
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureFromModel = StructureFromModel;
var _translation = (0, linear_algebra_1.Vec3)(), _m = (0, linear_algebra_1.Mat4)(), _n = (0, linear_algebra_1.Mat4)();
var TransformStructureConformation = objects_1.PluginStateTransform.BuiltIn({
    name: 'transform-structure-conformation',
    display: { name: 'Transform Conformation' },
    isDecorator: true,
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: {
        transform: param_definition_1.ParamDefinition.MappedStatic('components', {
            components: param_definition_1.ParamDefinition.Group({
                axis: param_definition_1.ParamDefinition.Vec3(linear_algebra_1.Vec3.create(1, 0, 0)),
                angle: param_definition_1.ParamDefinition.Numeric(0, { min: -180, max: 180, step: 0.1 }),
                translation: param_definition_1.ParamDefinition.Vec3(linear_algebra_1.Vec3.create(0, 0, 0)),
            }, { isFlat: true }),
            matrix: param_definition_1.ParamDefinition.Group({
                data: param_definition_1.ParamDefinition.Mat4(linear_algebra_1.Mat4.identity()),
                transpose: param_definition_1.ParamDefinition.Boolean(false)
            }, { isFlat: true })
        }, { label: 'Kind' })
    }
})({
    canAutoUpdate: function (_a) {
        var newParams = _a.newParams;
        return newParams.transform.name !== 'matrix';
    },
    apply: function (_a) {
        // TODO: optimze
        // TODO: think of ways how to fast-track changes to this for animations
        var a = _a.a, params = _a.params;
        var transform = (0, linear_algebra_1.Mat4)();
        if (params.transform.name === 'components') {
            var _b = params.transform.params, axis = _b.axis, angle = _b.angle, translation = _b.translation;
            var center = a.data.boundary.sphere.center;
            linear_algebra_1.Mat4.fromTranslation(_m, linear_algebra_1.Vec3.negate(_translation, center));
            linear_algebra_1.Mat4.fromTranslation(_n, linear_algebra_1.Vec3.add(_translation, center, translation));
            var rot = linear_algebra_1.Mat4.fromRotation((0, linear_algebra_1.Mat4)(), Math.PI / 180 * angle, linear_algebra_1.Vec3.normalize((0, linear_algebra_1.Vec3)(), axis));
            linear_algebra_1.Mat4.mul3(transform, _n, rot, _m);
        }
        else if (params.transform.name === 'matrix') {
            linear_algebra_1.Mat4.copy(transform, params.transform.params.data);
            if (params.transform.params.transpose)
                linear_algebra_1.Mat4.transpose(transform, transform);
        }
        var s = structure_1.Structure.transform(a.data, transform);
        return new objects_1.PluginStateObject.Molecule.Structure(s, { label: a.label, description: "".concat(a.description, " [Transformed]") });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
    // interpolate(src, tar, t) {
    //     // TODO: optimize
    //     const u = Mat4.fromRotation(Mat4(), Math.PI / 180 * src.angle, Vec3.normalize(Vec3(), src.axis));
    //     Mat4.setTranslation(u, src.translation);
    //     const v = Mat4.fromRotation(Mat4(), Math.PI / 180 * tar.angle, Vec3.normalize(Vec3(), tar.axis));
    //     Mat4.setTranslation(v, tar.translation);
    //     const m = SymmetryOperator.slerp(Mat4(), u, v, t);
    //     const rot = Mat4.getRotation(Quat.zero(), m);
    //     const axis = Vec3();
    //     const angle = Quat.getAxisAngle(axis, rot);
    //     const translation = Mat4.getTranslation(Vec3(), m);
    //     return { axis, angle, translation };
    // }
});
exports.TransformStructureConformation = TransformStructureConformation;
var StructureSelectionFromExpression = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-selection-from-expression',
    display: { name: 'Selection', description: 'Create a molecular structure from the specified expression.' },
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: function () { return ({
        expression: param_definition_1.ParamDefinition.Value(builder_1.MolScriptBuilder.struct.generator.all, { isHidden: true }),
        label: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text('', { isHidden: true }))
    }); }
})({
    apply: function (_a) {
        var a = _a.a, params = _a.params, cache = _a.cache;
        var _b = structure_query_1.StructureQueryHelper.createAndRun(a.data, params.expression), selection = _b.selection, entry = _b.entry;
        cache.entry = entry;
        if (structure_1.StructureSelection.isEmpty(selection))
            return mol_state_1.StateObject.Null;
        var s = structure_1.StructureSelection.unionStructure(selection);
        var props = { label: "".concat(params.label || 'Selection'), description: structure_1.Structure.elementDescription(s) };
        return new objects_1.PluginStateObject.Molecule.Structure(s, props);
    },
    update: function (_a) {
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams, cache = _a.cache;
        if (oldParams.expression !== newParams.expression)
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        var entry = cache.entry;
        if (entry.currentStructure === a.data) {
            return mol_state_1.StateTransformer.UpdateResult.Unchanged;
        }
        var selection = structure_query_1.StructureQueryHelper.updateStructure(entry, a.data);
        if (structure_1.StructureSelection.isEmpty(selection))
            return mol_state_1.StateTransformer.UpdateResult.Null;
        structure_query_1.StructureQueryHelper.updateStructureObject(b, selection, newParams.label);
        return mol_state_1.StateTransformer.UpdateResult.Updated;
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureSelectionFromExpression = StructureSelectionFromExpression;
var MultiStructureSelectionFromExpression = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-multi-selection-from-expression',
    display: { name: 'Multi-structure Measurement Selection', description: 'Create selection object from multiple structures.' },
    from: objects_1.PluginStateObject.Root,
    to: objects_1.PluginStateObject.Molecule.Structure.Selections,
    params: function () { return ({
        selections: param_definition_1.ParamDefinition.ObjectList({
            key: param_definition_1.ParamDefinition.Text(void 0, { description: 'A unique key.' }),
            ref: param_definition_1.ParamDefinition.Text(),
            groupId: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text()),
            expression: param_definition_1.ParamDefinition.Value(builder_1.MolScriptBuilder.struct.generator.empty)
        }, function (e) { return e.ref; }, { isHidden: true }),
        isTransitive: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Boolean(false, { isHidden: true, description: 'Remap the selections from the original structure if structurally equivalent.' })),
        label: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text('', { isHidden: true }))
    }); }
})({
    apply: function (_a) {
        var params = _a.params, cache = _a.cache, dependencies = _a.dependencies;
        var entries = new Map();
        var selections = [];
        var totalSize = 0;
        for (var _i = 0, _b = params.selections; _i < _b.length; _i++) {
            var sel = _b[_i];
            var _c = structure_query_1.StructureQueryHelper.createAndRun(dependencies[sel.ref].data, sel.expression), selection = _c.selection, entry = _c.entry;
            entries.set(sel.key, entry);
            var loci = structure_1.StructureSelection.toLociWithSourceUnits(selection);
            selections.push({ key: sel.key, loci: loci, groupId: sel.groupId });
            totalSize += structure_1.StructureElement.Loci.size(loci);
        }
        cache.entries = entries;
        var props = { label: "".concat(params.label || 'Multi-selection'), description: "".concat(params.selections.length, " source(s), ").concat(totalSize, " element(s) total") };
        return new objects_1.PluginStateObject.Molecule.Structure.Selections(selections, props);
    },
    update: function (_a) {
        var b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams, cache = _a.cache, dependencies = _a.dependencies;
        if (!!oldParams.isTransitive !== !!newParams.isTransitive)
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        var cacheEntries = cache.entries;
        var entries = new Map();
        var current = new Map();
        for (var _i = 0, _b = b.data; _i < _b.length; _i++) {
            var e = _b[_i];
            current.set(e.key, e);
        }
        var changed = false;
        var totalSize = 0;
        var selections = [];
        for (var _c = 0, _d = newParams.selections; _c < _d.length; _c++) {
            var sel = _d[_c];
            var structure = dependencies[sel.ref].data;
            var recreate = false;
            if (cacheEntries.has(sel.key)) {
                var entry = cacheEntries.get(sel.key);
                if (structure_query_1.StructureQueryHelper.isUnchanged(entry, sel.expression, structure) && current.has(sel.key)) {
                    var loci = current.get(sel.key);
                    if (loci.groupId !== sel.groupId) {
                        loci.groupId = sel.groupId;
                        changed = true;
                    }
                    entries.set(sel.key, entry);
                    selections.push(loci);
                    totalSize += structure_1.StructureElement.Loci.size(loci.loci);
                    continue;
                }
                if (entry.expression !== sel.expression) {
                    recreate = true;
                }
                else {
                    // TODO: properly support "transitive" queries. For that Structure.areUnitAndIndicesEqual needs to be fixed;
                    var update = false;
                    if (!!newParams.isTransitive) {
                        if (structure_1.Structure.areUnitIdsAndIndicesEqual(entry.originalStructure, structure)) {
                            var selection = structure_query_1.StructureQueryHelper.run(entry, entry.originalStructure);
                            entry.currentStructure = structure;
                            entries.set(sel.key, entry);
                            var loci = structure_1.StructureElement.Loci.remap(structure_1.StructureSelection.toLociWithSourceUnits(selection), structure);
                            selections.push({ key: sel.key, loci: loci, groupId: sel.groupId });
                            totalSize += structure_1.StructureElement.Loci.size(loci);
                            changed = true;
                        }
                        else {
                            update = true;
                        }
                    }
                    else {
                        update = true;
                    }
                    if (update) {
                        changed = true;
                        var selection = structure_query_1.StructureQueryHelper.updateStructure(entry, structure);
                        entries.set(sel.key, entry);
                        var loci = structure_1.StructureSelection.toLociWithSourceUnits(selection);
                        selections.push({ key: sel.key, loci: loci, groupId: sel.groupId });
                        totalSize += structure_1.StructureElement.Loci.size(loci);
                    }
                }
            }
            else {
                recreate = true;
            }
            if (recreate) {
                changed = true;
                // create new selection
                var _e = structure_query_1.StructureQueryHelper.createAndRun(structure, sel.expression), selection = _e.selection, entry = _e.entry;
                entries.set(sel.key, entry);
                var loci = structure_1.StructureSelection.toLociWithSourceUnits(selection);
                selections.push({ key: sel.key, loci: loci });
                totalSize += structure_1.StructureElement.Loci.size(loci);
            }
        }
        if (!changed)
            return mol_state_1.StateTransformer.UpdateResult.Unchanged;
        cache.entries = entries;
        b.data = selections;
        b.label = "".concat(newParams.label || 'Multi-selection');
        b.description = "".concat(selections.length, " source(s), ").concat(totalSize, " element(s) total");
        return mol_state_1.StateTransformer.UpdateResult.Updated;
    }
});
exports.MultiStructureSelectionFromExpression = MultiStructureSelectionFromExpression;
var StructureSelectionFromScript = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-selection-from-script',
    display: { name: 'Selection', description: 'Create a molecular structure from the specified script.' },
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: function () { return ({
        script: param_definition_1.ParamDefinition.Script({ language: 'mol-script', expression: '(sel.atom.atom-groups :residue-test (= atom.resname ALA))' }),
        label: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text(''))
    }); }
})({
    apply: function (_a) {
        var a = _a.a, params = _a.params, cache = _a.cache;
        var _b = structure_query_1.StructureQueryHelper.createAndRun(a.data, params.script), selection = _b.selection, entry = _b.entry;
        cache.entry = entry;
        var s = structure_1.StructureSelection.unionStructure(selection);
        var props = { label: "".concat(params.label || 'Selection'), description: structure_1.Structure.elementDescription(s) };
        return new objects_1.PluginStateObject.Molecule.Structure(s, props);
    },
    update: function (_a) {
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams, cache = _a.cache;
        if (!script_1.Script.areEqual(oldParams.script, newParams.script)) {
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        }
        var entry = cache.entry;
        if (entry.currentStructure === a.data) {
            return mol_state_1.StateTransformer.UpdateResult.Unchanged;
        }
        var selection = structure_query_1.StructureQueryHelper.updateStructure(entry, a.data);
        structure_query_1.StructureQueryHelper.updateStructureObject(b, selection, newParams.label);
        return mol_state_1.StateTransformer.UpdateResult.Updated;
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureSelectionFromScript = StructureSelectionFromScript;
var StructureSelectionFromBundle = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-selection-from-bundle',
    display: { name: 'Selection', description: 'Create a molecular structure from the specified structure-element bundle.' },
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: function () { return ({
        bundle: param_definition_1.ParamDefinition.Value(structure_1.StructureElement.Bundle.Empty, { isHidden: true }),
        label: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text('', { isHidden: true }))
    }); }
})({
    apply: function (_a) {
        var a = _a.a, params = _a.params, cache = _a.cache;
        if (params.bundle.hash !== a.data.hashCode) {
            return mol_state_1.StateObject.Null;
        }
        cache.source = a.data;
        var s = structure_1.StructureElement.Bundle.toStructure(params.bundle, a.data);
        if (s.elementCount === 0)
            return mol_state_1.StateObject.Null;
        var props = { label: "".concat(params.label || 'Selection'), description: structure_1.Structure.elementDescription(s) };
        return new objects_1.PluginStateObject.Molecule.Structure(s, props);
    },
    update: function (_a) {
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams, cache = _a.cache;
        if (!structure_1.StructureElement.Bundle.areEqual(oldParams.bundle, newParams.bundle)) {
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        }
        if (newParams.bundle.hash !== a.data.hashCode) {
            return mol_state_1.StateTransformer.UpdateResult.Null;
        }
        if (cache.source === a.data) {
            return mol_state_1.StateTransformer.UpdateResult.Unchanged;
        }
        cache.source = a.data;
        var s = structure_1.StructureElement.Bundle.toStructure(newParams.bundle, a.data);
        if (s.elementCount === 0)
            return mol_state_1.StateTransformer.UpdateResult.Null;
        b.label = "".concat(newParams.label || 'Selection');
        b.description = structure_1.Structure.elementDescription(s);
        b.data = s;
        return mol_state_1.StateTransformer.UpdateResult.Updated;
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureSelectionFromBundle = StructureSelectionFromBundle;
exports.StructureComplexElementTypes = {
    'polymer': 'polymer',
    'protein': 'protein',
    'nucleic': 'nucleic',
    'water': 'water',
    'branched': 'branched',
    'ligand': 'ligand',
    'non-standard': 'non-standard',
    'coarse': 'coarse',
    // Legacy
    'atomic-sequence': 'atomic-sequence',
    'atomic-het': 'atomic-het',
    'spheres': 'spheres'
};
var StructureComplexElementTypeTuples = param_definition_1.ParamDefinition.objectToOptions(exports.StructureComplexElementTypes);
var StructureComplexElement = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-complex-element',
    display: { name: 'Complex Element', description: 'Create a molecular structure from the specified model.' },
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: { type: param_definition_1.ParamDefinition.Select('atomic-sequence', StructureComplexElementTypeTuples, { isHidden: true }) }
})({
    apply: function (_a) {
        // TODO: update function.
        var a = _a.a, params = _a.params;
        var query, label;
        switch (params.type) {
            case 'polymer':
                query = structure_selection_query_1.StructureSelectionQueries.polymer.query;
                label = 'Polymer';
                break;
            case 'protein':
                query = structure_selection_query_1.StructureSelectionQueries.protein.query;
                label = 'Protein';
                break;
            case 'nucleic':
                query = structure_selection_query_1.StructureSelectionQueries.nucleic.query;
                label = 'Nucleic';
                break;
            case 'water':
                query = structure_1.Queries.internal.water();
                label = 'Water';
                break;
            case 'branched':
                query = structure_selection_query_1.StructureSelectionQueries.branchedPlusConnected.query;
                label = 'Branched';
                break;
            case 'ligand':
                query = structure_selection_query_1.StructureSelectionQueries.ligandPlusConnected.query;
                label = 'Ligand';
                break;
            case 'non-standard':
                query = structure_selection_query_1.StructureSelectionQueries.nonStandardPolymer.query;
                label = 'Non-standard';
                break;
            case 'coarse':
                query = structure_selection_query_1.StructureSelectionQueries.coarse.query;
                label = 'Coarse';
                break;
            case 'atomic-sequence':
                query = structure_1.Queries.internal.atomicSequence();
                label = 'Sequence';
                break;
            case 'atomic-het':
                query = structure_1.Queries.internal.atomicHet();
                label = 'HET Groups/Ligands';
                break;
            case 'spheres':
                query = structure_1.Queries.internal.spheres();
                label = 'Coarse Spheres';
                break;
            default: (0, type_helpers_1.assertUnreachable)(params.type);
        }
        var result = query(new structure_1.QueryContext(a.data));
        var s = structure_1.StructureSelection.unionStructure(result);
        if (s.elementCount === 0)
            return mol_state_1.StateObject.Null;
        return new objects_1.PluginStateObject.Molecule.Structure(s, { label: label, description: structure_1.Structure.elementDescription(s) });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureComplexElement = StructureComplexElement;
var StructureComponent = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-component',
    display: { name: 'Component', description: 'A molecular structure component.' },
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: structure_component_1.StructureComponentParams
})({
    apply: function (_a) {
        var a = _a.a, params = _a.params, cache = _a.cache;
        return (0, structure_component_1.createStructureComponent)(a.data, params, cache);
    },
    update: function (_a) {
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams, cache = _a.cache;
        return (0, structure_component_1.updateStructureComponent)(a.data, b, oldParams, newParams, cache);
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureComponent = StructureComponent;
var CustomModelProperties = objects_1.PluginStateTransform.BuiltIn({
    name: 'custom-model-properties',
    display: { name: 'Custom Model Properties' },
    isDecorator: true,
    from: objects_1.PluginStateObject.Molecule.Model,
    to: objects_1.PluginStateObject.Molecule.Model,
    params: function (a, ctx) {
        return ctx.customModelProperties.getParams(a === null || a === void 0 ? void 0 : a.data);
    }
})({
    apply: function (_a, ctx) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Custom Props', function (taskCtx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, attachModelProps(a.data, ctx, taskCtx, params)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Model(a.data, { label: a.label, description: a.description })];
                }
            });
        }); });
    },
    update: function (_a, ctx) {
        var _this = this;
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams;
        return mol_task_1.Task.create('Custom Props', function (taskCtx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _i, _a, name_1, property;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        b.data = a.data;
                        b.label = a.label;
                        b.description = a.description;
                        for (_i = 0, _a = oldParams.autoAttach; _i < _a.length; _i++) {
                            name_1 = _a[_i];
                            property = ctx.customModelProperties.get(name_1);
                            if (!property)
                                continue;
                            a.data.customProperties.reference(property.descriptor, false);
                        }
                        return [4 /*yield*/, attachModelProps(a.data, ctx, taskCtx, newParams)];
                    case 1:
                        _b.sent();
                        return [2 /*return*/, mol_state_1.StateTransformer.UpdateResult.Updated];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customProperties.dispose();
    }
});
exports.CustomModelProperties = CustomModelProperties;
function attachModelProps(model, ctx, taskCtx, params) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var propertyCtx, autoAttach, properties, _i, _a, name_2, property, props, e_1;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    propertyCtx = { runtime: taskCtx, assetManager: ctx.managers.asset };
                    autoAttach = params.autoAttach, properties = params.properties;
                    _i = 0, _a = Object.keys(properties);
                    _b.label = 1;
                case 1:
                    if (!(_i < _a.length)) return [3 /*break*/, 8];
                    name_2 = _a[_i];
                    property = ctx.customModelProperties.get(name_2);
                    props = properties[name_2];
                    if (!(autoAttach.includes(name_2) || property.isHidden)) return [3 /*break*/, 6];
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, property.attach(propertyCtx, model, props, true)];
                case 3:
                    _b.sent();
                    return [3 /*break*/, 5];
                case 4:
                    e_1 = _b.sent();
                    ctx.log.warn("Error attaching model prop '".concat(name_2, "': ").concat(e_1));
                    return [3 /*break*/, 5];
                case 5: return [3 /*break*/, 7];
                case 6:
                    property.set(model, props);
                    _b.label = 7;
                case 7:
                    _i++;
                    return [3 /*break*/, 1];
                case 8: return [2 /*return*/];
            }
        });
    });
}
var CustomStructureProperties = objects_1.PluginStateTransform.BuiltIn({
    name: 'custom-structure-properties',
    display: { name: 'Custom Structure Properties' },
    isDecorator: true,
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: function (a, ctx) {
        return ctx.customStructureProperties.getParams(a === null || a === void 0 ? void 0 : a.data.root);
    }
})({
    apply: function (_a, ctx) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Custom Props', function (taskCtx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, attachStructureProps(a.data.root, ctx, taskCtx, params)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Structure(a.data, { label: a.label, description: a.description })];
                }
            });
        }); });
    },
    update: function (_a, ctx) {
        var _this = this;
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams;
        if (a.data !== b.data)
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        return mol_task_1.Task.create('Custom Props', function (taskCtx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _i, _a, name_3, property;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        b.data = a.data;
                        b.label = a.label;
                        b.description = a.description;
                        for (_i = 0, _a = oldParams.autoAttach; _i < _a.length; _i++) {
                            name_3 = _a[_i];
                            property = ctx.customStructureProperties.get(name_3);
                            if (!property)
                                continue;
                            a.data.customPropertyDescriptors.reference(property.descriptor, false);
                        }
                        return [4 /*yield*/, attachStructureProps(a.data.root, ctx, taskCtx, newParams)];
                    case 1:
                        _b.sent();
                        return [2 /*return*/, mol_state_1.StateTransformer.UpdateResult.Updated];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.CustomStructureProperties = CustomStructureProperties;
function attachStructureProps(structure, ctx, taskCtx, params) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var propertyCtx, autoAttach, properties, _i, _a, name_4, property, props, e_2;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    propertyCtx = { runtime: taskCtx, assetManager: ctx.managers.asset };
                    autoAttach = params.autoAttach, properties = params.properties;
                    _i = 0, _a = Object.keys(properties);
                    _b.label = 1;
                case 1:
                    if (!(_i < _a.length)) return [3 /*break*/, 8];
                    name_4 = _a[_i];
                    property = ctx.customStructureProperties.get(name_4);
                    props = properties[name_4];
                    if (!(autoAttach.includes(name_4) || property.isHidden)) return [3 /*break*/, 6];
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, property.attach(propertyCtx, structure, props, true)];
                case 3:
                    _b.sent();
                    return [3 /*break*/, 5];
                case 4:
                    e_2 = _b.sent();
                    ctx.log.warn("Error attaching structure prop '".concat(name_4, "': ").concat(e_2));
                    return [3 /*break*/, 5];
                case 5: return [3 /*break*/, 7];
                case 6:
                    property.set(structure, props);
                    _b.label = 7;
                case 7:
                    _i++;
                    return [3 /*break*/, 1];
                case 8: return [2 /*return*/];
            }
        });
    });
}
var ShapeFromPly = objects_1.PluginStateTransform.BuiltIn({
    name: 'shape-from-ply',
    display: { name: 'Shape from PLY', description: 'Create Shape from PLY data' },
    from: objects_1.PluginStateObject.Format.Ply,
    to: objects_1.PluginStateObject.Shape.Provider,
    params: function (a) {
        return {};
    }
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Create shape from PLY', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var shape, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, ply_1.shapeFromPly)(a.data, params).runInContext(ctx)];
                    case 1:
                        shape = _a.sent();
                        props = { label: 'Shape' };
                        return [2 /*return*/, new objects_1.PluginStateObject.Shape.Provider(shape, props)];
                }
            });
        }); });
    }
});
exports.ShapeFromPly = ShapeFromPly;
