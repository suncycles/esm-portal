"use strict";
/**
 * Copyright (c) 2019-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RootStructureDefinition = void 0;
var tslib_1 = require("tslib");
var structure_1 = require("../../mol-model/structure");
var string_1 = require("../../mol-util/string");
var geometry_1 = require("../../mol-math/geometry");
var param_definition_1 = require("../../mol-util/param-definition");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var symmetry_1 = require("../../mol-model/structure/model/properties/symmetry");
var objects_1 = require("../objects");
var symmetry_2 = require("../../mol-model-formats/structure/property/symmetry");
var type_helpers_1 = require("../../mol-util/type-helpers");
var CommonStructureParams = {
    dynamicBonds: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Boolean(false, { description: 'Ensure bonds are recalculated upon model changes. Also enables calculation of inter-unit bonds in water molecules and ions.' })),
};
var RootStructureDefinition;
(function (RootStructureDefinition) {
    function getParams(model, defaultValue) {
        var symmetry = model && symmetry_2.ModelSymmetry.Provider.get(model);
        var assemblyIds = symmetry ? symmetry.assemblies.map(function (a) { return [a.id, "".concat(a.id, ": ").concat((0, string_1.stringToWords)(a.details))]; }) : [];
        var showSymm = !symmetry ? true : !geometry_1.SpacegroupCell.isZero(symmetry.spacegroup.cell);
        var operatorOptions = [];
        if (symmetry) {
            var operators = symmetry.spacegroup.operators;
            for (var i = 0, il = operators.length; i < il; i++) {
                operatorOptions.push([i, "".concat(i + 1, ": ").concat(geometry_1.Spacegroup.getOperatorXyz(operators[i]))]);
            }
        }
        var asymIdsOptions = [];
        if (model) {
            model.properties.structAsymMap.forEach(function (v) {
                var label = v.id === v.auth_id ? v.id : "".concat(v.id, " [auth ").concat(v.auth_id, "]");
                asymIdsOptions.push([v.id, label]);
            });
        }
        var modes = {
            auto: param_definition_1.ParamDefinition.Group(CommonStructureParams),
            model: param_definition_1.ParamDefinition.Group(CommonStructureParams),
            assembly: param_definition_1.ParamDefinition.Group(tslib_1.__assign({ id: param_definition_1.ParamDefinition.Optional(model
                    ? param_definition_1.ParamDefinition.Select(assemblyIds.length ? assemblyIds[0][0] : '', assemblyIds, { label: 'Asm Id', description: 'Assembly Id' })
                    : param_definition_1.ParamDefinition.Text('', { label: 'Asm Id', description: 'Assembly Id (use empty for the 1st assembly)' })) }, CommonStructureParams), { isFlat: true }),
            'symmetry-mates': param_definition_1.ParamDefinition.Group(tslib_1.__assign({ radius: param_definition_1.ParamDefinition.Numeric(5, { min: 0, max: 50, step: 1 }) }, CommonStructureParams), { isFlat: true }),
            'symmetry': param_definition_1.ParamDefinition.Group(tslib_1.__assign({ ijkMin: param_definition_1.ParamDefinition.Vec3(linear_algebra_1.Vec3.create(-1, -1, -1), { step: 1 }, { label: 'Min IJK', fieldLabels: { x: 'I', y: 'J', z: 'K' } }), ijkMax: param_definition_1.ParamDefinition.Vec3(linear_algebra_1.Vec3.create(1, 1, 1), { step: 1 }, { label: 'Max IJK', fieldLabels: { x: 'I', y: 'J', z: 'K' } }) }, CommonStructureParams), { isFlat: true }),
            'symmetry-assembly': param_definition_1.ParamDefinition.Group(tslib_1.__assign({ generators: param_definition_1.ParamDefinition.ObjectList({
                    operators: param_definition_1.ParamDefinition.ObjectList({
                        index: param_definition_1.ParamDefinition.Select(0, operatorOptions),
                        shift: param_definition_1.ParamDefinition.Vec3((0, linear_algebra_1.Vec3)(), { step: 1 }, { label: 'IJK', fieldLabels: { x: 'I', y: 'J', z: 'K' } })
                    }, function (e) { return "".concat(e.index + 1, "_").concat(e.shift.map(function (a) { return a + 5; }).join('')); }, {
                        defaultValue: []
                    }),
                    asymIds: param_definition_1.ParamDefinition.MultiSelect([], asymIdsOptions)
                }, function (e) { return "".concat(e.asymIds.length, " asym ids, ").concat(e.operators.length, " operators"); }, {
                    defaultValue: []
                }) }, CommonStructureParams), { isFlat: true })
        };
        var options = [];
        if (defaultValue === 'auto') {
            options.push(['auto', 'Auto']);
        }
        options.push(['model', 'Model']);
        if (assemblyIds.length > 0) {
            options.push(['assembly', 'Assembly']);
        }
        if (showSymm) {
            options.push(['symmetry-mates', 'Symmetry Mates']);
            options.push(['symmetry', 'Symmetry (indices)']);
            options.push(['symmetry-assembly', 'Symmetry (assembly)']);
        }
        return {
            type: param_definition_1.ParamDefinition.MappedStatic(defaultValue || 'model', modes, { options: options })
        };
    }
    RootStructureDefinition.getParams = getParams;
    function canAutoUpdate(oldParams, newParams) {
        if (newParams.name === 'symmetry-assembly' || (newParams.name === 'symmetry' && oldParams.name === 'symmetry'))
            return false;
        return true;
    }
    RootStructureDefinition.canAutoUpdate = canAutoUpdate;
    function buildAssembly(plugin, ctx, model, id, props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var asm, symmetry, base, label, s, objProps;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        asm = void 0;
                        symmetry = symmetry_2.ModelSymmetry.Provider.get(model);
                        // if no id is specified, use the 1st assembly.
                        if (!id && symmetry && symmetry.assemblies.length !== 0) {
                            id = symmetry.assemblies[0].id;
                        }
                        if (!symmetry || symmetry.assemblies.length === 0) {
                            plugin.log.warn("Model '".concat(model.entryId, "' has no assembly, returning model structure."));
                        }
                        else {
                            asm = symmetry_1.Symmetry.findAssembly(model, id || '');
                            if (!asm) {
                                plugin.log.warn("Model '".concat(model.entryId, "' has no assembly called '").concat(id, "', returning model structure."));
                            }
                        }
                        base = structure_1.Structure.ofModel(model, props);
                        if (!asm) {
                            label = { label: 'Model', description: structure_1.Structure.elementDescription(base) };
                            return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Structure(base, label)];
                        }
                        id = asm.id;
                        return [4 /*yield*/, structure_1.StructureSymmetry.buildAssembly(base, id).runInContext(ctx)];
                    case 1:
                        s = _a.sent();
                        objProps = { label: "Assembly ".concat(id), description: structure_1.Structure.elementDescription(s) };
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Structure(s, objProps)];
                }
            });
        });
    }
    function buildSymmetry(ctx, model, ijkMin, ijkMax, props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var base, s, objProps;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        base = structure_1.Structure.ofModel(model, props);
                        return [4 /*yield*/, structure_1.StructureSymmetry.buildSymmetryRange(base, ijkMin, ijkMax).runInContext(ctx)];
                    case 1:
                        s = _a.sent();
                        objProps = { label: "Symmetry [".concat(ijkMin, "] to [").concat(ijkMax, "]"), description: structure_1.Structure.elementDescription(s) };
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Structure(s, objProps)];
                }
            });
        });
    }
    function buildSymmetryMates(ctx, model, radius, props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var base, s, objProps;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        base = structure_1.Structure.ofModel(model, props);
                        return [4 /*yield*/, structure_1.StructureSymmetry.builderSymmetryMates(base, radius).runInContext(ctx)];
                    case 1:
                        s = _a.sent();
                        objProps = { label: "Symmetry Mates", description: structure_1.Structure.elementDescription(s) };
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Structure(s, objProps)];
                }
            });
        });
    }
    function buildSymmetryAssembly(ctx, model, generators, symmetry, props) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var base, s, objProps;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        base = structure_1.Structure.ofModel(model, props);
                        return [4 /*yield*/, structure_1.StructureSymmetry.buildSymmetryAssembly(base, generators, symmetry).runInContext(ctx)];
                    case 1:
                        s = _a.sent();
                        objProps = { label: "Symmetry Assembly", description: structure_1.Structure.elementDescription(s) };
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Structure(s, objProps)];
                }
            });
        });
    }
    function create(plugin, ctx, model, params) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var props, symmetry, s, s;
            return tslib_1.__generator(this, function (_a) {
                props = params === null || params === void 0 ? void 0 : params.params;
                symmetry = symmetry_2.ModelSymmetry.Provider.get(model);
                if (!symmetry || !params || params.name === 'model') {
                    s = structure_1.Structure.ofModel(model, props);
                    return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Structure(s, { label: 'Model', description: structure_1.Structure.elementDescription(s) })];
                }
                if (params.name === 'auto') {
                    if (symmetry.assemblies.length === 0) {
                        s = structure_1.Structure.ofModel(model, props);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Structure(s, { label: 'Model', description: structure_1.Structure.elementDescription(s) })];
                    }
                    else {
                        return [2 /*return*/, buildAssembly(plugin, ctx, model, undefined, props)];
                    }
                }
                if (params.name === 'assembly') {
                    return [2 /*return*/, buildAssembly(plugin, ctx, model, params.params.id, props)];
                }
                if (params.name === 'symmetry') {
                    return [2 /*return*/, buildSymmetry(ctx, model, params.params.ijkMin, params.params.ijkMax, props)];
                }
                if (params.name === 'symmetry-mates') {
                    return [2 /*return*/, buildSymmetryMates(ctx, model, params.params.radius, props)];
                }
                if (params.name === 'symmetry-assembly') {
                    return [2 /*return*/, buildSymmetryAssembly(ctx, model, params.params.generators, symmetry, props)];
                }
                (0, type_helpers_1.assertUnreachable)(params);
                return [2 /*return*/];
            });
        });
    }
    RootStructureDefinition.create = create;
})(RootStructureDefinition = exports.RootStructureDefinition || (exports.RootStructureDefinition = {}));
