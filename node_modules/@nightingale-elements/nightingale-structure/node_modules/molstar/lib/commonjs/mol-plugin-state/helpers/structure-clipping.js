"use strict";
/**
 * Copyright (c) 2019-2023 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setStructureClipping = void 0;
var tslib_1 = require("tslib");
var structure_1 = require("../../mol-model/structure");
var transforms_1 = require("../../mol-plugin-state/transforms");
var mol_state_1 = require("../../mol-state");
var loci_1 = require("../../mol-model/loci");
var clipping_1 = require("../../mol-theme/clipping");
var ClippingManagerTag = 'clipping-controls';
function setStructureClipping(plugin, components, groups, lociGetter, types) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _this = this;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, eachRepr(plugin, components, function (update, repr, clippingCell) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        var structure, loci, layer, bundleLayers, filtered, filtered;
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (types && types.length > 0 && !types.includes(repr.params.values.type.name))
                                        return [2 /*return*/];
                                    structure = repr.obj.data.sourceData;
                                    return [4 /*yield*/, lociGetter(structure.root)];
                                case 1:
                                    loci = _a.sent();
                                    if (loci_1.Loci.isEmpty(loci) || (0, loci_1.isEmptyLoci)(loci))
                                        return [2 /*return*/];
                                    layer = {
                                        bundle: structure_1.StructureElement.Bundle.fromLoci(loci),
                                        groups: groups
                                    };
                                    if (clippingCell) {
                                        bundleLayers = tslib_1.__spreadArray(tslib_1.__spreadArray([], clippingCell.params.values.layers, true), [layer], false);
                                        filtered = getFilteredBundle(bundleLayers, structure);
                                        update.to(clippingCell).update(clipping_1.Clipping.toBundle(filtered));
                                    }
                                    else {
                                        filtered = getFilteredBundle([layer], structure);
                                        update.to(repr.transform.ref)
                                            .apply(transforms_1.StateTransforms.Representation.ClippingStructureRepresentation3DFromBundle, clipping_1.Clipping.toBundle(filtered), { tags: ClippingManagerTag });
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    }); })];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
exports.setStructureClipping = setStructureClipping;
function eachRepr(plugin, components, callback) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var state, update, _i, components_1, c, _a, _b, r, clipping;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    state = plugin.state.data;
                    update = state.build();
                    _i = 0, components_1 = components;
                    _c.label = 1;
                case 1:
                    if (!(_i < components_1.length)) return [3 /*break*/, 6];
                    c = components_1[_i];
                    _a = 0, _b = c.representations;
                    _c.label = 2;
                case 2:
                    if (!(_a < _b.length)) return [3 /*break*/, 5];
                    r = _b[_a];
                    clipping = state.select(mol_state_1.StateSelection.Generators.ofTransformer(transforms_1.StateTransforms.Representation.ClippingStructureRepresentation3DFromBundle, r.cell.transform.ref).withTag(ClippingManagerTag));
                    return [4 /*yield*/, callback(update, r.cell, clipping[0])];
                case 3:
                    _c.sent();
                    _c.label = 4;
                case 4:
                    _a++;
                    return [3 /*break*/, 2];
                case 5:
                    _i++;
                    return [3 /*break*/, 1];
                case 6: return [2 /*return*/, update.commit({ doNotUpdateCurrent: true })];
            }
        });
    });
}
/** filter clipping layers for given structure */
function getFilteredBundle(layers, structure) {
    var clipping = clipping_1.Clipping.ofBundle(layers, structure.root);
    var merged = clipping_1.Clipping.merge(clipping);
    return clipping_1.Clipping.filter(merged, structure);
}
