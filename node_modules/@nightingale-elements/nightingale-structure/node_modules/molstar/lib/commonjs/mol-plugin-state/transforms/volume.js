"use strict";
/**
 * Copyright (c) 2018-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VolumeFromSegmentationCif = exports.VolumeFromDensityServerCif = exports.AssignColorVolume = exports.VolumeFromDx = exports.VolumeFromCube = exports.VolumeFromDsn6 = exports.VolumeFromCcp4 = void 0;
var tslib_1 = require("tslib");
var cif_1 = require("../../mol-io/reader/cif");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var ccp4_1 = require("../../mol-model-formats/volume/ccp4");
var density_server_1 = require("../../mol-model-formats/volume/density-server");
var dsn6_1 = require("../../mol-model-formats/volume/dsn6");
var mol_task_1 = require("../../mol-task");
var param_definition_1 = require("../../mol-util/param-definition");
var objects_1 = require("../objects");
var cube_1 = require("../../mol-model-formats/volume/cube");
var dx_1 = require("../../mol-model-formats/volume/dx");
var mol_state_1 = require("../../mol-state");
var segmentation_1 = require("../../mol-model-formats/volume/segmentation");
var VolumeFromCcp4 = objects_1.PluginStateTransform.BuiltIn({
    name: 'volume-from-ccp4',
    display: { name: 'Volume from CCP4/MRC/MAP', description: 'Create Volume from CCP4/MRC/MAP data' },
    from: objects_1.PluginStateObject.Format.Ccp4,
    to: objects_1.PluginStateObject.Volume.Data,
    params: function (a) {
        return {
            voxelSize: param_definition_1.ParamDefinition.Vec3(linear_algebra_1.Vec3.create(1, 1, 1)),
            offset: param_definition_1.ParamDefinition.Vec3(linear_algebra_1.Vec3.create(0, 0, 0)),
            entryId: param_definition_1.ParamDefinition.Text(''),
        };
    }
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Create volume from CCP4/MRC/MAP', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var volume, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, ccp4_1.volumeFromCcp4)(a.data, tslib_1.__assign(tslib_1.__assign({}, params), { label: a.data.name || a.label })).runInContext(ctx)];
                    case 1:
                        volume = _a.sent();
                        props = { label: volume.label || 'Volume', description: "Volume ".concat(a.data.header.NX, "\u00D7").concat(a.data.header.NX, "\u00D7").concat(a.data.header.NX) };
                        return [2 /*return*/, new objects_1.PluginStateObject.Volume.Data(volume, props)];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customProperties.dispose();
    }
});
exports.VolumeFromCcp4 = VolumeFromCcp4;
var VolumeFromDsn6 = objects_1.PluginStateTransform.BuiltIn({
    name: 'volume-from-dsn6',
    display: { name: 'Volume from DSN6/BRIX', description: 'Create Volume from DSN6/BRIX data' },
    from: objects_1.PluginStateObject.Format.Dsn6,
    to: objects_1.PluginStateObject.Volume.Data,
    params: function (a) {
        return {
            voxelSize: param_definition_1.ParamDefinition.Vec3(linear_algebra_1.Vec3.create(1, 1, 1)),
            entryId: param_definition_1.ParamDefinition.Text(''),
        };
    }
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Create volume from DSN6/BRIX', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var volume, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, dsn6_1.volumeFromDsn6)(a.data, tslib_1.__assign(tslib_1.__assign({}, params), { label: a.data.name || a.label })).runInContext(ctx)];
                    case 1:
                        volume = _a.sent();
                        props = { label: volume.label || 'Volume', description: "Volume ".concat(a.data.header.xExtent, "\u00D7").concat(a.data.header.yExtent, "\u00D7").concat(a.data.header.zExtent) };
                        return [2 /*return*/, new objects_1.PluginStateObject.Volume.Data(volume, props)];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customProperties.dispose();
    }
});
exports.VolumeFromDsn6 = VolumeFromDsn6;
var VolumeFromCube = objects_1.PluginStateTransform.BuiltIn({
    name: 'volume-from-cube',
    display: { name: 'Volume from Cube', description: 'Create Volume from Cube data' },
    from: objects_1.PluginStateObject.Format.Cube,
    to: objects_1.PluginStateObject.Volume.Data,
    params: function (a) {
        var dataIndex = a ? param_definition_1.ParamDefinition.Select(0, a.data.header.dataSetIds.map(function (id, i) { return [i, "".concat(id)]; })) : param_definition_1.ParamDefinition.Numeric(0);
        return {
            dataIndex: dataIndex,
            entryId: param_definition_1.ParamDefinition.Text(''),
        };
    }
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Create volume from Cube', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var volume, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, cube_1.volumeFromCube)(a.data, tslib_1.__assign(tslib_1.__assign({}, params), { label: a.data.name || a.label })).runInContext(ctx)];
                    case 1:
                        volume = _a.sent();
                        props = { label: volume.label || 'Volume', description: "Volume ".concat(a.data.header.dim[0], "\u00D7").concat(a.data.header.dim[1], "\u00D7").concat(a.data.header.dim[2]) };
                        return [2 /*return*/, new objects_1.PluginStateObject.Volume.Data(volume, props)];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customProperties.dispose();
    }
});
exports.VolumeFromCube = VolumeFromCube;
var VolumeFromDx = objects_1.PluginStateTransform.BuiltIn({
    name: 'volume-from-dx',
    display: { name: 'Parse DX', description: 'Create volume from DX data.' },
    from: objects_1.PluginStateObject.Format.Dx,
    to: objects_1.PluginStateObject.Volume.Data
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse DX', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var volume, props;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, dx_1.volumeFromDx)(a.data, { label: a.data.name || a.label }).runInContext(ctx)];
                    case 1:
                        volume = _a.sent();
                        props = { label: volume.label || 'Volume', description: "Volume ".concat(a.data.header.dim[0], "\u00D7").concat(a.data.header.dim[1], "\u00D7").concat(a.data.header.dim[2]) };
                        return [2 /*return*/, new objects_1.PluginStateObject.Volume.Data(volume, props)];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customProperties.dispose();
    }
});
exports.VolumeFromDx = VolumeFromDx;
var VolumeFromDensityServerCif = objects_1.PluginStateTransform.BuiltIn({
    name: 'volume-from-density-server-cif',
    display: { name: 'Volume from density-server CIF', description: 'Identify and create all separate models in the specified CIF data block' },
    from: objects_1.PluginStateObject.Format.Cif,
    to: objects_1.PluginStateObject.Volume.Data,
    params: function (a) {
        if (!a) {
            return {
                blockHeader: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text(void 0, { description: 'Header of the block to parse. If none is specifed, the 1st data block in the file is used.' })),
                entryId: param_definition_1.ParamDefinition.Text(''),
            };
        }
        var blocks = a.data.blocks.slice(1); // zero block contains query meta-data
        return {
            blockHeader: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Select(blocks[0] && blocks[0].header, blocks.map(function (b) { return [b.header, b.header]; }), { description: 'Header of the block to parse' })),
            entryId: param_definition_1.ParamDefinition.Text(''),
        };
    }
})({
    isApplicable: function (a) { return a.data.blocks.length > 0; },
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Parse density-server CIF', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var header, block, densityServerCif, volume, _a, x, y, z, props;
            var _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        header = params.blockHeader || a.data.blocks[1].header;
                        block = a.data.blocks.find(function (b) { return b.header === header; });
                        if (!block)
                            throw new Error("Data block '".concat([header], "' not found."));
                        densityServerCif = cif_1.CIF.schema.densityServer(block);
                        return [4 /*yield*/, (0, density_server_1.volumeFromDensityServerData)(densityServerCif, { entryId: params.entryId }).runInContext(ctx)];
                    case 1:
                        volume = _c.sent();
                        _a = volume.grid.cells.space.dimensions, x = _a[0], y = _a[1], z = _a[2];
                        props = { label: (_b = params.entryId) !== null && _b !== void 0 ? _b : densityServerCif.volume_data_3d_info.name.value(0), description: "Volume ".concat(x, "\u00D7").concat(y, "\u00D7").concat(z) };
                        return [2 /*return*/, new objects_1.PluginStateObject.Volume.Data(volume, props)];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customProperties.dispose();
    }
});
exports.VolumeFromDensityServerCif = VolumeFromDensityServerCif;
var VolumeFromSegmentationCif = objects_1.PluginStateTransform.BuiltIn({
    name: 'volume-from-segmentation-cif',
    display: { name: 'Volume from Segmentation CIF' },
    from: objects_1.PluginStateObject.Format.Cif,
    to: objects_1.PluginStateObject.Volume.Data,
    params: function (a) {
        var blocks = a === null || a === void 0 ? void 0 : a.data.blocks.slice(1);
        var blockHeaderParam = blocks ?
            param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Select(blocks[0] && blocks[0].header, blocks.map(function (b) { return [b.header, b.header]; }), { description: 'Header of the block to parse' }))
            : param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text(void 0, { description: 'Header of the block to parse. If none is specifed, the 1st data block in the file is used.' }));
        return {
            blockHeader: blockHeaderParam,
            segmentLabels: param_definition_1.ParamDefinition.ObjectList({ id: param_definition_1.ParamDefinition.Numeric(-1), label: param_definition_1.ParamDefinition.Text('') }, function (s) { return "".concat(s.id, " = ").concat(s.label); }, { description: 'Mapping of segment IDs to segment labels' }),
            ownerId: param_definition_1.ParamDefinition.Text('', { isHidden: true, description: 'Reference to the object which manages this volume' }),
        };
    }
})({
    isApplicable: function (a) { return a.data.blocks.length > 0; },
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Parse segmentation CIF', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var header, block, segmentationCif, segmentLabels, _i, _a, segment, volume, _b, x, y, z, props;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        header = params.blockHeader || a.data.blocks[1].header;
                        block = a.data.blocks.find(function (b) { return b.header === header; });
                        if (!block)
                            throw new Error("Data block '".concat([header], "' not found."));
                        segmentationCif = cif_1.CIF.schema.segmentation(block);
                        segmentLabels = {};
                        for (_i = 0, _a = params.segmentLabels; _i < _a.length; _i++) {
                            segment = _a[_i];
                            segmentLabels[segment.id] = segment.label;
                        }
                        return [4 /*yield*/, (0, segmentation_1.volumeFromSegmentationData)(segmentationCif, { segmentLabels: segmentLabels, ownerId: params.ownerId }).runInContext(ctx)];
                    case 1:
                        volume = _c.sent();
                        _b = volume.grid.cells.space.dimensions, x = _b[0], y = _b[1], z = _b[2];
                        props = { label: segmentationCif.volume_data_3d_info.name.value(0), description: "Segmentation ".concat(x, "\u00D7").concat(y, "\u00D7").concat(z) };
                        return [2 /*return*/, new objects_1.PluginStateObject.Volume.Data(volume, props)];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customProperties.dispose();
    }
});
exports.VolumeFromSegmentationCif = VolumeFromSegmentationCif;
var AssignColorVolume = objects_1.PluginStateTransform.BuiltIn({
    name: 'assign-color-volume',
    display: { name: 'Assign Color Volume', description: 'Assigns another volume to be available for coloring.' },
    from: objects_1.PluginStateObject.Volume.Data,
    to: objects_1.PluginStateObject.Volume.Data,
    isDecorator: true,
    params: function (a, plugin) {
        if (!a)
            return { ref: param_definition_1.ParamDefinition.Text() };
        var cells = plugin.state.data.select(mol_state_1.StateSelection.Generators.root.subtree().ofType(objects_1.PluginStateObject.Volume.Data).filter(function (cell) { var _a; return !!cell.obj && !((_a = cell.obj) === null || _a === void 0 ? void 0 : _a.data.colorVolume) && cell.obj !== a; }));
        if (cells.length === 0)
            return { ref: param_definition_1.ParamDefinition.Text('', { isHidden: true }) };
        return { ref: param_definition_1.ParamDefinition.Select(cells[0].transform.ref, cells.map(function (c) { return [c.transform.ref, c.obj.label]; })) };
    }
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params, dependencies = _a.dependencies;
        return mol_task_1.Task.create('Assign Color Volume', function (ctx) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var colorVolume, volume, props;
            return tslib_1.__generator(this, function (_a) {
                if (!dependencies || !dependencies[params.ref]) {
                    throw new Error('Dependency not available.');
                }
                colorVolume = dependencies[params.ref].data;
                volume = tslib_1.__assign(tslib_1.__assign({}, a.data), { colorVolume: colorVolume });
                props = { label: a.label, description: 'Volume + Colors' };
                return [2 /*return*/, new objects_1.PluginStateObject.Volume.Data(volume, props)];
            });
        }); });
    }
});
exports.AssignColorVolume = AssignColorVolume;
