"use strict";
/**
 * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.objectForEach = exports.mapObjectMap = exports.deepClone = exports.shallowMergeArray = exports.shallowMerge = exports.shallowEqual = exports.shallowMerge2 = exports.assignIfUndefined = void 0;
var hasOwnProperty = Object.prototype.hasOwnProperty;
/** Assign to the object if a given property in update is undefined */
function assignIfUndefined(to, full) {
    for (var _i = 0, _a = Object.keys(full); _i < _a.length; _i++) {
        var k = _a[_i];
        if (!hasOwnProperty.call(full, k))
            continue;
        if (typeof to[k] === 'undefined') {
            to[k] = full[k];
        }
    }
    return to;
}
exports.assignIfUndefined = assignIfUndefined;
/** Create new object if any property in "update" changes in "source". */
function shallowMerge2(source, update) {
    // Adapted from LiteMol (https://github.com/dsehnal/LiteMol)
    var changed = false;
    for (var _i = 0, _a = Object.keys(update); _i < _a.length; _i++) {
        var k = _a[_i];
        if (!hasOwnProperty.call(update, k))
            continue;
        if (update[k] !== source[k]) {
            changed = true;
            break;
        }
    }
    if (!changed)
        return source;
    return Object.assign({}, source, update);
}
exports.shallowMerge2 = shallowMerge2;
function shallowEqual(a, b) {
    if (!a) {
        if (!b)
            return true;
        return false;
    }
    if (!b)
        return false;
    var keys = Object.keys(a);
    if (Object.keys(b).length !== keys.length)
        return false;
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var k = keys_1[_i];
        if (!hasOwnProperty.call(a, k) || a[k] !== b[k])
            return false;
    }
    return true;
}
exports.shallowEqual = shallowEqual;
function shallowMerge(source) {
    var rest = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        rest[_i - 1] = arguments[_i];
    }
    return shallowMergeArray(source, rest);
}
exports.shallowMerge = shallowMerge;
function shallowMergeArray(source, rest) {
    // Adapted from LiteMol (https://github.com/dsehnal/LiteMol)
    var ret = source;
    for (var s = 0; s < rest.length; s++) {
        if (!rest[s])
            continue;
        ret = shallowMerge2(source, rest[s]);
        if (ret !== source) {
            for (var i = s + 1; i < rest.length; i++) {
                ret = Object.assign(ret, rest[i]);
            }
            break;
        }
    }
    return ret;
}
exports.shallowMergeArray = shallowMergeArray;
/** Simple deep clone for number, boolean, string, null, undefined, object, array */
function deepClone(source) {
    if (null === source || 'object' !== typeof source)
        return source;
    if (source instanceof Array) {
        var copy = [];
        for (var i = 0, len = source.length; i < len; i++) {
            copy[i] = deepClone(source[i]);
        }
        return copy;
    }
    // `instanceof Object` does not find `Object.create(null)`
    if (typeof source === 'object' && !('prototype' in source)) {
        var copy = {};
        for (var k in source) {
            if (hasOwnProperty.call(source, k))
                copy[k] = deepClone(source[k]);
        }
        return copy;
    }
    throw new Error("Can't clone, type \"".concat(typeof source, "\" unsupported"));
}
exports.deepClone = deepClone;
function mapObjectMap(o, f) {
    var ret = {};
    for (var _i = 0, _a = Object.keys(o); _i < _a.length; _i++) {
        var k = _a[_i];
        ret[k] = f(o[k]);
    }
    return ret;
}
exports.mapObjectMap = mapObjectMap;
function objectForEach(o, f) {
    if (!o)
        return;
    for (var _i = 0, _a = Object.keys(o); _i < _a.length; _i++) {
        var k = _a[_i];
        f(o[k], k);
    }
}
exports.objectForEach = objectForEach;
