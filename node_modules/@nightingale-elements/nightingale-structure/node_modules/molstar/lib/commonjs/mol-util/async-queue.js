"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncQueue = void 0;
var array_1 = require("./array");
var rxjs_1 = require("rxjs");
var AsyncQueue = /** @class */ (function () {
    function AsyncQueue() {
        this.queue = [];
        this.signal = new rxjs_1.Subject();
    }
    Object.defineProperty(AsyncQueue.prototype, "length", {
        get: function () { return this.queue.length; },
        enumerable: false,
        configurable: true
    });
    AsyncQueue.prototype.enqueue = function (v) {
        this.queue.push(v);
        if (this.queue.length === 1)
            return true;
        return this.waitFor(v);
    };
    AsyncQueue.prototype.handled = function (v) {
        (0, array_1.arrayRemoveInPlace)(this.queue, v);
        if (this.queue.length > 0) {
            this.signal.next({ v: this.queue[0], stillPresent: true });
        }
    };
    AsyncQueue.prototype.remove = function (v) {
        var rem = (0, array_1.arrayRemoveInPlace)(this.queue, v);
        if (rem)
            this.signal.next({ v: v, stillPresent: false });
        return rem;
    };
    AsyncQueue.prototype.waitFor = function (t) {
        var _this = this;
        return new Promise(function (res) {
            var sub = _this.signal.subscribe(function (_a) {
                var v = _a.v, removed = _a.stillPresent;
                if (v === t) {
                    sub.unsubscribe();
                    res(removed);
                }
            });
        });
    };
    return AsyncQueue;
}());
exports.AsyncQueue = AsyncQueue;
