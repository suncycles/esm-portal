"use strict";
/**
 * Copyright (c) 2018-2023 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Gianluca Tomasello <giagitom@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Canvas3D = exports.Canvas3DContext = exports.DefaultCanvas3DParams = exports.Canvas3DParams = void 0;
var tslib_1 = require("tslib");
var rxjs_1 = require("rxjs");
var now_1 = require("../mol-util/now");
var linear_algebra_1 = require("../mol-math/linear-algebra");
var input_observer_1 = require("../mol-util/input/input-observer");
var renderer_1 = require("../mol-gl/renderer");
var trackball_1 = require("./controls/trackball");
var util_1 = require("./camera/util");
var context_1 = require("../mol-gl/webgl/context");
var representation_1 = require("../mol-repr/representation");
var scene_1 = require("../mol-gl/scene");
var loci_1 = require("../mol-model/loci");
var camera_1 = require("./camera");
var param_definition_1 = require("../mol-util/param-definition");
var bounding_sphere_helper_1 = require("./helper/bounding-sphere-helper");
var set_1 = require("../mol-util/set");
var interaction_events_1 = require("./helper/interaction-events");
var postprocessing_1 = require("./passes/postprocessing");
var multi_sample_1 = require("./passes/multi-sample");
var pick_1 = require("./passes/pick");
var image_1 = require("./passes/image");
var geometry_1 = require("../mol-math/geometry");
var debug_1 = require("../mol-util/debug");
var camera_helper_1 = require("./helper/camera-helper");
var immer_1 = require("immer");
var handle_helper_1 = require("./helper/handle-helper");
var stereo_1 = require("./camera/stereo");
var helper_1 = require("./helper/helper");
var passes_1 = require("./passes/passes");
var mol_util_1 = require("../mol-util");
var marking_1 = require("./passes/marking");
var render_item_1 = require("../mol-gl/webgl/render-item");
var misc_1 = require("../mol-math/misc");
var object_1 = require("../mol-util/object");
exports.Canvas3DParams = {
    camera: param_definition_1.ParamDefinition.Group({
        mode: param_definition_1.ParamDefinition.Select('perspective', param_definition_1.ParamDefinition.arrayToOptions(['perspective', 'orthographic']), { label: 'Camera' }),
        helper: param_definition_1.ParamDefinition.Group(camera_helper_1.CameraHelperParams, { isFlat: true }),
        stereo: param_definition_1.ParamDefinition.MappedStatic('off', {
            on: param_definition_1.ParamDefinition.Group(stereo_1.StereoCameraParams),
            off: param_definition_1.ParamDefinition.Group({})
        }, { cycle: true, hideIf: function (p) { return (p === null || p === void 0 ? void 0 : p.mode) !== 'perspective'; } }),
        fov: param_definition_1.ParamDefinition.Numeric(45, { min: 10, max: 130, step: 1 }, { label: 'Field of View' }),
        manualReset: param_definition_1.ParamDefinition.Boolean(false, { isHidden: true }),
    }, { pivot: 'mode' }),
    cameraFog: param_definition_1.ParamDefinition.MappedStatic('on', {
        on: param_definition_1.ParamDefinition.Group({
            intensity: param_definition_1.ParamDefinition.Numeric(15, { min: 1, max: 100, step: 1 }),
        }),
        off: param_definition_1.ParamDefinition.Group({})
    }, { cycle: true, description: 'Show fog in the distance' }),
    cameraClipping: param_definition_1.ParamDefinition.Group({
        radius: param_definition_1.ParamDefinition.Numeric(100, { min: 0, max: 99, step: 1 }, { label: 'Clipping', description: 'How much of the scene to show.' }),
        far: param_definition_1.ParamDefinition.Boolean(true, { description: 'Hide scene in the distance' }),
        minNear: param_definition_1.ParamDefinition.Numeric(5, { min: 0.1, max: 100, step: 0.1 }, { description: 'Note, may cause performance issues rendering impostors when set too small and cause issues with outline rendering when too close to 0.' }),
    }, { pivot: 'radius' }),
    viewport: param_definition_1.ParamDefinition.MappedStatic('canvas', {
        canvas: param_definition_1.ParamDefinition.Group({}),
        'static-frame': param_definition_1.ParamDefinition.Group({
            x: param_definition_1.ParamDefinition.Numeric(0),
            y: param_definition_1.ParamDefinition.Numeric(0),
            width: param_definition_1.ParamDefinition.Numeric(128),
            height: param_definition_1.ParamDefinition.Numeric(128)
        }),
        'relative-frame': param_definition_1.ParamDefinition.Group({
            x: param_definition_1.ParamDefinition.Numeric(0.33, { min: 0, max: 1, step: 0.01 }),
            y: param_definition_1.ParamDefinition.Numeric(0.33, { min: 0, max: 1, step: 0.01 }),
            width: param_definition_1.ParamDefinition.Numeric(0.5, { min: 0.01, max: 1, step: 0.01 }),
            height: param_definition_1.ParamDefinition.Numeric(0.5, { min: 0.01, max: 1, step: 0.01 })
        })
    }),
    cameraResetDurationMs: param_definition_1.ParamDefinition.Numeric(250, { min: 0, max: 1000, step: 1 }, { description: 'The time it takes to reset the camera.' }),
    sceneRadiusFactor: param_definition_1.ParamDefinition.Numeric(1, { min: 1, max: 10, step: 0.1 }),
    transparentBackground: param_definition_1.ParamDefinition.Boolean(false),
    dpoitIterations: param_definition_1.ParamDefinition.Numeric(2, { min: 1, max: 10, step: 1 }),
    multiSample: param_definition_1.ParamDefinition.Group(multi_sample_1.MultiSampleParams),
    postprocessing: param_definition_1.ParamDefinition.Group(postprocessing_1.PostprocessingParams),
    marking: param_definition_1.ParamDefinition.Group(marking_1.MarkingParams),
    renderer: param_definition_1.ParamDefinition.Group(renderer_1.RendererParams),
    trackball: param_definition_1.ParamDefinition.Group(trackball_1.TrackballControlsParams),
    interaction: param_definition_1.ParamDefinition.Group(interaction_events_1.Canvas3dInteractionHelperParams),
    debug: param_definition_1.ParamDefinition.Group(bounding_sphere_helper_1.DebugHelperParams),
    handle: param_definition_1.ParamDefinition.Group(handle_helper_1.HandleHelperParams),
};
exports.DefaultCanvas3DParams = param_definition_1.ParamDefinition.getDefaultValues(exports.Canvas3DParams);
var Canvas3DContext;
(function (Canvas3DContext) {
    Canvas3DContext.DefaultAttribs = {
        powerPreference: 'high-performance',
        failIfMajorPerformanceCaveat: false,
        /** true by default to avoid issues with Safari (Jan 2021) */
        antialias: true,
        /** true to support multiple Canvas3D objects with a single context */
        preserveDrawingBuffer: true,
        pixelScale: 1,
        pickScale: 0.25,
        /** extra pixels to around target to check in case target is empty */
        pickPadding: 1,
        enableWboit: true,
        enableDpoit: false,
        preferWebGl1: false
    };
    function fromCanvas(canvas, assetManager, attribs) {
        if (attribs === void 0) { attribs = {}; }
        var a = tslib_1.__assign(tslib_1.__assign({}, Canvas3DContext.DefaultAttribs), attribs);
        if (a.enableWboit && a.enableDpoit)
            throw new Error('Multiple transparency methods not allowed.');
        var powerPreference = a.powerPreference, failIfMajorPerformanceCaveat = a.failIfMajorPerformanceCaveat, antialias = a.antialias, preserveDrawingBuffer = a.preserveDrawingBuffer, pixelScale = a.pixelScale, preferWebGl1 = a.preferWebGl1;
        var gl = (0, context_1.getGLContext)(canvas, {
            powerPreference: powerPreference,
            failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat,
            antialias: antialias,
            preserveDrawingBuffer: preserveDrawingBuffer,
            alpha: true,
            depth: true,
            premultipliedAlpha: true,
            preferWebGl1: preferWebGl1
        });
        if (gl === null)
            throw new Error('Could not create a WebGL rendering context');
        var input = input_observer_1.InputObserver.fromElement(canvas, { pixelScale: pixelScale, preventGestures: true });
        var webgl = (0, context_1.createContext)(gl, { pixelScale: pixelScale });
        var passes = new passes_1.Passes(webgl, assetManager, a);
        if (debug_1.isDebugMode) {
            var loseContextExt_1 = gl.getExtension('WEBGL_lose_context');
            if (loseContextExt_1) {
                // Hold down shift+ctrl+alt and press any mouse button to call `loseContext`.
                // After 1 second `restoreContext` will be called.
                canvas.addEventListener('mousedown', function (e) {
                    if (webgl.isContextLost)
                        return;
                    if (!e.shiftKey || !e.ctrlKey || !e.altKey)
                        return;
                    if (debug_1.isDebugMode)
                        console.log('lose context');
                    loseContextExt_1.loseContext();
                    setTimeout(function () {
                        if (!webgl.isContextLost)
                            return;
                        if (debug_1.isDebugMode)
                            console.log('restore context');
                        loseContextExt_1.restoreContext();
                    }, 1000);
                }, false);
            }
        }
        // https://www.khronos.org/webgl/wiki/HandlingContextLost
        var contextLost = new rxjs_1.BehaviorSubject(0);
        var handleWebglContextLost = function (e) {
            webgl.setContextLost();
            e.preventDefault();
            if (debug_1.isDebugMode)
                console.log('context lost');
            contextLost.next((0, now_1.now)());
        };
        var handlewWebglContextRestored = function () {
            if (!webgl.isContextLost)
                return;
            webgl.handleContextRestored(function () {
                passes.draw.reset();
            });
            if (debug_1.isDebugMode)
                console.log('context restored');
        };
        canvas.addEventListener('webglcontextlost', handleWebglContextLost, false);
        canvas.addEventListener('webglcontextrestored', handlewWebglContextRestored, false);
        return {
            canvas: canvas,
            webgl: webgl,
            input: input,
            passes: passes,
            attribs: a,
            contextLost: contextLost,
            contextRestored: webgl.contextRestored,
            assetManager: assetManager,
            dispose: function (options) {
                input.dispose();
                canvas.removeEventListener('webglcontextlost', handleWebglContextLost, false);
                canvas.removeEventListener('webglcontextrestored', handlewWebglContextRestored, false);
                webgl.destroy(options);
            }
        };
    }
    Canvas3DContext.fromCanvas = fromCanvas;
})(Canvas3DContext || (Canvas3DContext = {}));
exports.Canvas3DContext = Canvas3DContext;
var requestAnimationFrame = typeof window !== 'undefined'
    ? window.requestAnimationFrame
    : function (f) { return setImmediate(function () { return f(Date.now()); }); };
var cancelAnimationFrame = typeof window !== 'undefined'
    ? window.cancelAnimationFrame
    : function (handle) { return clearImmediate(handle); };
var Canvas3D;
(function (Canvas3D) {
    function create(_a, props) {
        var webgl = _a.webgl, input = _a.input, passes = _a.passes, attribs = _a.attribs, assetManager = _a.assetManager;
        if (props === void 0) { props = {}; }
        var p = tslib_1.__assign(tslib_1.__assign({}, (0, object_1.deepClone)(exports.DefaultCanvas3DParams)), (0, object_1.deepClone)(props));
        var reprRenderObjects = new Map();
        var reprUpdatedSubscriptions = new Map();
        var reprCount = new rxjs_1.BehaviorSubject(0);
        var startTime = (0, now_1.now)();
        var didDraw = new rxjs_1.BehaviorSubject(0);
        var commited = new rxjs_1.BehaviorSubject(0);
        var commitQueueSize = new rxjs_1.BehaviorSubject(0);
        var gl = webgl.gl, contextRestored = webgl.contextRestored;
        var x = 0;
        var y = 0;
        var width = 128;
        var height = 128;
        updateViewport();
        var scene = scene_1.Scene.create(webgl, passes.draw.dpoitEnabled ? render_item_1.GraphicsRenderVariantsDpoit : (passes.draw.wboitEnabled ? render_item_1.GraphicsRenderVariantsWboit : render_item_1.GraphicsRenderVariantsBlended));
        function getSceneRadius() {
            return scene.boundingSphere.radius * p.sceneRadiusFactor;
        }
        var camera = new camera_1.Camera({
            position: linear_algebra_1.Vec3.create(0, 0, 100),
            mode: p.camera.mode,
            fog: p.cameraFog.name === 'on' ? p.cameraFog.params.intensity : 0,
            clipFar: p.cameraClipping.far,
            minNear: p.cameraClipping.minNear,
            fov: (0, misc_1.degToRad)(p.camera.fov),
        }, { x: x, y: y, width: width, height: height }, { pixelScale: attribs.pixelScale });
        var stereoCamera = new stereo_1.StereoCamera(camera, p.camera.stereo.params);
        var controls = trackball_1.TrackballControls.create(input, camera, scene, p.trackball);
        var renderer = renderer_1.Renderer.create(webgl, p.renderer);
        var helper = new helper_1.Helper(webgl, scene, p);
        var pickHelper = new pick_1.PickHelper(webgl, renderer, scene, helper, passes.pick, { x: x, y: y, width: width, height: height }, attribs.pickPadding);
        var interactionHelper = new interaction_events_1.Canvas3dInteractionHelper(identify, getLoci, input, camera, controls, p.interaction);
        var multiSampleHelper = new multi_sample_1.MultiSampleHelper(passes.multiSample);
        passes.draw.postprocessing.background.update(camera, p.postprocessing.background, function (changed) {
            if (changed)
                requestDraw();
        });
        var cameraResetRequested = false;
        var nextCameraResetDuration = void 0;
        var nextCameraResetSnapshot = void 0;
        var resizeRequested = false;
        var notifyDidDraw = true;
        function getLoci(pickingId) {
            var loci = loci_1.EmptyLoci;
            var repr = representation_1.Representation.Empty;
            if (pickingId) {
                var cameraHelperLoci = helper.camera.getLoci(pickingId);
                if (cameraHelperLoci !== loci_1.EmptyLoci)
                    return { loci: cameraHelperLoci, repr: repr };
                loci = helper.handle.getLoci(pickingId);
                reprRenderObjects.forEach(function (_, _repr) {
                    var _loci = _repr.getLoci(pickingId);
                    if (!(0, loci_1.isEmptyLoci)(_loci)) {
                        if (!(0, loci_1.isEmptyLoci)(loci)) {
                            console.warn('found another loci, this should not happen');
                        }
                        loci = _loci;
                        repr = _repr;
                    }
                });
            }
            return { loci: loci, repr: repr };
        }
        var markBuffer = [];
        function mark(reprLoci, action) {
            // NOTE: might try to optimize a case with opposite actions for the
            //       same loci. Tho this might end up being more expensive (and error prone)
            //       then just applying everything "naively".
            markBuffer.push([reprLoci, action]);
        }
        function resolveMarking() {
            var changed = false;
            for (var _i = 0, markBuffer_1 = markBuffer; _i < markBuffer_1.length; _i++) {
                var _a = markBuffer_1[_i], r = _a[0], l = _a[1];
                changed = applyMark(r, l) || changed;
            }
            markBuffer = [];
            if (changed) {
                scene.update(void 0, true);
                helper.handle.scene.update(void 0, true);
                helper.camera.scene.update(void 0, true);
            }
            return changed;
        }
        function applyMark(reprLoci, action) {
            var repr = reprLoci.repr, loci = reprLoci.loci;
            var changed = false;
            if (repr) {
                changed = repr.mark(loci, action) || changed;
            }
            else {
                reprRenderObjects.forEach(function (_, _repr) { changed = _repr.mark(loci, action) || changed; });
            }
            changed = helper.handle.mark(loci, action) || changed;
            changed = helper.camera.mark(loci, action) || changed;
            return changed;
        }
        function render(force) {
            if (webgl.isContextLost)
                return false;
            var resized = false;
            if (resizeRequested) {
                handleResize(false);
                resizeRequested = false;
                resized = true;
            }
            if (x > gl.drawingBufferWidth || x + width < 0 ||
                y > gl.drawingBufferHeight || y + height < 0)
                return false;
            var markingUpdated = resolveMarking() && (renderer.props.colorMarker || p.marking.enabled);
            var didRender = false;
            controls.update(currentTime);
            var cameraChanged = camera.update();
            var shouldRender = force || cameraChanged || resized || forceNextRender;
            forceNextRender = false;
            var multiSampleChanged = multiSampleHelper.update(markingUpdated || shouldRender, p.multiSample);
            if (shouldRender || multiSampleChanged || markingUpdated) {
                var cam = camera;
                if (p.camera.stereo.name === 'on') {
                    stereoCamera.update();
                    cam = stereoCamera;
                }
                if (debug_1.isTimingMode)
                    webgl.timer.mark('Canvas3D.render', true);
                var ctx = { renderer: renderer, camera: cam, scene: scene, helper: helper };
                if (multi_sample_1.MultiSamplePass.isEnabled(p.multiSample)) {
                    var forceOn = !cameraChanged && markingUpdated && !controls.isAnimating;
                    multiSampleHelper.render(ctx, p, true, forceOn);
                }
                else {
                    passes.draw.render(ctx, p, true);
                }
                if (debug_1.isTimingMode)
                    webgl.timer.markEnd('Canvas3D.render');
                // if only marking has updated, do not set the flag to dirty
                pickHelper.dirty = pickHelper.dirty || shouldRender;
                didRender = true;
            }
            return didRender;
        }
        var forceNextRender = false;
        var forceDrawAfterAllCommited = false;
        var currentTime = 0;
        var drawPaused = false;
        function draw(options) {
            if (drawPaused)
                return;
            if (render(!!(options === null || options === void 0 ? void 0 : options.force)) && notifyDidDraw) {
                didDraw.next((0, now_1.now)() - startTime);
            }
        }
        function requestDraw() {
            forceNextRender = true;
        }
        var animationFrameHandle = 0;
        function tick(t, options) {
            currentTime = t;
            commit(options === null || options === void 0 ? void 0 : options.isSynchronous);
            camera.transition.tick(currentTime);
            if (options === null || options === void 0 ? void 0 : options.manualDraw) {
                return;
            }
            draw();
            if (!camera.transition.inTransition && !webgl.isContextLost) {
                interactionHelper.tick(currentTime);
            }
        }
        function _animate() {
            tick((0, now_1.now)());
            animationFrameHandle = requestAnimationFrame(_animate);
        }
        function resetTime(t) {
            startTime = t;
            controls.start(t);
        }
        function animate() {
            drawPaused = false;
            controls.start((0, now_1.now)());
            if (animationFrameHandle === 0)
                _animate();
        }
        function pause(noDraw) {
            if (noDraw === void 0) { noDraw = false; }
            drawPaused = noDraw;
            cancelAnimationFrame(animationFrameHandle);
            animationFrameHandle = 0;
        }
        function identify(x, y) {
            var cam = p.camera.stereo.name === 'on' ? stereoCamera : camera;
            return webgl.isContextLost ? undefined : pickHelper.identify(x, y, cam);
        }
        function commit(isSynchronous) {
            if (isSynchronous === void 0) { isSynchronous = false; }
            var allCommited = commitScene(isSynchronous);
            // Only reset the camera after the full scene has been commited.
            if (allCommited) {
                resolveCameraReset();
                if (forceDrawAfterAllCommited) {
                    if (helper.debug.isEnabled)
                        helper.debug.update();
                    draw({ force: true });
                    forceDrawAfterAllCommited = false;
                }
                commited.next((0, now_1.now)());
            }
        }
        function resolveCameraReset() {
            if (!cameraResetRequested)
                return;
            var boundingSphere = scene.boundingSphereVisible;
            var center = boundingSphere.center, radius = boundingSphere.radius;
            var autoAdjustControls = controls.props.autoAdjustMinMaxDistance;
            if (autoAdjustControls.name === 'on') {
                var minDistance = autoAdjustControls.params.minDistanceFactor * radius + autoAdjustControls.params.minDistancePadding;
                var maxDistance = Math.max(autoAdjustControls.params.maxDistanceFactor * radius, autoAdjustControls.params.maxDistanceMin);
                controls.setProps({ minDistance: minDistance, maxDistance: maxDistance });
            }
            if (radius > 0) {
                var duration = nextCameraResetDuration === undefined ? p.cameraResetDurationMs : nextCameraResetDuration;
                var focus_1 = camera.getFocus(center, radius);
                var next = typeof nextCameraResetSnapshot === 'function' ? nextCameraResetSnapshot(scene, camera) : nextCameraResetSnapshot;
                var snapshot = next ? tslib_1.__assign(tslib_1.__assign({}, focus_1), next) : focus_1;
                camera.setState(tslib_1.__assign(tslib_1.__assign({}, snapshot), { radiusMax: getSceneRadius() }), duration);
            }
            nextCameraResetDuration = void 0;
            nextCameraResetSnapshot = void 0;
            cameraResetRequested = false;
        }
        var oldBoundingSphereVisible = (0, geometry_1.Sphere3D)();
        var cameraSphere = (0, geometry_1.Sphere3D)();
        function shouldResetCamera() {
            if (camera.state.radiusMax === 0)
                return true;
            if (camera.transition.inTransition || nextCameraResetSnapshot)
                return false;
            var cameraSphereOverlapsNone = true, isEmpty = true;
            geometry_1.Sphere3D.set(cameraSphere, camera.state.target, camera.state.radius);
            // check if any renderable has moved outside of the old bounding sphere
            // and if no renderable is overlapping with the camera sphere
            for (var _i = 0, _a = scene.renderables; _i < _a.length; _i++) {
                var r = _a[_i];
                if (!r.state.visible)
                    continue;
                var b = r.values.boundingSphere.ref.value;
                if (!b.radius)
                    continue;
                isEmpty = false;
                var cameraDist = linear_algebra_1.Vec3.distance(cameraSphere.center, b.center);
                if ((cameraDist > cameraSphere.radius || cameraDist > b.radius || b.radius > camera.state.radiusMax) && !geometry_1.Sphere3D.includes(oldBoundingSphereVisible, b))
                    return true;
                if (geometry_1.Sphere3D.overlaps(cameraSphere, b))
                    cameraSphereOverlapsNone = false;
            }
            return cameraSphereOverlapsNone || (!isEmpty && cameraSphere.radius <= 0.1);
        }
        var sceneCommitTimeoutMs = 250;
        function commitScene(isSynchronous) {
            if (!scene.needsCommit)
                return true;
            // snapshot the current bounding sphere of visible objects
            geometry_1.Sphere3D.copy(oldBoundingSphereVisible, scene.boundingSphereVisible);
            if (!scene.commit(isSynchronous ? void 0 : sceneCommitTimeoutMs)) {
                commitQueueSize.next(scene.commitQueueSize);
                return false;
            }
            commitQueueSize.next(0);
            if (helper.debug.isEnabled)
                helper.debug.update();
            if (!p.camera.manualReset && (reprCount.value === 0 || shouldResetCamera())) {
                cameraResetRequested = true;
            }
            if (oldBoundingSphereVisible.radius === 0)
                nextCameraResetDuration = 0;
            if (!p.camera.manualReset)
                camera.setState({ radiusMax: getSceneRadius() }, 0);
            reprCount.next(reprRenderObjects.size);
            if (debug_1.isDebugMode)
                consoleStats();
            return true;
        }
        function consoleStats() {
            var items = scene.renderables.map(function (r) { return ({
                drawCount: r.values.drawCount.ref.value,
                instanceCount: r.values.instanceCount.ref.value,
                materialId: r.materialId,
                renderItemId: r.id,
            }); });
            console.groupCollapsed("".concat(items.length, " RenderItems"));
            if (items.length < 50) {
                console.table(items);
            }
            else {
                console.log(items);
            }
            console.log(JSON.stringify(webgl.stats, undefined, 4));
            var _a = webgl.resources.getByteCounts(), texture = _a.texture, attribute = _a.attribute, elements = _a.elements;
            console.log(JSON.stringify({
                texture: "".concat((texture / 1024 / 1024).toFixed(3), " MiB"),
                attribute: "".concat((attribute / 1024 / 1024).toFixed(3), " MiB"),
                elements: "".concat((elements / 1024 / 1024).toFixed(3), " MiB"),
            }, undefined, 4));
            console.log(JSON.stringify(webgl.timer.formatedStats(), undefined, 4));
            console.groupEnd();
        }
        function add(repr) {
            registerAutoUpdate(repr);
            var oldRO = reprRenderObjects.get(repr);
            var newRO = new Set();
            repr.renderObjects.forEach(function (o) { return newRO.add(o); });
            if (oldRO) {
                if (!set_1.SetUtils.areEqual(newRO, oldRO)) {
                    newRO.forEach(function (o) { if (!oldRO.has(o))
                        scene.add(o); });
                    oldRO.forEach(function (o) { if (!newRO.has(o))
                        scene.remove(o); });
                }
            }
            else {
                repr.renderObjects.forEach(function (o) { return scene.add(o); });
            }
            reprRenderObjects.set(repr, newRO);
            scene.update(repr.renderObjects, false);
            forceDrawAfterAllCommited = true;
            if (debug_1.isDebugMode)
                consoleStats();
        }
        function remove(repr) {
            unregisterAutoUpdate(repr);
            var renderObjects = reprRenderObjects.get(repr);
            if (renderObjects) {
                renderObjects.forEach(function (o) { return scene.remove(o); });
                reprRenderObjects.delete(repr);
                forceDrawAfterAllCommited = true;
                if (debug_1.isDebugMode)
                    consoleStats();
            }
        }
        function registerAutoUpdate(repr) {
            if (reprUpdatedSubscriptions.has(repr))
                return;
            reprUpdatedSubscriptions.set(repr, repr.updated.subscribe(function (_) {
                if (!repr.state.syncManually)
                    add(repr);
            }));
        }
        function unregisterAutoUpdate(repr) {
            var updatedSubscription = reprUpdatedSubscriptions.get(repr);
            if (updatedSubscription) {
                updatedSubscription.unsubscribe();
                reprUpdatedSubscriptions.delete(repr);
            }
        }
        function getProps() {
            var radius = scene.boundingSphere.radius > 0
                ? 100 - Math.round((camera.transition.target.radius / getSceneRadius()) * 100)
                : 0;
            return {
                camera: {
                    mode: camera.state.mode,
                    helper: tslib_1.__assign({}, helper.camera.props),
                    stereo: tslib_1.__assign({}, p.camera.stereo),
                    fov: Math.round((0, misc_1.radToDeg)(camera.state.fov)),
                    manualReset: !!p.camera.manualReset
                },
                cameraFog: camera.state.fog > 0
                    ? { name: 'on', params: { intensity: camera.state.fog } }
                    : { name: 'off', params: {} },
                cameraClipping: { far: camera.state.clipFar, radius: radius, minNear: camera.state.minNear },
                cameraResetDurationMs: p.cameraResetDurationMs,
                sceneRadiusFactor: p.sceneRadiusFactor,
                transparentBackground: p.transparentBackground,
                dpoitIterations: p.dpoitIterations,
                viewport: p.viewport,
                postprocessing: tslib_1.__assign({}, p.postprocessing),
                marking: tslib_1.__assign({}, p.marking),
                multiSample: tslib_1.__assign({}, p.multiSample),
                renderer: tslib_1.__assign({}, renderer.props),
                trackball: tslib_1.__assign({}, controls.props),
                interaction: tslib_1.__assign({}, interactionHelper.props),
                debug: tslib_1.__assign({}, helper.debug.props),
                handle: tslib_1.__assign({}, helper.handle.props),
            };
        }
        var contextRestoredSub = contextRestored.subscribe(function () {
            pickHelper.dirty = true;
            draw({ force: true });
            // Unclear why, but in Chrome with wboit enabled the first `draw` only clears
            // the drawingBuffer. Note that in Firefox the drawingBuffer is preserved after
            // context loss so it is unclear if it behaves the same.
            draw({ force: true });
        });
        var resized = new rxjs_1.BehaviorSubject(0);
        function handleResize(draw) {
            if (draw === void 0) { draw = true; }
            passes.updateSize();
            updateViewport();
            syncViewport();
            if (draw)
                requestDraw();
            resized.next(+new Date());
        }
        (0, debug_1.addConsoleStatsProvider)(consoleStats);
        return {
            webgl: webgl,
            add: add,
            remove: remove,
            commit: commit,
            update: function (repr, keepSphere) {
                if (repr) {
                    if (!reprRenderObjects.has(repr))
                        return;
                    scene.update(repr.renderObjects, !!keepSphere);
                }
                else {
                    scene.update(void 0, !!keepSphere);
                }
                forceDrawAfterAllCommited = true;
            },
            clear: function () {
                reprUpdatedSubscriptions.forEach(function (v) { return v.unsubscribe(); });
                reprUpdatedSubscriptions.clear();
                reprRenderObjects.clear();
                scene.clear();
                helper.debug.clear();
                requestDraw();
                reprCount.next(reprRenderObjects.size);
            },
            syncVisibility: function () {
                if (camera.state.radiusMax === 0) {
                    cameraResetRequested = true;
                    nextCameraResetDuration = 0;
                }
                if (scene.syncVisibility()) {
                    if (helper.debug.isEnabled)
                        helper.debug.update();
                }
                requestDraw();
            },
            requestDraw: requestDraw,
            tick: tick,
            animate: animate,
            resetTime: resetTime,
            pause: pause,
            resume: function () { drawPaused = false; },
            identify: identify,
            mark: mark,
            getLoci: getLoci,
            handleResize: handleResize,
            requestResize: function () {
                resizeRequested = true;
            },
            requestCameraReset: function (options) {
                nextCameraResetDuration = options === null || options === void 0 ? void 0 : options.durationMs;
                nextCameraResetSnapshot = options === null || options === void 0 ? void 0 : options.snapshot;
                cameraResetRequested = true;
            },
            camera: camera,
            boundingSphere: scene.boundingSphere,
            boundingSphereVisible: scene.boundingSphereVisible,
            get notifyDidDraw() { return notifyDidDraw; },
            set notifyDidDraw(v) { notifyDidDraw = v; },
            didDraw: didDraw,
            commited: commited,
            commitQueueSize: commitQueueSize,
            reprCount: reprCount,
            resized: resized,
            setProps: function (properties, doNotRequestDraw) {
                var _a, _b, _c, _d;
                if (doNotRequestDraw === void 0) { doNotRequestDraw = false; }
                var props = typeof properties === 'function'
                    ? (0, immer_1.produce)(getProps(), properties)
                    : properties;
                if (props.sceneRadiusFactor !== undefined) {
                    p.sceneRadiusFactor = props.sceneRadiusFactor;
                    camera.setState({ radiusMax: getSceneRadius() }, 0);
                }
                var cameraState = Object.create(null);
                if (props.camera && props.camera.mode !== undefined && props.camera.mode !== camera.state.mode) {
                    cameraState.mode = props.camera.mode;
                }
                var oldFov = Math.round((0, misc_1.radToDeg)(camera.state.fov));
                if (props.camera && props.camera.fov !== undefined && props.camera.fov !== oldFov) {
                    cameraState.fov = (0, misc_1.degToRad)(props.camera.fov);
                }
                if (props.cameraFog !== undefined && props.cameraFog.params) {
                    var newFog = props.cameraFog.name === 'on' ? props.cameraFog.params.intensity : 0;
                    if (newFog !== camera.state.fog)
                        cameraState.fog = newFog;
                }
                if (props.cameraClipping !== undefined) {
                    if (props.cameraClipping.far !== undefined && props.cameraClipping.far !== camera.state.clipFar) {
                        cameraState.clipFar = props.cameraClipping.far;
                    }
                    if (props.cameraClipping.minNear !== undefined && props.cameraClipping.minNear !== camera.state.minNear) {
                        cameraState.minNear = props.cameraClipping.minNear;
                    }
                    if (props.cameraClipping.radius !== undefined) {
                        var radius = (getSceneRadius() / 100) * (100 - props.cameraClipping.radius);
                        if (radius > 0 && radius !== cameraState.radius) {
                            // if radius = 0, NaNs happen
                            cameraState.radius = Math.max(radius, 0.01);
                        }
                    }
                }
                if (Object.keys(cameraState).length > 0)
                    camera.setState(cameraState);
                if ((_a = props.camera) === null || _a === void 0 ? void 0 : _a.helper)
                    helper.camera.setProps(props.camera.helper);
                if (((_b = props.camera) === null || _b === void 0 ? void 0 : _b.manualReset) !== undefined)
                    p.camera.manualReset = props.camera.manualReset;
                if (((_c = props.camera) === null || _c === void 0 ? void 0 : _c.stereo) !== undefined) {
                    Object.assign(p.camera.stereo, props.camera.stereo);
                    stereoCamera.setProps(p.camera.stereo.params);
                }
                if (props.cameraResetDurationMs !== undefined)
                    p.cameraResetDurationMs = props.cameraResetDurationMs;
                if (props.transparentBackground !== undefined)
                    p.transparentBackground = props.transparentBackground;
                if (props.dpoitIterations !== undefined)
                    p.dpoitIterations = props.dpoitIterations;
                if (props.viewport !== undefined) {
                    var doNotUpdate = p.viewport === props.viewport ||
                        (p.viewport.name === props.viewport.name && (0, mol_util_1.shallowEqual)(p.viewport.params, props.viewport.params));
                    if (!doNotUpdate) {
                        p.viewport = props.viewport;
                        updateViewport();
                        syncViewport();
                    }
                }
                if ((_d = props.postprocessing) === null || _d === void 0 ? void 0 : _d.background) {
                    Object.assign(p.postprocessing.background, props.postprocessing.background);
                    passes.draw.postprocessing.background.update(camera, p.postprocessing.background, function (changed) {
                        if (changed && !doNotRequestDraw)
                            requestDraw();
                    });
                }
                if (props.postprocessing)
                    Object.assign(p.postprocessing, props.postprocessing);
                if (props.marking)
                    Object.assign(p.marking, props.marking);
                if (props.multiSample)
                    Object.assign(p.multiSample, props.multiSample);
                if (props.renderer)
                    renderer.setProps(props.renderer);
                if (props.trackball)
                    controls.setProps(props.trackball);
                if (props.interaction)
                    interactionHelper.setProps(props.interaction);
                if (props.debug)
                    helper.debug.setProps(props.debug);
                if (props.handle)
                    helper.handle.setProps(props.handle);
                if (cameraState.mode === 'orthographic') {
                    p.camera.stereo.name = 'off';
                }
                if (!doNotRequestDraw) {
                    requestDraw();
                }
            },
            getImagePass: function (props) {
                if (props === void 0) { props = {}; }
                return new image_1.ImagePass(webgl, assetManager, renderer, scene, camera, helper, passes.draw.wboitEnabled, passes.draw.dpoitEnabled, props);
            },
            getRenderObjects: function () {
                var renderObjects = [];
                scene.forEach(function (_, ro) { return renderObjects.push(ro); });
                return renderObjects;
            },
            get props() {
                return getProps();
            },
            get input() {
                return input;
            },
            get stats() {
                return renderer.stats;
            },
            get interaction() {
                return interactionHelper.events;
            },
            dispose: function () {
                contextRestoredSub.unsubscribe();
                cancelAnimationFrame(animationFrameHandle);
                markBuffer = [];
                scene.clear();
                helper.debug.clear();
                controls.dispose();
                renderer.dispose();
                interactionHelper.dispose();
                (0, debug_1.removeConsoleStatsProvider)(consoleStats);
            }
        };
        function updateViewport() {
            var oldX = x, oldY = y, oldWidth = width, oldHeight = height;
            if (p.viewport.name === 'canvas') {
                x = 0;
                y = 0;
                width = gl.drawingBufferWidth;
                height = gl.drawingBufferHeight;
            }
            else if (p.viewport.name === 'static-frame') {
                x = p.viewport.params.x * webgl.pixelRatio;
                height = p.viewport.params.height * webgl.pixelRatio;
                y = gl.drawingBufferHeight - height - p.viewport.params.y * webgl.pixelRatio;
                width = p.viewport.params.width * webgl.pixelRatio;
            }
            else if (p.viewport.name === 'relative-frame') {
                x = Math.round(p.viewport.params.x * gl.drawingBufferWidth);
                height = Math.round(p.viewport.params.height * gl.drawingBufferHeight);
                y = Math.round(gl.drawingBufferHeight - height - p.viewport.params.y * gl.drawingBufferHeight);
                width = Math.round(p.viewport.params.width * gl.drawingBufferWidth);
            }
            if (oldX !== x || oldY !== y || oldWidth !== width || oldHeight !== height) {
                forceNextRender = true;
            }
        }
        function syncViewport() {
            pickHelper.setViewport(x, y, width, height);
            renderer.setViewport(x, y, width, height);
            util_1.Viewport.set(camera.viewport, x, y, width, height);
            util_1.Viewport.set(controls.viewport, x, y, width, height);
        }
    }
    Canvas3D.create = create;
})(Canvas3D || (Canvas3D = {}));
exports.Canvas3D = Canvas3D;
