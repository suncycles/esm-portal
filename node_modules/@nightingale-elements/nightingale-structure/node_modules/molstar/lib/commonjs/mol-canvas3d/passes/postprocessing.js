"use strict";
/**
 * Copyright (c) 2019-2023 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Áron Samuel Kovács <aron.kovacs@mail.muni.cz>
 * @author Ludovic Autin <ludovic.autin@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AntialiasingPass = exports.PostprocessingPass = exports.PostprocessingParams = void 0;
var tslib_1 = require("tslib");
var util_1 = require("../../mol-gl/compute/util");
var schema_1 = require("../../mol-gl/renderable/schema");
var shader_code_1 = require("../../mol-gl/shader-code");
var mol_util_1 = require("../../mol-util");
var render_item_1 = require("../../mol-gl/webgl/render-item");
var renderable_1 = require("../../mol-gl/renderable");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var param_definition_1 = require("../../mol-util/param-definition");
var quad_vert_1 = require("../../mol-gl/shader/quad.vert");
var outlines_frag_1 = require("../../mol-gl/shader/outlines.frag");
var ssao_frag_1 = require("../../mol-gl/shader/ssao.frag");
var ssao_blur_frag_1 = require("../../mol-gl/shader/ssao-blur.frag");
var postprocessing_frag_1 = require("../../mol-gl/shader/postprocessing.frag");
var color_1 = require("../../mol-util/color");
var fxaa_1 = require("./fxaa");
var smaa_1 = require("./smaa");
var debug_1 = require("../../mol-util/debug");
var background_1 = require("./background");
var shadows_frag_1 = require("../../mol-gl/shader/shadows.frag");
var OutlinesSchema = tslib_1.__assign(tslib_1.__assign({}, util_1.QuadSchema), { tDepthOpaque: (0, schema_1.TextureSpec)('texture', 'rgba', 'ubyte', 'nearest'), tDepthTransparent: (0, schema_1.TextureSpec)('texture', 'rgba', 'ubyte', 'nearest'), uTexSize: (0, schema_1.UniformSpec)('v2'), dOrthographic: (0, schema_1.DefineSpec)('number'), uNear: (0, schema_1.UniformSpec)('f'), uFar: (0, schema_1.UniformSpec)('f'), uInvProjection: (0, schema_1.UniformSpec)('m4'), uOutlineThreshold: (0, schema_1.UniformSpec)('f'), dTransparentOutline: (0, schema_1.DefineSpec)('boolean') });
function getOutlinesRenderable(ctx, depthTextureOpaque, depthTextureTransparent, transparentOutline) {
    var width = depthTextureOpaque.getWidth();
    var height = depthTextureOpaque.getHeight();
    var values = tslib_1.__assign(tslib_1.__assign({}, util_1.QuadValues), { tDepthOpaque: mol_util_1.ValueCell.create(depthTextureOpaque), tDepthTransparent: mol_util_1.ValueCell.create(depthTextureTransparent), uTexSize: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(width, height)), dOrthographic: mol_util_1.ValueCell.create(0), uNear: mol_util_1.ValueCell.create(1), uFar: mol_util_1.ValueCell.create(10000), uInvProjection: mol_util_1.ValueCell.create(linear_algebra_1.Mat4.identity()), uOutlineThreshold: mol_util_1.ValueCell.create(0.33), dTransparentOutline: mol_util_1.ValueCell.create(transparentOutline) });
    var schema = tslib_1.__assign({}, OutlinesSchema);
    var shaderCode = (0, shader_code_1.ShaderCode)('outlines', quad_vert_1.quad_vert, outlines_frag_1.outlines_frag);
    var renderItem = (0, render_item_1.createComputeRenderItem)(ctx, 'triangles', shaderCode, schema, values);
    return (0, renderable_1.createComputeRenderable)(renderItem, values);
}
var ShadowsSchema = tslib_1.__assign(tslib_1.__assign({}, util_1.QuadSchema), { tDepth: (0, schema_1.TextureSpec)('texture', 'rgba', 'ubyte', 'nearest'), uTexSize: (0, schema_1.UniformSpec)('v2'), uProjection: (0, schema_1.UniformSpec)('m4'), uInvProjection: (0, schema_1.UniformSpec)('m4'), uBounds: (0, schema_1.UniformSpec)('v4'), dOrthographic: (0, schema_1.DefineSpec)('number'), uNear: (0, schema_1.UniformSpec)('f'), uFar: (0, schema_1.UniformSpec)('f'), dSteps: (0, schema_1.DefineSpec)('number'), uMaxDistance: (0, schema_1.UniformSpec)('f'), uTolerance: (0, schema_1.UniformSpec)('f'), uBias: (0, schema_1.UniformSpec)('f'), uLightDirection: (0, schema_1.UniformSpec)('v3[]'), uLightColor: (0, schema_1.UniformSpec)('v3[]'), dLightCount: (0, schema_1.DefineSpec)('number') });
function getShadowsRenderable(ctx, depthTexture) {
    var width = depthTexture.getWidth();
    var height = depthTexture.getHeight();
    var values = tslib_1.__assign(tslib_1.__assign({}, util_1.QuadValues), { tDepth: mol_util_1.ValueCell.create(depthTexture), uTexSize: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(width, height)), uProjection: mol_util_1.ValueCell.create(linear_algebra_1.Mat4.identity()), uInvProjection: mol_util_1.ValueCell.create(linear_algebra_1.Mat4.identity()), uBounds: mol_util_1.ValueCell.create((0, linear_algebra_1.Vec4)()), dOrthographic: mol_util_1.ValueCell.create(0), uNear: mol_util_1.ValueCell.create(1), uFar: mol_util_1.ValueCell.create(10000), dSteps: mol_util_1.ValueCell.create(1), uMaxDistance: mol_util_1.ValueCell.create(3.0), uTolerance: mol_util_1.ValueCell.create(1.0), uBias: mol_util_1.ValueCell.create(0.6), uLightDirection: mol_util_1.ValueCell.create([]), uLightColor: mol_util_1.ValueCell.create([]), dLightCount: mol_util_1.ValueCell.create(0) });
    var schema = tslib_1.__assign({}, ShadowsSchema);
    var shaderCode = (0, shader_code_1.ShaderCode)('shadows', quad_vert_1.quad_vert, shadows_frag_1.shadows_frag);
    var renderItem = (0, render_item_1.createComputeRenderItem)(ctx, 'triangles', shaderCode, schema, values);
    return (0, renderable_1.createComputeRenderable)(renderItem, values);
}
var SsaoSchema = tslib_1.__assign(tslib_1.__assign({}, util_1.QuadSchema), { tDepth: (0, schema_1.TextureSpec)('texture', 'rgba', 'ubyte', 'nearest'), tDepthHalf: (0, schema_1.TextureSpec)('texture', 'rgba', 'ubyte', 'nearest'), tDepthQuarter: (0, schema_1.TextureSpec)('texture', 'rgba', 'ubyte', 'nearest'), uSamples: (0, schema_1.UniformSpec)('v3[]'), dNSamples: (0, schema_1.DefineSpec)('number'), uProjection: (0, schema_1.UniformSpec)('m4'), uInvProjection: (0, schema_1.UniformSpec)('m4'), uBounds: (0, schema_1.UniformSpec)('v4'), uTexSize: (0, schema_1.UniformSpec)('v2'), uRadius: (0, schema_1.UniformSpec)('f'), uBias: (0, schema_1.UniformSpec)('f'), dMultiScale: (0, schema_1.DefineSpec)('boolean'), dLevels: (0, schema_1.DefineSpec)('number'), uLevelRadius: (0, schema_1.UniformSpec)('f[]'), uLevelBias: (0, schema_1.UniformSpec)('f[]'), uNearThreshold: (0, schema_1.UniformSpec)('f'), uFarThreshold: (0, schema_1.UniformSpec)('f') });
function getSsaoRenderable(ctx, depthTexture, depthHalfTexture, depthQuarterTexture) {
    var values = tslib_1.__assign(tslib_1.__assign({}, util_1.QuadValues), { tDepth: mol_util_1.ValueCell.create(depthTexture), tDepthHalf: mol_util_1.ValueCell.create(depthHalfTexture), tDepthQuarter: mol_util_1.ValueCell.create(depthQuarterTexture), uSamples: mol_util_1.ValueCell.create(getSamples(32)), dNSamples: mol_util_1.ValueCell.create(32), uProjection: mol_util_1.ValueCell.create(linear_algebra_1.Mat4.identity()), uInvProjection: mol_util_1.ValueCell.create(linear_algebra_1.Mat4.identity()), uBounds: mol_util_1.ValueCell.create((0, linear_algebra_1.Vec4)()), uTexSize: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(ctx.gl.drawingBufferWidth, ctx.gl.drawingBufferHeight)), uRadius: mol_util_1.ValueCell.create(Math.pow(2, 5)), uBias: mol_util_1.ValueCell.create(0.8), dMultiScale: mol_util_1.ValueCell.create(false), dLevels: mol_util_1.ValueCell.create(3), uLevelRadius: mol_util_1.ValueCell.create([Math.pow(2, 2), Math.pow(2, 5), Math.pow(2, 8)]), uLevelBias: mol_util_1.ValueCell.create([0.8, 0.8, 0.8]), uNearThreshold: mol_util_1.ValueCell.create(10.0), uFarThreshold: mol_util_1.ValueCell.create(1500.0) });
    var schema = tslib_1.__assign({}, SsaoSchema);
    var shaderCode = (0, shader_code_1.ShaderCode)('ssao', quad_vert_1.quad_vert, ssao_frag_1.ssao_frag);
    var renderItem = (0, render_item_1.createComputeRenderItem)(ctx, 'triangles', shaderCode, schema, values);
    return (0, renderable_1.createComputeRenderable)(renderItem, values);
}
var SsaoBlurSchema = tslib_1.__assign(tslib_1.__assign({}, util_1.QuadSchema), { tSsaoDepth: (0, schema_1.TextureSpec)('texture', 'rgba', 'ubyte', 'nearest'), uTexSize: (0, schema_1.UniformSpec)('v2'), uKernel: (0, schema_1.UniformSpec)('f[]'), dOcclusionKernelSize: (0, schema_1.DefineSpec)('number'), uBlurDirectionX: (0, schema_1.UniformSpec)('f'), uBlurDirectionY: (0, schema_1.UniformSpec)('f'), uInvProjection: (0, schema_1.UniformSpec)('m4'), uNear: (0, schema_1.UniformSpec)('f'), uFar: (0, schema_1.UniformSpec)('f'), uBounds: (0, schema_1.UniformSpec)('v4'), dOrthographic: (0, schema_1.DefineSpec)('number') });
function getSsaoBlurRenderable(ctx, ssaoDepthTexture, direction) {
    var values = tslib_1.__assign(tslib_1.__assign({}, util_1.QuadValues), { tSsaoDepth: mol_util_1.ValueCell.create(ssaoDepthTexture), uTexSize: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(ssaoDepthTexture.getWidth(), ssaoDepthTexture.getHeight())), uKernel: mol_util_1.ValueCell.create(getBlurKernel(15)), dOcclusionKernelSize: mol_util_1.ValueCell.create(15), uBlurDirectionX: mol_util_1.ValueCell.create(direction === 'horizontal' ? 1 : 0), uBlurDirectionY: mol_util_1.ValueCell.create(direction === 'vertical' ? 1 : 0), uInvProjection: mol_util_1.ValueCell.create(linear_algebra_1.Mat4.identity()), uNear: mol_util_1.ValueCell.create(0.0), uFar: mol_util_1.ValueCell.create(10000.0), uBounds: mol_util_1.ValueCell.create((0, linear_algebra_1.Vec4)()), dOrthographic: mol_util_1.ValueCell.create(0) });
    var schema = tslib_1.__assign({}, SsaoBlurSchema);
    var shaderCode = (0, shader_code_1.ShaderCode)('ssao_blur', quad_vert_1.quad_vert, ssao_blur_frag_1.ssaoBlur_frag);
    var renderItem = (0, render_item_1.createComputeRenderItem)(ctx, 'triangles', shaderCode, schema, values);
    return (0, renderable_1.createComputeRenderable)(renderItem, values);
}
function getBlurKernel(kernelSize) {
    var sigma = kernelSize / 3.0;
    var halfKernelSize = Math.floor((kernelSize + 1) / 2);
    var kernel = [];
    for (var x = 0; x < halfKernelSize; x++) {
        kernel.push((1.0 / ((Math.sqrt(2 * Math.PI)) * sigma)) * Math.exp(-x * x / (2 * sigma * sigma)));
    }
    return kernel;
}
var RandomHemisphereVector = [];
for (var i = 0; i < 256; i++) {
    var v = (0, linear_algebra_1.Vec3)();
    v[0] = Math.random() * 2.0 - 1.0;
    v[1] = Math.random() * 2.0 - 1.0;
    v[2] = Math.random();
    linear_algebra_1.Vec3.normalize(v, v);
    linear_algebra_1.Vec3.scale(v, v, Math.random());
    RandomHemisphereVector.push(v);
}
function getSamples(nSamples) {
    var samples = [];
    for (var i = 0; i < nSamples; i++) {
        var scale = (i * i + 2.0 * i + 1) / (nSamples * nSamples);
        scale = 0.1 + scale * (1.0 - 0.1);
        samples.push(RandomHemisphereVector[i][0] * scale);
        samples.push(RandomHemisphereVector[i][1] * scale);
        samples.push(RandomHemisphereVector[i][2] * scale);
    }
    return samples;
}
var PostprocessingSchema = tslib_1.__assign(tslib_1.__assign({}, util_1.QuadSchema), { tSsaoDepth: (0, schema_1.TextureSpec)('texture', 'rgba', 'ubyte', 'nearest'), tColor: (0, schema_1.TextureSpec)('texture', 'rgba', 'ubyte', 'nearest'), tDepthOpaque: (0, schema_1.TextureSpec)('texture', 'rgba', 'ubyte', 'nearest'), tDepthTransparent: (0, schema_1.TextureSpec)('texture', 'rgba', 'ubyte', 'nearest'), tShadows: (0, schema_1.TextureSpec)('texture', 'rgba', 'ubyte', 'nearest'), tOutlines: (0, schema_1.TextureSpec)('texture', 'rgba', 'ubyte', 'nearest'), uTexSize: (0, schema_1.UniformSpec)('v2'), dOrthographic: (0, schema_1.DefineSpec)('number'), uNear: (0, schema_1.UniformSpec)('f'), uFar: (0, schema_1.UniformSpec)('f'), uFogNear: (0, schema_1.UniformSpec)('f'), uFogFar: (0, schema_1.UniformSpec)('f'), uFogColor: (0, schema_1.UniformSpec)('v3'), uOutlineColor: (0, schema_1.UniformSpec)('v3'), uOcclusionColor: (0, schema_1.UniformSpec)('v3'), uTransparentBackground: (0, schema_1.UniformSpec)('b'), dOcclusionEnable: (0, schema_1.DefineSpec)('boolean'), uOcclusionOffset: (0, schema_1.UniformSpec)('v2'), dShadowEnable: (0, schema_1.DefineSpec)('boolean'), dOutlineEnable: (0, schema_1.DefineSpec)('boolean'), dOutlineScale: (0, schema_1.DefineSpec)('number'), dTransparentOutline: (0, schema_1.DefineSpec)('boolean') });
function getPostprocessingRenderable(ctx, colorTexture, depthTextureOpaque, depthTextureTransparent, shadowsTexture, outlinesTexture, ssaoDepthTexture, transparentOutline) {
    var values = tslib_1.__assign(tslib_1.__assign({}, util_1.QuadValues), { tSsaoDepth: mol_util_1.ValueCell.create(ssaoDepthTexture), tColor: mol_util_1.ValueCell.create(colorTexture), tDepthOpaque: mol_util_1.ValueCell.create(depthTextureOpaque), tDepthTransparent: mol_util_1.ValueCell.create(depthTextureTransparent), tShadows: mol_util_1.ValueCell.create(shadowsTexture), tOutlines: mol_util_1.ValueCell.create(outlinesTexture), uTexSize: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(colorTexture.getWidth(), colorTexture.getHeight())), dOrthographic: mol_util_1.ValueCell.create(0), uNear: mol_util_1.ValueCell.create(1), uFar: mol_util_1.ValueCell.create(10000), uFogNear: mol_util_1.ValueCell.create(10000), uFogFar: mol_util_1.ValueCell.create(10000), uFogColor: mol_util_1.ValueCell.create(linear_algebra_1.Vec3.create(1, 1, 1)), uOutlineColor: mol_util_1.ValueCell.create(linear_algebra_1.Vec3.create(0, 0, 0)), uOcclusionColor: mol_util_1.ValueCell.create(linear_algebra_1.Vec3.create(0, 0, 0)), uTransparentBackground: mol_util_1.ValueCell.create(false), dOcclusionEnable: mol_util_1.ValueCell.create(true), uOcclusionOffset: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(0, 0)), dShadowEnable: mol_util_1.ValueCell.create(false), dOutlineEnable: mol_util_1.ValueCell.create(false), dOutlineScale: mol_util_1.ValueCell.create(1), dTransparentOutline: mol_util_1.ValueCell.create(transparentOutline) });
    var schema = tslib_1.__assign({}, PostprocessingSchema);
    var shaderCode = (0, shader_code_1.ShaderCode)('postprocessing', quad_vert_1.quad_vert, postprocessing_frag_1.postprocessing_frag);
    var renderItem = (0, render_item_1.createComputeRenderItem)(ctx, 'triangles', shaderCode, schema, values);
    return (0, renderable_1.createComputeRenderable)(renderItem, values);
}
exports.PostprocessingParams = {
    occlusion: param_definition_1.ParamDefinition.MappedStatic('on', {
        on: param_definition_1.ParamDefinition.Group({
            samples: param_definition_1.ParamDefinition.Numeric(32, { min: 1, max: 256, step: 1 }),
            multiScale: param_definition_1.ParamDefinition.MappedStatic('off', {
                on: param_definition_1.ParamDefinition.Group({
                    levels: param_definition_1.ParamDefinition.ObjectList({
                        radius: param_definition_1.ParamDefinition.Numeric(5, { min: 0, max: 20, step: 0.1 }, { description: 'Final occlusion radius is 2^x' }),
                        bias: param_definition_1.ParamDefinition.Numeric(1, { min: 0, max: 3, step: 0.1 }),
                    }, function (o) { return "".concat(o.radius, ", ").concat(o.bias); }, { defaultValue: [
                            { radius: 2, bias: 1 },
                            { radius: 5, bias: 1 },
                            { radius: 8, bias: 1 },
                            { radius: 11, bias: 1 },
                        ] }),
                    nearThreshold: param_definition_1.ParamDefinition.Numeric(10, { min: 0, max: 50, step: 1 }),
                    farThreshold: param_definition_1.ParamDefinition.Numeric(1500, { min: 0, max: 10000, step: 100 }),
                }),
                off: param_definition_1.ParamDefinition.Group({})
            }, { cycle: true }),
            radius: param_definition_1.ParamDefinition.Numeric(5, { min: 0, max: 20, step: 0.1 }, { description: 'Final occlusion radius is 2^x', hideIf: function (p) { return (p === null || p === void 0 ? void 0 : p.multiScale.name) === 'on'; } }),
            bias: param_definition_1.ParamDefinition.Numeric(0.8, { min: 0, max: 3, step: 0.1 }),
            blurKernelSize: param_definition_1.ParamDefinition.Numeric(15, { min: 1, max: 25, step: 2 }),
            resolutionScale: param_definition_1.ParamDefinition.Numeric(1, { min: 0.1, max: 1, step: 0.05 }, { description: 'Adjust resolution of occlusion calculation' }),
            color: param_definition_1.ParamDefinition.Color((0, color_1.Color)(0x000000)),
        }),
        off: param_definition_1.ParamDefinition.Group({})
    }, { cycle: true, description: 'Darken occluded crevices with the ambient occlusion effect' }),
    shadow: param_definition_1.ParamDefinition.MappedStatic('off', {
        on: param_definition_1.ParamDefinition.Group({
            steps: param_definition_1.ParamDefinition.Numeric(1, { min: 1, max: 64, step: 1 }),
            bias: param_definition_1.ParamDefinition.Numeric(0.6, { min: 0.0, max: 1.0, step: 0.01 }),
            maxDistance: param_definition_1.ParamDefinition.Numeric(3, { min: 0, max: 256, step: 1 }),
            tolerance: param_definition_1.ParamDefinition.Numeric(1.0, { min: 0.0, max: 10.0, step: 0.1 }),
        }),
        off: param_definition_1.ParamDefinition.Group({})
    }, { cycle: true, description: 'Simplistic shadows' }),
    outline: param_definition_1.ParamDefinition.MappedStatic('off', {
        on: param_definition_1.ParamDefinition.Group({
            scale: param_definition_1.ParamDefinition.Numeric(1, { min: 1, max: 5, step: 1 }),
            threshold: param_definition_1.ParamDefinition.Numeric(0.33, { min: 0.01, max: 1, step: 0.01 }),
            color: param_definition_1.ParamDefinition.Color((0, color_1.Color)(0x000000)),
            includeTransparent: param_definition_1.ParamDefinition.Boolean(true, { description: 'Whether to show outline for transparent objects' }),
        }),
        off: param_definition_1.ParamDefinition.Group({})
    }, { cycle: true, description: 'Draw outline around 3D objects' }),
    antialiasing: param_definition_1.ParamDefinition.MappedStatic('smaa', {
        fxaa: param_definition_1.ParamDefinition.Group(fxaa_1.FxaaParams),
        smaa: param_definition_1.ParamDefinition.Group(smaa_1.SmaaParams),
        off: param_definition_1.ParamDefinition.Group({})
    }, { options: [['fxaa', 'FXAA'], ['smaa', 'SMAA'], ['off', 'Off']], description: 'Smooth pixel edges' }),
    background: param_definition_1.ParamDefinition.Group(background_1.BackgroundParams, { isFlat: true }),
};
function getLevels(props, levels) {
    var count = props.length;
    var _a = levels || {
        radius: (new Array(count * 3)).fill(0),
        bias: (new Array(count * 3)).fill(0),
    }, radius = _a.radius, bias = _a.bias;
    props = props.slice().sort(function (a, b) { return a.radius - b.radius; });
    for (var i = 0; i < count; ++i) {
        var p = props[i];
        radius[i] = Math.pow(2, p.radius);
        bias[i] = p.bias;
    }
    return { count: count, radius: radius, bias: bias };
}
var PostprocessingPass = /** @class */ (function () {
    function PostprocessingPass(webgl, assetManager, drawPass) {
        this.webgl = webgl;
        this.drawPass = drawPass;
        this.bgColor = (0, linear_algebra_1.Vec3)();
        this.occlusionOffset = [0, 0];
        this.transparentBackground = false;
        var colorTarget = drawPass.colorTarget, depthTextureTransparent = drawPass.depthTextureTransparent, depthTextureOpaque = drawPass.depthTextureOpaque;
        var width = colorTarget.getWidth();
        var height = colorTarget.getHeight();
        this.nSamples = 1;
        this.blurKernelSize = 1;
        this.downsampleFactor = 1;
        this.ssaoScale = this.calcSsaoScale();
        this.levels = [];
        // needs to be linear for anti-aliasing pass
        this.target = webgl.createRenderTarget(width, height, false, 'uint8', 'linear');
        this.outlinesTarget = webgl.createRenderTarget(width, height, false);
        this.outlinesRenderable = getOutlinesRenderable(webgl, depthTextureOpaque, depthTextureTransparent, true);
        this.shadowsTarget = webgl.createRenderTarget(width, height, false);
        this.shadowsRenderable = getShadowsRenderable(webgl, depthTextureOpaque);
        this.ssaoFramebuffer = webgl.resources.framebuffer();
        this.ssaoBlurFirstPassFramebuffer = webgl.resources.framebuffer();
        this.ssaoBlurSecondPassFramebuffer = webgl.resources.framebuffer();
        var sw = Math.floor(width * this.ssaoScale);
        var sh = Math.floor(height * this.ssaoScale);
        var hw = Math.max(1, Math.floor(sw * 0.5));
        var hh = Math.max(1, Math.floor(sh * 0.5));
        var qw = Math.max(1, Math.floor(sw * 0.25));
        var qh = Math.max(1, Math.floor(sh * 0.25));
        this.downsampledDepthTarget = drawPass.packedDepth
            ? webgl.createRenderTarget(sw, sh, false, 'uint8', 'linear', 'rgba')
            : webgl.createRenderTarget(sw, sh, false, 'float32', 'linear', webgl.isWebGL2 ? 'alpha' : 'rgba');
        this.downsampleDepthRenderable = (0, util_1.createCopyRenderable)(webgl, depthTextureOpaque);
        this.depthHalfTarget = drawPass.packedDepth
            ? webgl.createRenderTarget(hw, hh, false, 'uint8', 'linear', 'rgba')
            : webgl.createRenderTarget(hw, hh, false, 'float32', 'linear', webgl.isWebGL2 ? 'alpha' : 'rgba');
        this.depthHalfRenderable = (0, util_1.createCopyRenderable)(webgl, this.ssaoScale === 1 ? depthTextureOpaque : this.downsampledDepthTarget.texture);
        this.depthQuarterTarget = drawPass.packedDepth
            ? webgl.createRenderTarget(qw, qh, false, 'uint8', 'linear', 'rgba')
            : webgl.createRenderTarget(qw, qh, false, 'float32', 'linear', webgl.isWebGL2 ? 'alpha' : 'rgba');
        this.depthQuarterRenderable = (0, util_1.createCopyRenderable)(webgl, this.depthHalfTarget.texture);
        this.ssaoDepthTexture = webgl.resources.texture('image-uint8', 'rgba', 'ubyte', 'linear');
        this.ssaoDepthTexture.define(sw, sh);
        this.ssaoDepthTexture.attachFramebuffer(this.ssaoFramebuffer, 'color0');
        this.ssaoDepthBlurProxyTexture = webgl.resources.texture('image-uint8', 'rgba', 'ubyte', 'linear');
        this.ssaoDepthBlurProxyTexture.define(sw, sh);
        this.ssaoDepthBlurProxyTexture.attachFramebuffer(this.ssaoBlurFirstPassFramebuffer, 'color0');
        this.ssaoDepthTexture.attachFramebuffer(this.ssaoBlurSecondPassFramebuffer, 'color0');
        this.ssaoRenderable = getSsaoRenderable(webgl, this.ssaoScale === 1 ? depthTextureOpaque : this.downsampledDepthTarget.texture, this.depthHalfTarget.texture, this.depthQuarterTarget.texture);
        this.ssaoBlurFirstPassRenderable = getSsaoBlurRenderable(webgl, this.ssaoDepthTexture, 'horizontal');
        this.ssaoBlurSecondPassRenderable = getSsaoBlurRenderable(webgl, this.ssaoDepthBlurProxyTexture, 'vertical');
        this.renderable = getPostprocessingRenderable(webgl, colorTarget.texture, depthTextureOpaque, depthTextureTransparent, this.shadowsTarget.texture, this.outlinesTarget.texture, this.ssaoDepthTexture, true);
        this.background = new background_1.BackgroundPass(webgl, assetManager, width, height);
    }
    PostprocessingPass.isEnabled = function (props) {
        return props.occlusion.name === 'on' || props.shadow.name === 'on' || props.outline.name === 'on' || props.background.variant.name !== 'off';
    };
    PostprocessingPass.isTransparentOutlineEnabled = function (props) {
        return props.outline.name === 'on' && props.outline.params.includeTransparent;
    };
    PostprocessingPass.prototype.calcSsaoScale = function () {
        // downscale ssao for high pixel-ratios
        return Math.min(1, 1 / this.webgl.pixelRatio) * this.downsampleFactor;
    };
    PostprocessingPass.prototype.setSize = function (width, height) {
        var _a = this.renderable.values.uTexSize.ref.value, w = _a[0], h = _a[1];
        var ssaoScale = this.calcSsaoScale();
        if (width !== w || height !== h || this.ssaoScale !== ssaoScale) {
            this.ssaoScale = ssaoScale;
            this.target.setSize(width, height);
            this.outlinesTarget.setSize(width, height);
            this.shadowsTarget.setSize(width, height);
            var sw = Math.floor(width * this.ssaoScale);
            var sh = Math.floor(height * this.ssaoScale);
            this.downsampledDepthTarget.setSize(sw, sh);
            this.ssaoDepthTexture.define(sw, sh);
            this.ssaoDepthBlurProxyTexture.define(sw, sh);
            var hw = Math.max(1, Math.floor(sw * 0.5));
            var hh = Math.max(1, Math.floor(sh * 0.5));
            this.depthHalfTarget.setSize(hw, hh);
            var qw = Math.max(1, Math.floor(sw * 0.25));
            var qh = Math.max(1, Math.floor(sh * 0.25));
            this.depthQuarterTarget.setSize(qw, qh);
            mol_util_1.ValueCell.update(this.renderable.values.uTexSize, linear_algebra_1.Vec2.set(this.renderable.values.uTexSize.ref.value, width, height));
            mol_util_1.ValueCell.update(this.outlinesRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.outlinesRenderable.values.uTexSize.ref.value, width, height));
            mol_util_1.ValueCell.update(this.shadowsRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.shadowsRenderable.values.uTexSize.ref.value, width, height));
            mol_util_1.ValueCell.update(this.downsampleDepthRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.downsampleDepthRenderable.values.uTexSize.ref.value, sw, sh));
            mol_util_1.ValueCell.update(this.depthHalfRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.depthHalfRenderable.values.uTexSize.ref.value, hw, hh));
            mol_util_1.ValueCell.update(this.depthQuarterRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.depthQuarterRenderable.values.uTexSize.ref.value, qw, qh));
            mol_util_1.ValueCell.update(this.ssaoRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.ssaoRenderable.values.uTexSize.ref.value, sw, sh));
            mol_util_1.ValueCell.update(this.ssaoBlurFirstPassRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.ssaoBlurFirstPassRenderable.values.uTexSize.ref.value, sw, sh));
            mol_util_1.ValueCell.update(this.ssaoBlurSecondPassRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.ssaoBlurSecondPassRenderable.values.uTexSize.ref.value, sw, sh));
            this.background.setSize(width, height);
        }
    };
    PostprocessingPass.prototype.updateState = function (camera, transparentBackground, backgroundColor, props, light) {
        var _a;
        var needsUpdateShadows = false;
        var needsUpdateMain = false;
        var needsUpdateSsao = false;
        var needsUpdateSsaoBlur = false;
        var needsUpdateOutlines = false;
        var orthographic = camera.state.mode === 'orthographic' ? 1 : 0;
        var outlinesEnabled = props.outline.name === 'on';
        var shadowsEnabled = props.shadow.name === 'on';
        var occlusionEnabled = props.occlusion.name === 'on';
        var invProjection = linear_algebra_1.Mat4.identity();
        linear_algebra_1.Mat4.invert(invProjection, camera.projection);
        var _b = this.renderable.values.uTexSize.ref.value, w = _b[0], h = _b[1];
        var v = camera.viewport;
        if (props.occlusion.name === 'on') {
            mol_util_1.ValueCell.update(this.ssaoRenderable.values.uProjection, camera.projection);
            mol_util_1.ValueCell.update(this.ssaoRenderable.values.uInvProjection, invProjection);
            var b = this.ssaoRenderable.values.uBounds;
            var s = this.ssaoScale;
            linear_algebra_1.Vec4.set(b.ref.value, Math.floor(v.x * s) / (w * s), Math.floor(v.y * s) / (h * s), Math.ceil((v.x + v.width) * s) / (w * s), Math.ceil((v.y + v.height) * s) / (h * s));
            mol_util_1.ValueCell.update(b, b.ref.value);
            mol_util_1.ValueCell.update(this.ssaoBlurFirstPassRenderable.values.uBounds, b.ref.value);
            mol_util_1.ValueCell.update(this.ssaoBlurSecondPassRenderable.values.uBounds, b.ref.value);
            mol_util_1.ValueCell.updateIfChanged(this.ssaoBlurFirstPassRenderable.values.uNear, camera.near);
            mol_util_1.ValueCell.updateIfChanged(this.ssaoBlurSecondPassRenderable.values.uNear, camera.near);
            mol_util_1.ValueCell.updateIfChanged(this.ssaoBlurFirstPassRenderable.values.uFar, camera.far);
            mol_util_1.ValueCell.updateIfChanged(this.ssaoBlurSecondPassRenderable.values.uFar, camera.far);
            mol_util_1.ValueCell.update(this.ssaoBlurFirstPassRenderable.values.uInvProjection, invProjection);
            mol_util_1.ValueCell.update(this.ssaoBlurSecondPassRenderable.values.uInvProjection, invProjection);
            if (this.ssaoBlurFirstPassRenderable.values.dOrthographic.ref.value !== orthographic) {
                needsUpdateSsaoBlur = true;
                mol_util_1.ValueCell.update(this.ssaoBlurFirstPassRenderable.values.dOrthographic, orthographic);
                mol_util_1.ValueCell.update(this.ssaoBlurSecondPassRenderable.values.dOrthographic, orthographic);
            }
            if (this.nSamples !== props.occlusion.params.samples) {
                needsUpdateSsao = true;
                this.nSamples = props.occlusion.params.samples;
                mol_util_1.ValueCell.update(this.ssaoRenderable.values.uSamples, getSamples(this.nSamples));
                mol_util_1.ValueCell.updateIfChanged(this.ssaoRenderable.values.dNSamples, this.nSamples);
            }
            var multiScale = props.occlusion.params.multiScale.name === 'on';
            if (this.ssaoRenderable.values.dMultiScale.ref.value !== multiScale) {
                needsUpdateSsao = true;
                mol_util_1.ValueCell.update(this.ssaoRenderable.values.dMultiScale, multiScale);
            }
            if (props.occlusion.params.multiScale.name === 'on') {
                var mp = props.occlusion.params.multiScale.params;
                if (!(0, mol_util_1.deepEqual)(this.levels, mp.levels)) {
                    needsUpdateSsao = true;
                    this.levels = mp.levels;
                    var levels = getLevels(mp.levels);
                    mol_util_1.ValueCell.updateIfChanged(this.ssaoRenderable.values.dLevels, levels.count);
                    mol_util_1.ValueCell.update(this.ssaoRenderable.values.uLevelRadius, levels.radius);
                    mol_util_1.ValueCell.update(this.ssaoRenderable.values.uLevelBias, levels.bias);
                }
                mol_util_1.ValueCell.updateIfChanged(this.ssaoRenderable.values.uNearThreshold, mp.nearThreshold);
                mol_util_1.ValueCell.updateIfChanged(this.ssaoRenderable.values.uFarThreshold, mp.farThreshold);
            }
            else {
                mol_util_1.ValueCell.updateIfChanged(this.ssaoRenderable.values.uRadius, Math.pow(2, props.occlusion.params.radius));
            }
            mol_util_1.ValueCell.updateIfChanged(this.ssaoRenderable.values.uBias, props.occlusion.params.bias);
            if (this.blurKernelSize !== props.occlusion.params.blurKernelSize) {
                needsUpdateSsaoBlur = true;
                this.blurKernelSize = props.occlusion.params.blurKernelSize;
                var kernel = getBlurKernel(this.blurKernelSize);
                mol_util_1.ValueCell.update(this.ssaoBlurFirstPassRenderable.values.uKernel, kernel);
                mol_util_1.ValueCell.update(this.ssaoBlurSecondPassRenderable.values.uKernel, kernel);
                mol_util_1.ValueCell.update(this.ssaoBlurFirstPassRenderable.values.dOcclusionKernelSize, this.blurKernelSize);
                mol_util_1.ValueCell.update(this.ssaoBlurSecondPassRenderable.values.dOcclusionKernelSize, this.blurKernelSize);
            }
            if (this.downsampleFactor !== props.occlusion.params.resolutionScale) {
                needsUpdateSsao = true;
                this.downsampleFactor = props.occlusion.params.resolutionScale;
                this.ssaoScale = this.calcSsaoScale();
                var sw = Math.floor(w * this.ssaoScale);
                var sh = Math.floor(h * this.ssaoScale);
                this.downsampledDepthTarget.setSize(sw, sh);
                this.ssaoDepthTexture.define(sw, sh);
                this.ssaoDepthBlurProxyTexture.define(sw, sh);
                var hw = Math.floor(sw * 0.5);
                var hh = Math.floor(sh * 0.5);
                this.depthHalfTarget.setSize(hw, hh);
                var qw = Math.floor(sw * 0.25);
                var qh = Math.floor(sh * 0.25);
                this.depthQuarterTarget.setSize(qw, qh);
                if (this.ssaoScale === 1) {
                    mol_util_1.ValueCell.update(this.ssaoRenderable.values.tDepth, this.drawPass.depthTextureOpaque);
                }
                else {
                    mol_util_1.ValueCell.update(this.ssaoRenderable.values.tDepth, this.downsampledDepthTarget.texture);
                }
                mol_util_1.ValueCell.update(this.ssaoRenderable.values.tDepthHalf, this.depthHalfTarget.texture);
                mol_util_1.ValueCell.update(this.ssaoRenderable.values.tDepthQuarter, this.depthQuarterTarget.texture);
                mol_util_1.ValueCell.update(this.downsampleDepthRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.downsampleDepthRenderable.values.uTexSize.ref.value, sw, sh));
                mol_util_1.ValueCell.update(this.depthHalfRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.depthHalfRenderable.values.uTexSize.ref.value, hw, hh));
                mol_util_1.ValueCell.update(this.depthQuarterRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.depthQuarterRenderable.values.uTexSize.ref.value, qw, qh));
                mol_util_1.ValueCell.update(this.ssaoRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.ssaoRenderable.values.uTexSize.ref.value, sw, sh));
                mol_util_1.ValueCell.update(this.ssaoBlurFirstPassRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.ssaoBlurFirstPassRenderable.values.uTexSize.ref.value, sw, sh));
                mol_util_1.ValueCell.update(this.ssaoBlurSecondPassRenderable.values.uTexSize, linear_algebra_1.Vec2.set(this.ssaoBlurSecondPassRenderable.values.uTexSize.ref.value, sw, sh));
            }
            mol_util_1.ValueCell.update(this.renderable.values.uOcclusionColor, color_1.Color.toVec3Normalized(this.renderable.values.uOcclusionColor.ref.value, props.occlusion.params.color));
        }
        if (props.shadow.name === 'on') {
            mol_util_1.ValueCell.update(this.shadowsRenderable.values.uProjection, camera.projection);
            mol_util_1.ValueCell.update(this.shadowsRenderable.values.uInvProjection, invProjection);
            linear_algebra_1.Vec4.set(this.shadowsRenderable.values.uBounds.ref.value, v.x / w, v.y / h, (v.x + v.width) / w, (v.y + v.height) / h);
            mol_util_1.ValueCell.update(this.shadowsRenderable.values.uBounds, this.shadowsRenderable.values.uBounds.ref.value);
            mol_util_1.ValueCell.updateIfChanged(this.shadowsRenderable.values.uNear, camera.near);
            mol_util_1.ValueCell.updateIfChanged(this.shadowsRenderable.values.uFar, camera.far);
            if (this.shadowsRenderable.values.dOrthographic.ref.value !== orthographic) {
                mol_util_1.ValueCell.update(this.shadowsRenderable.values.dOrthographic, orthographic);
                needsUpdateShadows = true;
            }
            mol_util_1.ValueCell.updateIfChanged(this.shadowsRenderable.values.uMaxDistance, props.shadow.params.maxDistance);
            mol_util_1.ValueCell.updateIfChanged(this.shadowsRenderable.values.uTolerance, props.shadow.params.tolerance);
            mol_util_1.ValueCell.updateIfChanged(this.shadowsRenderable.values.uBias, props.shadow.params.bias);
            if (this.shadowsRenderable.values.dSteps.ref.value !== props.shadow.params.steps) {
                mol_util_1.ValueCell.update(this.shadowsRenderable.values.dSteps, props.shadow.params.steps);
                needsUpdateShadows = true;
            }
            mol_util_1.ValueCell.update(this.shadowsRenderable.values.uLightDirection, light.direction);
            mol_util_1.ValueCell.update(this.shadowsRenderable.values.uLightColor, light.color);
            if (this.shadowsRenderable.values.dLightCount.ref.value !== light.count) {
                mol_util_1.ValueCell.update(this.shadowsRenderable.values.dLightCount, light.count);
                needsUpdateShadows = true;
            }
        }
        if (props.outline.name === 'on') {
            var transparentOutline = (_a = props.outline.params.includeTransparent) !== null && _a !== void 0 ? _a : true;
            var outlineScale = props.outline.params.scale - 1;
            var outlineThreshold = 50 * props.outline.params.threshold;
            mol_util_1.ValueCell.updateIfChanged(this.outlinesRenderable.values.uNear, camera.near);
            mol_util_1.ValueCell.updateIfChanged(this.outlinesRenderable.values.uFar, camera.far);
            mol_util_1.ValueCell.update(this.outlinesRenderable.values.uInvProjection, invProjection);
            if (this.outlinesRenderable.values.dTransparentOutline.ref.value !== transparentOutline) {
                needsUpdateOutlines = true;
                mol_util_1.ValueCell.update(this.outlinesRenderable.values.dTransparentOutline, transparentOutline);
            }
            if (this.outlinesRenderable.values.dOrthographic.ref.value !== orthographic) {
                needsUpdateOutlines = true;
                mol_util_1.ValueCell.update(this.outlinesRenderable.values.dOrthographic, orthographic);
            }
            mol_util_1.ValueCell.updateIfChanged(this.outlinesRenderable.values.uOutlineThreshold, outlineThreshold);
            mol_util_1.ValueCell.update(this.renderable.values.uOutlineColor, color_1.Color.toVec3Normalized(this.renderable.values.uOutlineColor.ref.value, props.outline.params.color));
            if (this.renderable.values.dOutlineScale.ref.value !== outlineScale) {
                needsUpdateMain = true;
                mol_util_1.ValueCell.update(this.renderable.values.dOutlineScale, outlineScale);
            }
            if (this.renderable.values.dTransparentOutline.ref.value !== transparentOutline) {
                needsUpdateMain = true;
                mol_util_1.ValueCell.update(this.renderable.values.dTransparentOutline, transparentOutline);
            }
        }
        mol_util_1.ValueCell.updateIfChanged(this.renderable.values.uFar, camera.far);
        mol_util_1.ValueCell.updateIfChanged(this.renderable.values.uNear, camera.near);
        mol_util_1.ValueCell.updateIfChanged(this.renderable.values.uFogFar, camera.fogFar);
        mol_util_1.ValueCell.updateIfChanged(this.renderable.values.uFogNear, camera.fogNear);
        mol_util_1.ValueCell.update(this.renderable.values.uFogColor, color_1.Color.toVec3Normalized(this.renderable.values.uFogColor.ref.value, backgroundColor));
        mol_util_1.ValueCell.updateIfChanged(this.renderable.values.uTransparentBackground, transparentBackground);
        if (this.renderable.values.dOrthographic.ref.value !== orthographic) {
            needsUpdateMain = true;
            mol_util_1.ValueCell.update(this.renderable.values.dOrthographic, orthographic);
        }
        if (this.renderable.values.dOutlineEnable.ref.value !== outlinesEnabled) {
            needsUpdateMain = true;
            mol_util_1.ValueCell.update(this.renderable.values.dOutlineEnable, outlinesEnabled);
        }
        if (this.renderable.values.dShadowEnable.ref.value !== shadowsEnabled) {
            needsUpdateMain = true;
            mol_util_1.ValueCell.update(this.renderable.values.dShadowEnable, shadowsEnabled);
        }
        if (this.renderable.values.dOcclusionEnable.ref.value !== occlusionEnabled) {
            needsUpdateMain = true;
            mol_util_1.ValueCell.update(this.renderable.values.dOcclusionEnable, occlusionEnabled);
        }
        if (needsUpdateOutlines) {
            this.outlinesRenderable.update();
        }
        if (needsUpdateShadows) {
            this.shadowsRenderable.update();
        }
        if (needsUpdateSsao) {
            this.ssaoRenderable.update();
        }
        if (needsUpdateSsaoBlur) {
            this.ssaoBlurFirstPassRenderable.update();
            this.ssaoBlurSecondPassRenderable.update();
        }
        if (needsUpdateMain) {
            this.renderable.update();
        }
        var _c = this.webgl, gl = _c.gl, state = _c.state;
        state.enable(gl.SCISSOR_TEST);
        state.disable(gl.BLEND);
        state.disable(gl.DEPTH_TEST);
        state.depthMask(false);
    };
    PostprocessingPass.prototype.setOcclusionOffset = function (x, y) {
        this.occlusionOffset[0] = x;
        this.occlusionOffset[1] = y;
        mol_util_1.ValueCell.update(this.renderable.values.uOcclusionOffset, linear_algebra_1.Vec2.set(this.renderable.values.uOcclusionOffset.ref.value, x, y));
    };
    PostprocessingPass.prototype.setTransparentBackground = function (value) {
        this.transparentBackground = value;
    };
    PostprocessingPass.prototype.render = function (camera, toDrawingBuffer, transparentBackground, backgroundColor, props, light) {
        if (debug_1.isTimingMode)
            this.webgl.timer.mark('PostprocessingPass.render');
        this.updateState(camera, transparentBackground, backgroundColor, props, light);
        var _a = this.webgl, gl = _a.gl, state = _a.state;
        var _b = camera.viewport, x = _b.x, y = _b.y, width = _b.width, height = _b.height;
        // don't render occlusion if offset is given,
        // which will reuse the existing occlusion
        if (props.occlusion.name === 'on' && this.occlusionOffset[0] === 0 && this.occlusionOffset[1] === 0) {
            if (debug_1.isTimingMode)
                this.webgl.timer.mark('SSAO.render');
            var sx = Math.floor(x * this.ssaoScale);
            var sy = Math.floor(y * this.ssaoScale);
            var sw = Math.ceil(width * this.ssaoScale);
            var sh = Math.ceil(height * this.ssaoScale);
            state.viewport(sx, sy, sw, sh);
            state.scissor(sx, sy, sw, sh);
            if (this.ssaoScale < 1) {
                if (debug_1.isTimingMode)
                    this.webgl.timer.mark('SSAO.downsample');
                this.downsampledDepthTarget.bind();
                this.downsampleDepthRenderable.render();
                if (debug_1.isTimingMode)
                    this.webgl.timer.markEnd('SSAO.downsample');
            }
            if (debug_1.isTimingMode)
                this.webgl.timer.mark('SSAO.half');
            this.depthHalfTarget.bind();
            this.depthHalfRenderable.render();
            if (debug_1.isTimingMode)
                this.webgl.timer.markEnd('SSAO.half');
            if (debug_1.isTimingMode)
                this.webgl.timer.mark('SSAO.quarter');
            this.depthQuarterTarget.bind();
            this.depthQuarterRenderable.render();
            if (debug_1.isTimingMode)
                this.webgl.timer.markEnd('SSAO.quarter');
            this.ssaoFramebuffer.bind();
            this.ssaoRenderable.render();
            this.ssaoBlurFirstPassFramebuffer.bind();
            this.ssaoBlurFirstPassRenderable.render();
            this.ssaoBlurSecondPassFramebuffer.bind();
            this.ssaoBlurSecondPassRenderable.render();
            if (debug_1.isTimingMode)
                this.webgl.timer.markEnd('SSAO.render');
        }
        state.viewport(x, y, width, height);
        state.scissor(x, y, width, height);
        if (props.outline.name === 'on') {
            this.outlinesTarget.bind();
            this.outlinesRenderable.render();
        }
        if (props.shadow.name === 'on') {
            this.shadowsTarget.bind();
            this.shadowsRenderable.render();
        }
        if (toDrawingBuffer) {
            this.webgl.unbindFramebuffer();
        }
        else {
            this.target.bind();
        }
        this.background.update(camera, props.background);
        if (this.background.isEnabled(props.background)) {
            if (this.transparentBackground) {
                state.clearColor(0, 0, 0, 0);
            }
            else {
                color_1.Color.toVec3Normalized(this.bgColor, backgroundColor);
                state.clearColor(this.bgColor[0], this.bgColor[1], this.bgColor[2], 1);
            }
            gl.clear(gl.COLOR_BUFFER_BIT);
            state.enable(gl.BLEND);
            state.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            this.background.render();
        }
        else {
            state.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
        this.renderable.render();
        if (debug_1.isTimingMode)
            this.webgl.timer.markEnd('PostprocessingPass.render');
    };
    return PostprocessingPass;
}());
exports.PostprocessingPass = PostprocessingPass;
var AntialiasingPass = /** @class */ (function () {
    function AntialiasingPass(webgl, drawPass) {
        this.drawPass = drawPass;
        var colorTarget = drawPass.colorTarget;
        var width = colorTarget.getWidth();
        var height = colorTarget.getHeight();
        this.target = webgl.createRenderTarget(width, height, false);
        this.fxaa = new fxaa_1.FxaaPass(webgl, this.target.texture);
        this.smaa = new smaa_1.SmaaPass(webgl, this.target.texture);
    }
    AntialiasingPass.isEnabled = function (props) {
        return props.antialiasing.name !== 'off';
    };
    AntialiasingPass.prototype.setSize = function (width, height) {
        var w = this.target.texture.getWidth();
        var h = this.target.texture.getHeight();
        if (width !== w || height !== h) {
            this.target.setSize(width, height);
            this.fxaa.setSize(width, height);
            if (this.smaa.supported)
                this.smaa.setSize(width, height);
        }
    };
    AntialiasingPass.prototype._renderFxaa = function (camera, toDrawingBuffer, props) {
        if (props.antialiasing.name !== 'fxaa')
            return;
        var input = PostprocessingPass.isEnabled(props)
            ? this.drawPass.postprocessing.target.texture
            : this.drawPass.colorTarget.texture;
        this.fxaa.update(input, props.antialiasing.params);
        this.fxaa.render(camera.viewport, toDrawingBuffer ? undefined : this.target);
    };
    AntialiasingPass.prototype._renderSmaa = function (camera, toDrawingBuffer, props) {
        if (props.antialiasing.name !== 'smaa')
            return;
        var input = PostprocessingPass.isEnabled(props)
            ? this.drawPass.postprocessing.target.texture
            : this.drawPass.colorTarget.texture;
        this.smaa.update(input, props.antialiasing.params);
        this.smaa.render(camera.viewport, toDrawingBuffer ? undefined : this.target);
    };
    AntialiasingPass.prototype.render = function (camera, toDrawingBuffer, props) {
        if (props.antialiasing.name === 'off')
            return;
        if (props.antialiasing.name === 'fxaa') {
            this._renderFxaa(camera, toDrawingBuffer, props);
        }
        else if (props.antialiasing.name === 'smaa') {
            if (!this.smaa.supported) {
                throw new Error('SMAA not supported, missing "HTMLImageElement"');
            }
            this._renderSmaa(camera, toDrawingBuffer, props);
        }
    };
    return AntialiasingPass;
}());
exports.AntialiasingPass = AntialiasingPass;
