"use strict";
/**
 * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BoundingSphereHelper = exports.DebugHelperParams = void 0;
var tslib_1 = require("tslib");
var render_object_1 = require("../../mol-gl/render-object");
var mesh_builder_1 = require("../../mol-geo/geometry/mesh/mesh-builder");
var sphere_1 = require("../../mol-geo/geometry/mesh/builder/sphere");
var mesh_1 = require("../../mol-geo/geometry/mesh/mesh");
var param_definition_1 = require("../../mol-util/param-definition");
var scene_1 = require("../../mol-gl/scene");
var geometry_1 = require("../../mol-math/geometry");
var names_1 = require("../../mol-util/color/names");
var sphere_2 = require("../../mol-geo/primitive/sphere");
var mol_util_1 = require("../../mol-util");
var geometry_2 = require("../../mol-geo/geometry/geometry");
var render_item_1 = require("../../mol-gl/webgl/render-item");
exports.DebugHelperParams = {
    sceneBoundingSpheres: param_definition_1.ParamDefinition.Boolean(false, { description: 'Show full scene bounding spheres.' }),
    visibleSceneBoundingSpheres: param_definition_1.ParamDefinition.Boolean(false, { description: 'Show visible scene bounding spheres.' }),
    objectBoundingSpheres: param_definition_1.ParamDefinition.Boolean(false, { description: 'Show bounding spheres of visible render objects.' }),
    instanceBoundingSpheres: param_definition_1.ParamDefinition.Boolean(false, { description: 'Show bounding spheres of visible instances.' }),
};
var BoundingSphereHelper = /** @class */ (function () {
    function BoundingSphereHelper(ctx, parent, props) {
        this.objectsData = new Map();
        this.instancesData = new Map();
        this.scene = scene_1.Scene.create(ctx, render_item_1.GraphicsRenderVariantsBlended);
        this.parent = parent;
        this._props = tslib_1.__assign(tslib_1.__assign({}, param_definition_1.ParamDefinition.getDefaultValues(exports.DebugHelperParams)), props);
    }
    BoundingSphereHelper.prototype.update = function () {
        var _this = this;
        var newSceneData = updateBoundingSphereData(this.scene, this.parent.boundingSphere, this.sceneData, names_1.ColorNames.lightgrey, sceneMaterialId);
        if (newSceneData)
            this.sceneData = newSceneData;
        var newVisibleSceneData = updateBoundingSphereData(this.scene, this.parent.boundingSphereVisible, this.visibleSceneData, names_1.ColorNames.black, visibleSceneMaterialId);
        if (newVisibleSceneData)
            this.visibleSceneData = newVisibleSceneData;
        this.parent.forEach(function (r, ro) {
            var objectData = _this.objectsData.get(ro);
            var newObjectData = updateBoundingSphereData(_this.scene, r.values.boundingSphere.ref.value, objectData, names_1.ColorNames.tomato, objectMaterialId);
            if (newObjectData)
                _this.objectsData.set(ro, newObjectData);
            var instanceData = _this.instancesData.get(ro);
            var newInstanceData = updateBoundingSphereData(_this.scene, r.values.invariantBoundingSphere.ref.value, instanceData, names_1.ColorNames.skyblue, instanceMaterialId, {
                aTransform: ro.values.aTransform,
                matrix: ro.values.matrix,
                transform: ro.values.transform,
                extraTransform: ro.values.extraTransform,
                uInstanceCount: ro.values.uInstanceCount,
                instanceCount: ro.values.instanceCount,
                aInstance: ro.values.aInstance,
                hasReflection: ro.values.hasReflection,
            });
            if (newInstanceData)
                _this.instancesData.set(ro, newInstanceData);
        });
        this.objectsData.forEach(function (objectData, ro) {
            if (!_this.parent.has(ro)) {
                _this.scene.remove(objectData.renderObject);
                _this.objectsData.delete(ro);
            }
        });
        this.instancesData.forEach(function (instanceData, ro) {
            if (!_this.parent.has(ro)) {
                _this.scene.remove(instanceData.renderObject);
                _this.instancesData.delete(ro);
            }
        });
        this.scene.update(void 0, false);
        this.scene.commit();
    };
    BoundingSphereHelper.prototype.syncVisibility = function () {
        var _this = this;
        if (this.sceneData) {
            this.sceneData.renderObject.state.visible = this._props.sceneBoundingSpheres;
        }
        if (this.visibleSceneData) {
            this.visibleSceneData.renderObject.state.visible = this._props.visibleSceneBoundingSpheres;
        }
        this.parent.forEach(function (_, ro) {
            var objectData = _this.objectsData.get(ro);
            if (objectData)
                objectData.renderObject.state.visible = ro.state.visible && _this._props.objectBoundingSpheres;
            var instanceData = _this.instancesData.get(ro);
            if (instanceData)
                instanceData.renderObject.state.visible = ro.state.visible && _this._props.instanceBoundingSpheres;
        });
    };
    BoundingSphereHelper.prototype.clear = function () {
        this.sceneData = undefined;
        this.objectsData.clear();
        this.scene.clear();
    };
    Object.defineProperty(BoundingSphereHelper.prototype, "isEnabled", {
        get: function () {
            return (this._props.sceneBoundingSpheres || this._props.visibleSceneBoundingSpheres ||
                this._props.objectBoundingSpheres || this._props.instanceBoundingSpheres);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BoundingSphereHelper.prototype, "props", {
        get: function () { return this._props; },
        enumerable: false,
        configurable: true
    });
    BoundingSphereHelper.prototype.setProps = function (props) {
        Object.assign(this._props, props);
        if (this.isEnabled)
            this.update();
    };
    return BoundingSphereHelper;
}());
exports.BoundingSphereHelper = BoundingSphereHelper;
function updateBoundingSphereData(scene, boundingSphere, data, color, materialId, transform) {
    if (!data || !geometry_1.Sphere3D.equals(data.boundingSphere, boundingSphere)) {
        var mesh = createBoundingSphereMesh(boundingSphere, data && data.mesh);
        var renderObject = data ? data.renderObject : createBoundingSphereRenderObject(mesh, color, materialId, transform);
        if (data) {
            mol_util_1.ValueCell.updateIfChanged(renderObject.values.drawCount, geometry_2.Geometry.getDrawCount(mesh));
        }
        else {
            scene.add(renderObject);
        }
        return { boundingSphere: geometry_1.Sphere3D.clone(boundingSphere), renderObject: renderObject, mesh: mesh };
    }
}
function createBoundingSphereMesh(boundingSphere, mesh) {
    var detail = 2;
    var vertexCount = (0, sphere_2.sphereVertexCount)(detail);
    var builderState = mesh_builder_1.MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);
    if (boundingSphere.radius) {
        (0, sphere_1.addSphere)(builderState, boundingSphere.center, boundingSphere.radius, detail);
        if (geometry_1.Sphere3D.hasExtrema(boundingSphere)) {
            for (var _i = 0, _a = boundingSphere.extrema; _i < _a.length; _i++) {
                var e = _a[_i];
                (0, sphere_1.addSphere)(builderState, e, 1.0, 0);
            }
        }
    }
    return mesh_builder_1.MeshBuilder.getMesh(builderState);
}
var sceneMaterialId = (0, render_object_1.getNextMaterialId)();
var visibleSceneMaterialId = (0, render_object_1.getNextMaterialId)();
var objectMaterialId = (0, render_object_1.getNextMaterialId)();
var instanceMaterialId = (0, render_object_1.getNextMaterialId)();
function createBoundingSphereRenderObject(mesh, color, materialId, transform) {
    var values = mesh_1.Mesh.Utils.createValuesSimple(mesh, { alpha: 0.1, doubleSided: false }, color, 1, transform);
    return (0, render_object_1.createRenderObject)('mesh', values, { disposed: false, visible: true, alphaFactor: 1, pickable: false, colorOnly: false, opaque: false, writeDepth: false }, materialId);
}
