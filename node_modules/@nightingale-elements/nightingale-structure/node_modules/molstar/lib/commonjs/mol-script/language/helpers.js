"use strict";
/*
 * Copyright (c) 2018 Mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.symbolList = exports.normalizeTable = exports.symbol = void 0;
var symbol_1 = require("./symbol");
function symbol(args, type, description) {
    return (0, symbol_1.MSymbol)('', args, type, description);
}
exports.symbol = symbol;
function normalizeTable(table) {
    _normalizeTable('', '', table);
}
exports.normalizeTable = normalizeTable;
function symbolList(table) {
    var list = [];
    _symbolList(table, list);
    return list;
}
exports.symbolList = symbolList;
function formatKey(key) {
    var regex = /([a-z])([A-Z])([a-z]|$)/g;
    // do this twice because 'xXxX'
    return key.replace(regex, function (s, a, b, c) { return "".concat(a, "-").concat(b.toLocaleLowerCase()).concat(c); }).replace(regex, function (s, a, b, c) { return "".concat(a, "-").concat(b.toLocaleLowerCase()).concat(c); });
}
function _normalizeTable(namespace, key, obj) {
    if ((0, symbol_1.isSymbol)(obj)) {
        obj.info.namespace = namespace;
        obj.info.name = obj.info.name || formatKey(key);
        obj.id = "".concat(obj.info.namespace, ".").concat(obj.info.name);
        return;
    }
    var currentNs = "".concat(obj['@namespace'] || formatKey(key));
    var newNs = namespace ? "".concat(namespace, ".").concat(currentNs) : currentNs;
    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
        var childKey = _a[_i];
        if (typeof obj[childKey] !== 'object' && !(0, symbol_1.isSymbol)(obj[childKey]))
            continue;
        _normalizeTable(newNs, childKey, obj[childKey]);
    }
}
function _symbolList(obj, list) {
    if ((0, symbol_1.isSymbol)(obj)) {
        list.push(obj);
        return;
    }
    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
        var childKey = _a[_i];
        if (typeof obj[childKey] !== 'object' && !(0, symbol_1.isSymbol)(obj[childKey]))
            continue;
        _symbolList(obj[childKey], list);
    }
}
