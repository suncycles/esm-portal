"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateUnitDihedralAngles = void 0;
var linear_algebra_1 = require("../../../../mol-math/linear-algebra");
var misc_1 = require("../../../../mol-math/misc");
function calculateUnitDihedralAngles(unit, proteinInfo) {
    var cIndices = proteinInfo.cIndices, nIndices = proteinInfo.nIndices, residueIndices = proteinInfo.residueIndices;
    var position = unit.conformation.position;
    var index = unit.model.atomicHierarchy.index;
    var traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex;
    var residueCount = residueIndices.length;
    var p = function (i, v) { return i === -1 ? linear_algebra_1.Vec3.setNaN(v) : position(i, v); };
    var cPosPrev = (0, linear_algebra_1.Vec3)(), caPosPrev = (0, linear_algebra_1.Vec3)(), nPosPrev = (0, linear_algebra_1.Vec3)();
    var cPos = (0, linear_algebra_1.Vec3)(), caPos = (0, linear_algebra_1.Vec3)(), nPos = (0, linear_algebra_1.Vec3)();
    var cPosNext = (0, linear_algebra_1.Vec3)(), caPosNext = (0, linear_algebra_1.Vec3)(), nPosNext = (0, linear_algebra_1.Vec3)();
    if (residueCount === 0)
        return { phi: new Float32Array(0), psi: new Float32Array(0) };
    var phi = new Float32Array(residueCount - 1);
    var psi = new Float32Array(residueCount - 1);
    p(-1, cPosPrev);
    p(-1, caPosPrev);
    p(-1, nPosPrev);
    p(cIndices[0], cPos);
    p(traceElementIndex[residueIndices[0]], caPos);
    p(nIndices[0], nPos);
    p(cIndices[1], cPosNext);
    p(traceElementIndex[residueIndices[1]], caPosNext);
    p(nIndices[1], nPosNext);
    for (var i = 0; i < residueCount - 1; ++i) {
        // ignore C-terminal residue as acceptor
        if (index.findAtomOnResidue(residueIndices[i], 'OXT') !== -1)
            continue;
        // returns NaN for missing atoms
        phi[i] = (0, misc_1.radToDeg)(linear_algebra_1.Vec3.dihedralAngle(cPosPrev, nPos, caPos, cPos));
        psi[i] = (0, misc_1.radToDeg)(linear_algebra_1.Vec3.dihedralAngle(nPos, caPos, cPos, nPosNext));
        cPosPrev = cPos, caPosPrev = caPos, nPosPrev = nPos;
        cPos = cPosNext, caPos = caPosNext, nPos = nPosNext;
        p(cIndices[i + 1], cPosNext);
        p(traceElementIndex[residueIndices[i + 1]], caPosNext);
        p(nIndices[i + 1], nPosNext);
    }
    return { phi: phi, psi: psi };
}
exports.calculateUnitDihedralAngles = calculateUnitDihedralAngles;
