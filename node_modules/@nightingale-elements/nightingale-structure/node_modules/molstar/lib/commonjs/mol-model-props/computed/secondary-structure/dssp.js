"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeUnitDSSP = exports.DSSPComputationParams = void 0;
var tslib_1 = require("tslib");
var seconday_structure_1 = require("../../../mol-model/structure/model/properties/seconday-structure");
var types_1 = require("../../../mol-model/structure/model/types");
var param_definition_1 = require("../../../mol-util/param-definition");
var bends_1 = require("./dssp/bends");
var backbone_hbonds_1 = require("./dssp/backbone-hbonds");
var common_1 = require("./dssp/common");
var turns_1 = require("./dssp/turns");
var helices_1 = require("./dssp/helices");
var ladders_1 = require("./dssp/ladders");
var bridges_1 = require("./dssp/bridges");
var sheets_1 = require("./dssp/sheets");
var dihedral_angles_1 = require("./dssp/dihedral-angles");
var trace_lookup_1 = require("./dssp/trace-lookup");
var protein_info_1 = require("./dssp/protein-info");
var int_1 = require("../../../mol-data/int");
/**
 * TODO bugs to fix:
 * - some turns are not detected correctly: see e.g. pdb:1acj - maybe more than 2 hbonds require some residue to donate electrons
 * - some sheets are not extended correctly: see e.g. pdb:1acj
 * - validate new helix definition
 * - validate new ordering of secondary structure elements
 */
exports.DSSPComputationParams = {
    oldDefinition: param_definition_1.ParamDefinition.Boolean(true, { description: 'Whether to use the old DSSP convention for the annotation of turns and helices, causes them to be two residues shorter' }),
    oldOrdering: param_definition_1.ParamDefinition.Boolean(true, { description: 'Alpha-helices are preferred over 3-10 helices' })
};
function computeUnitDSSP(unit, params) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var proteinInfo, residueIndices, lookup3d, hbonds, residueCount, flags, torsionAngles, ladders, bridges, getResidueFlag, getFlagName, ctx, assignment, type, keys, elements, getIndex, i, il, assign, flag;
        return tslib_1.__generator(this, function (_a) {
            proteinInfo = (0, protein_info_1.getUnitProteinInfo)(unit);
            residueIndices = proteinInfo.residueIndices;
            lookup3d = (0, trace_lookup_1.calcUnitProteinTraceLookup3D)(unit, residueIndices);
            hbonds = (0, backbone_hbonds_1.calcUnitBackboneHbonds)(unit, proteinInfo, lookup3d);
            residueCount = residueIndices.length;
            flags = new Uint32Array(residueCount);
            torsionAngles = (0, dihedral_angles_1.calculateUnitDihedralAngles)(unit, proteinInfo);
            ladders = [];
            bridges = [];
            getResidueFlag = params.oldDefinition ? getOriginalResidueFlag : getUpdatedResidueFlag;
            getFlagName = params.oldOrdering ? getOriginalFlagName : getUpdatedFlagName;
            ctx = {
                params: params,
                getResidueFlag: getResidueFlag,
                getFlagName: getFlagName,
                unit: unit,
                proteinInfo: proteinInfo,
                flags: flags,
                hbonds: hbonds,
                torsionAngles: torsionAngles,
                ladders: ladders,
                bridges: bridges
            };
            (0, turns_1.assignTurns)(ctx);
            (0, helices_1.assignHelices)(ctx);
            (0, bends_1.assignBends)(ctx);
            (0, bridges_1.assignBridges)(ctx);
            (0, ladders_1.assignLadders)(ctx);
            (0, sheets_1.assignSheets)(ctx);
            assignment = getDSSPAssignment(flags, getResidueFlag);
            type = new Uint32Array(residueCount);
            keys = [];
            elements = [];
            getIndex = function (rI) { return int_1.SortedArray.indexOf(residueIndices, rI); };
            for (i = 0, il = residueIndices.length; i < il; ++i) {
                assign = assignment[i];
                type[i] = assign;
                flag = getResidueFlag(flags[i]);
                // console.log(i, SortedArray.indexOf(residueIndices, i), getFlagName(flags[i]))
                // TODO is this expected behavior? elements will be strictly split depending on 'winning' flag
                if (elements.length === 0 /* would fail at very start */ || flag !== elements[elements.length - 1].flags /* flag changed */) {
                    elements[elements.length] = createElement(mapToKind(assign), flags[i], getResidueFlag);
                }
                keys[i] = elements.length - 1;
            }
            return [2 /*return*/, (0, seconday_structure_1.SecondaryStructure)(type, keys, elements, getIndex)];
        });
    });
}
exports.computeUnitDSSP = computeUnitDSSP;
function createElement(kind, flag, getResidueFlag) {
    // TODO would be nice to add more detailed information
    if (kind === 'helix') {
        return {
            kind: 'helix',
            flags: getResidueFlag(flag)
        };
    }
    else if (kind === 'sheet') {
        return {
            kind: 'sheet',
            flags: getResidueFlag(flag)
        };
    }
    else if (kind === 'turn' || kind === 'bend') {
        return {
            kind: 'turn',
            flags: getResidueFlag(flag)
        };
    }
    else {
        return {
            kind: 'none'
        };
    }
}
function mapToKind(assignment) {
    if (assignment === types_1.SecondaryStructureType.SecondaryStructureDssp.H || assignment === types_1.SecondaryStructureType.SecondaryStructureDssp.G || assignment === types_1.SecondaryStructureType.SecondaryStructureDssp.I) {
        return 'helix';
    }
    else if (assignment === types_1.SecondaryStructureType.SecondaryStructureDssp.B || assignment === types_1.SecondaryStructureType.SecondaryStructureDssp.E) {
        return 'sheet';
    }
    else if (assignment === types_1.SecondaryStructureType.SecondaryStructureDssp.T) {
        return 'turn';
    }
    else if (assignment === types_1.SecondaryStructureType.SecondaryStructureDssp.S) {
        return 'bend';
    }
    else {
        return 'none';
    }
}
/** Original priority: H,B,E,G,I,T,S */
function getOriginalResidueFlag(f) {
    if (common_1.DSSPType.is(f, 1 /* DSSPType.Flag.H */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.H;
    if (common_1.DSSPType.is(f, 4 /* DSSPType.Flag.E */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.E;
    if (common_1.DSSPType.is(f, 2 /* DSSPType.Flag.B */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.B;
    if (common_1.DSSPType.is(f, 8 /* DSSPType.Flag.G */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.G;
    if (common_1.DSSPType.is(f, 16 /* DSSPType.Flag.I */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.I;
    if (common_1.DSSPType.is(f, 64 /* DSSPType.Flag.T */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.T;
    if (common_1.DSSPType.is(f, 32 /* DSSPType.Flag.S */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.S;
    return 0 /* SecondaryStructureType.Flag.None */;
}
function getOriginalFlagName(f) {
    if (common_1.DSSPType.is(f, 1 /* DSSPType.Flag.H */))
        return 'H';
    if (common_1.DSSPType.is(f, 4 /* DSSPType.Flag.E */))
        return 'E';
    if (common_1.DSSPType.is(f, 2 /* DSSPType.Flag.B */))
        return 'B';
    if (common_1.DSSPType.is(f, 8 /* DSSPType.Flag.G */))
        return 'G';
    if (common_1.DSSPType.is(f, 16 /* DSSPType.Flag.I */))
        return 'I';
    if (common_1.DSSPType.is(f, 64 /* DSSPType.Flag.T */))
        return 'T';
    if (common_1.DSSPType.is(f, 32 /* DSSPType.Flag.S */))
        return 'S';
    return '-';
}
/** Version 2.1.0 priority: I,H,B,E,G,T,S */
function getUpdatedResidueFlag(f) {
    if (common_1.DSSPType.is(f, 16 /* DSSPType.Flag.I */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.I;
    if (common_1.DSSPType.is(f, 1 /* DSSPType.Flag.H */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.H;
    if (common_1.DSSPType.is(f, 4 /* DSSPType.Flag.E */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.E;
    if (common_1.DSSPType.is(f, 2 /* DSSPType.Flag.B */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.B;
    if (common_1.DSSPType.is(f, 8 /* DSSPType.Flag.G */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.G;
    if (common_1.DSSPType.is(f, 64 /* DSSPType.Flag.T */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.T;
    if (common_1.DSSPType.is(f, 32 /* DSSPType.Flag.S */))
        return types_1.SecondaryStructureType.SecondaryStructureDssp.S;
    return 0 /* SecondaryStructureType.Flag.None */;
}
function getUpdatedFlagName(f) {
    if (common_1.DSSPType.is(f, 16 /* DSSPType.Flag.I */))
        return 'I';
    if (common_1.DSSPType.is(f, 1 /* DSSPType.Flag.H */))
        return 'H';
    if (common_1.DSSPType.is(f, 4 /* DSSPType.Flag.E */))
        return 'E';
    if (common_1.DSSPType.is(f, 2 /* DSSPType.Flag.B */))
        return 'B';
    if (common_1.DSSPType.is(f, 8 /* DSSPType.Flag.G */))
        return 'G';
    if (common_1.DSSPType.is(f, 64 /* DSSPType.Flag.T */))
        return 'T';
    if (common_1.DSSPType.is(f, 32 /* DSSPType.Flag.S */))
        return 'S';
    return '-';
}
function getDSSPAssignment(flags, getResidueFlag) {
    var type = new Uint32Array(flags.length);
    for (var i = 0, il = flags.length; i < il; ++i) {
        var f = common_1.DSSPType.create(flags[i]);
        type[i] = getResidueFlag(f);
    }
    return type;
}
