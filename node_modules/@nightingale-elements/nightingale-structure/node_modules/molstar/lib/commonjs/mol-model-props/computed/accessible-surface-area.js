"use strict";
/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccessibleSurfaceAreaProvider = exports.AccessibleSurfaceAreaSymbols = exports.AccessibleSurfaceAreaParams = void 0;
var tslib_1 = require("tslib");
var param_definition_1 = require("../../mol-util/param-definition");
var shrake_rupley_1 = require("./accessible-surface-area/shrake-rupley");
var structure_1 = require("../../mol-model/structure");
var custom_structure_property_1 = require("../common/custom-structure-property");
var compiler_1 = require("../../mol-script/runtime/query/compiler");
var symbol_1 = require("../../mol-script/language/symbol");
var type_1 = require("../../mol-script/language/type");
var custom_property_1 = require("../../mol-model/custom-property");
exports.AccessibleSurfaceAreaParams = tslib_1.__assign({}, shrake_rupley_1.ShrakeRupleyComputationParams);
exports.AccessibleSurfaceAreaSymbols = {
    isBuried: compiler_1.QuerySymbolRuntime.Dynamic((0, symbol_1.CustomPropSymbol)('computed', 'accessible-surface-area.is-buried', type_1.Type.Bool), function (ctx) {
        if (!structure_1.Unit.isAtomic(ctx.element.unit))
            return false;
        var accessibleSurfaceArea = exports.AccessibleSurfaceAreaProvider.get(ctx.element.structure).value;
        if (!accessibleSurfaceArea)
            return false;
        return shrake_rupley_1.AccessibleSurfaceArea.getFlag(ctx.element, accessibleSurfaceArea) === 1 /* AccessibleSurfaceArea.Flags.Buried */;
    }),
    isAccessible: compiler_1.QuerySymbolRuntime.Dynamic((0, symbol_1.CustomPropSymbol)('computed', 'accessible-surface-area.is-accessible', type_1.Type.Bool), function (ctx) {
        if (!structure_1.Unit.isAtomic(ctx.element.unit))
            return false;
        var accessibleSurfaceArea = exports.AccessibleSurfaceAreaProvider.get(ctx.element.structure).value;
        if (!accessibleSurfaceArea)
            return false;
        return shrake_rupley_1.AccessibleSurfaceArea.getFlag(ctx.element, accessibleSurfaceArea) === 2 /* AccessibleSurfaceArea.Flags.Accessible */;
    }),
};
exports.AccessibleSurfaceAreaProvider = custom_structure_property_1.CustomStructureProperty.createProvider({
    label: 'Accessible Surface Area',
    descriptor: (0, custom_property_1.CustomPropertyDescriptor)({
        name: 'molstar_accessible_surface_area',
        symbols: exports.AccessibleSurfaceAreaSymbols,
        // TODO `cifExport`
    }),
    type: 'root',
    defaultParams: exports.AccessibleSurfaceAreaParams,
    getParams: function (data) { return exports.AccessibleSurfaceAreaParams; },
    isApplicable: function (data) { return true; },
    obtain: function (ctx, data, props) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var p;
        var _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    p = tslib_1.__assign(tslib_1.__assign({}, param_definition_1.ParamDefinition.getDefaultValues(exports.AccessibleSurfaceAreaParams)), props);
                    _a = {};
                    return [4 /*yield*/, shrake_rupley_1.AccessibleSurfaceArea.compute(data, p).runInContext(ctx.runtime)];
                case 1: return [2 /*return*/, (_a.value = _b.sent(), _a)];
            }
        });
    }); }
});
