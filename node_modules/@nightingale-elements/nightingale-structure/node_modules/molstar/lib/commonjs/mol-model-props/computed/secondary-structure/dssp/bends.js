"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.assignBends = void 0;
var linear_algebra_1 = require("../../../../mol-math/linear-algebra");
var misc_1 = require("../../../../mol-math/misc");
/**
 * Bend(i) =: [angle ((CW - Ca(i - 2)),(C"(i + 2) - C"(i))) > 70"]
 *
 * Type: S
 */
function assignBends(ctx) {
    var unit = ctx.unit, flags = ctx.flags, proteinInfo = ctx.proteinInfo;
    var position = unit.conformation.position;
    var traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex;
    var residueIndices = proteinInfo.residueIndices, nIndices = proteinInfo.nIndices;
    var residueCount = residueIndices.length;
    // const position = (i: number, v: Vec3) => Vec3.set(v, x[i], y[i], z[i])
    var p = function (i, v) { return i === -1 ? linear_algebra_1.Vec3.setNaN(v) : position(i, v); };
    var caPosPrev2 = (0, linear_algebra_1.Vec3)();
    var caPos = (0, linear_algebra_1.Vec3)();
    var caPosNext2 = (0, linear_algebra_1.Vec3)();
    var cPos = (0, linear_algebra_1.Vec3)();
    var nPosNext = (0, linear_algebra_1.Vec3)();
    var caMinus2 = (0, linear_algebra_1.Vec3)();
    var caPlus2 = (0, linear_algebra_1.Vec3)();
    f1: for (var i = 2; i < residueCount - 2; i++) {
        // check for peptide bond
        for (var k = 0; k < 4; k++) {
            var index = i + k - 2;
            p(traceElementIndex[index], cPos);
            p(nIndices[index + 1], nPosNext);
            if (linear_algebra_1.Vec3.squaredDistance(cPos, nPosNext) > 6.25 /* max squared peptide bond distance allowed */) {
                continue f1;
            }
        }
        var oRIprev2 = residueIndices[i - 2];
        var oRI = residueIndices[i];
        var oRInext2 = residueIndices[i + 2];
        var caAtomPrev2 = traceElementIndex[oRIprev2];
        var caAtom = traceElementIndex[oRI];
        var caAtomNext2 = traceElementIndex[oRInext2];
        p(caAtomPrev2, caPosPrev2);
        p(caAtom, caPos);
        p(caAtomNext2, caPosNext2);
        linear_algebra_1.Vec3.sub(caMinus2, caPosPrev2, caPos);
        linear_algebra_1.Vec3.sub(caPlus2, caPos, caPosNext2);
        var angle = (0, misc_1.radToDeg)(linear_algebra_1.Vec3.angle(caMinus2, caPlus2));
        if (angle && angle > 70.00) {
            flags[i] |= 32 /* DSSPType.Flag.S */;
        }
    }
}
exports.assignBends = assignBends;
