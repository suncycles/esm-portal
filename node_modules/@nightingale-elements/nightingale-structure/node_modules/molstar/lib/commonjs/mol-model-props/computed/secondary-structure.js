"use strict";
/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecondaryStructureProvider = exports.SecondaryStructureParams = void 0;
var tslib_1 = require("tslib");
var dssp_1 = require("./secondary-structure/dssp");
var param_definition_1 = require("../../mol-util/param-definition");
var structure_1 = require("../../mol-model/structure/structure");
var custom_structure_property_1 = require("../common/custom-structure-property");
var secondary_structure_1 = require("../../mol-model-formats/structure/property/secondary-structure");
var custom_property_1 = require("../../mol-model/custom-property");
var model_1 = require("../../mol-model/structure/model");
function getSecondaryStructureParams(data) {
    var defaultType = 'model';
    if (data) {
        defaultType = 'dssp';
        for (var i = 0, il = data.models.length; i < il; ++i) {
            var m = data.models[i];
            if (model_1.Model.isFromPdbArchive(m) || model_1.Model.hasSecondaryStructure(m)) {
                // if there is any secondary structure definition given or if there is
                // an archival model, don't calculate dssp by default
                defaultType = 'model';
                break;
            }
        }
    }
    return {
        type: param_definition_1.ParamDefinition.MappedStatic(defaultType, {
            'model': param_definition_1.ParamDefinition.EmptyGroup({ label: 'Model' }),
            'dssp': param_definition_1.ParamDefinition.Group(dssp_1.DSSPComputationParams, { label: 'DSSP', isFlat: true })
        }, { options: [['model', 'Model'], ['dssp', 'DSSP']] })
    };
}
exports.SecondaryStructureParams = getSecondaryStructureParams();
exports.SecondaryStructureProvider = custom_structure_property_1.CustomStructureProperty.createProvider({
    label: 'Secondary Structure',
    descriptor: (0, custom_property_1.CustomPropertyDescriptor)({
        name: 'molstar_computed_secondary_structure',
        // TODO `cifExport` and `symbol`
    }),
    type: 'root',
    defaultParams: exports.SecondaryStructureParams,
    getParams: getSecondaryStructureParams,
    isApplicable: function (data) { return true; },
    obtain: function (ctx, data, props) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var p, _a;
        var _b, _c;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    p = tslib_1.__assign(tslib_1.__assign({}, param_definition_1.ParamDefinition.getDefaultValues(exports.SecondaryStructureParams)), props);
                    _a = p.type.name;
                    switch (_a) {
                        case 'dssp': return [3 /*break*/, 1];
                        case 'model': return [3 /*break*/, 3];
                    }
                    return [3 /*break*/, 5];
                case 1:
                    _b = {};
                    return [4 /*yield*/, computeDssp(data, p.type.params)];
                case 2: return [2 /*return*/, (_b.value = _d.sent(), _b)];
                case 3:
                    _c = {};
                    return [4 /*yield*/, computeModel(data)];
                case 4: return [2 /*return*/, (_c.value = _d.sent(), _c)];
                case 5: return [2 /*return*/];
            }
        });
    }); }
});
function computeDssp(structure, props) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var map, i, il, u, secondaryStructure;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    map = new Map();
                    i = 0, il = structure.unitSymmetryGroups.length;
                    _a.label = 1;
                case 1:
                    if (!(i < il)) return [3 /*break*/, 4];
                    u = structure.unitSymmetryGroups[i].units[0];
                    if (!(structure_1.Unit.isAtomic(u) && !model_1.Model.isCoarseGrained(u.model))) return [3 /*break*/, 3];
                    return [4 /*yield*/, (0, dssp_1.computeUnitDSSP)(u, props)];
                case 2:
                    secondaryStructure = _a.sent();
                    map.set(u.invariantId, secondaryStructure);
                    _a.label = 3;
                case 3:
                    ++i;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/, map];
            }
        });
    });
}
function computeModel(structure) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var map, i, il, u, secondaryStructure;
        return tslib_1.__generator(this, function (_a) {
            map = new Map();
            for (i = 0, il = structure.unitSymmetryGroups.length; i < il; ++i) {
                u = structure.unitSymmetryGroups[i].units[0];
                if (structure_1.Unit.isAtomic(u)) {
                    secondaryStructure = secondary_structure_1.ModelSecondaryStructure.Provider.get(u.model);
                    if (secondaryStructure) {
                        map.set(u.invariantId, secondaryStructure);
                    }
                }
            }
            return [2 /*return*/, map];
        });
    });
}
