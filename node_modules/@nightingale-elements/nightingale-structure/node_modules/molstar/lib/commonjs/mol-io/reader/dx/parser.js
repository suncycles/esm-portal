"use strict";
/**
 * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * Adapted from NGL.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDx = void 0;
var tslib_1 = require("tslib");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var mol_task_1 = require("../../../mol-task");
var number_parser_1 = require("../common/text/number-parser");
var tokenizer_1 = require("../common/text/tokenizer");
var result_1 = require("../result");
var utf8_1 = require("../../common/utf8");
function readHeader(tokenizer) {
    var header = { h: (0, linear_algebra_1.Vec3)() };
    var headerByteCount = 0;
    var deltaLineCount = 0;
    var reWhitespace = /\s+/g;
    while (true) {
        var line = tokenizer_1.Tokenizer.readLine(tokenizer);
        var ls = void 0;
        if (line.startsWith('object 1')) {
            ls = line.split(reWhitespace);
            header.dim = linear_algebra_1.Vec3.create(parseInt(ls[5]), parseInt(ls[6]), parseInt(ls[7]));
        }
        else if (line.startsWith('origin')) {
            ls = line.split(reWhitespace);
            header.min = linear_algebra_1.Vec3.create(parseFloat(ls[1]), parseFloat(ls[2]), parseFloat(ls[3]));
        }
        else if (line.startsWith('delta')) {
            ls = line.split(reWhitespace);
            if (deltaLineCount === 0) {
                header.h[0] = parseFloat(ls[1]);
            }
            else if (deltaLineCount === 1) {
                header.h[1] = parseFloat(ls[2]);
            }
            else if (deltaLineCount === 2) {
                header.h[2] = parseFloat(ls[3]);
            }
            deltaLineCount += 1;
        }
        else if (line.startsWith('object 3')) {
            headerByteCount += line.length + 1;
            break;
        }
        headerByteCount += line.length + 1;
    }
    return { header: header, headerByteCount: headerByteCount };
}
function readValuesText(ctx, tokenizer, header) {
    var N = header.dim[0] * header.dim[1] * header.dim[2];
    var chunkSize = 100 * 100 * 100;
    var data = new Float64Array(N);
    var offset = 0;
    return (0, mol_task_1.chunkedSubtask)(ctx, chunkSize, data, function (count, data) {
        var max = Math.min(N, offset + count);
        for (var i = offset; i < max; i++) {
            tokenizer_1.Tokenizer.skipWhitespace(tokenizer);
            tokenizer.tokenStart = tokenizer.position;
            tokenizer_1.Tokenizer.eatValue(tokenizer);
            data[i] = (0, number_parser_1.parseFloat)(tokenizer.data, tokenizer.tokenStart, tokenizer.tokenEnd);
        }
        offset = max;
        return max === N ? 0 : chunkSize;
    }, function (ctx, _, i) { return ctx.update({ current: Math.min(i, N), max: N }); });
}
function parseText(taskCtx, data, name) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var tokenizer, header, values;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, taskCtx.update('Reading header...')];
                case 1:
                    _a.sent();
                    tokenizer = (0, tokenizer_1.Tokenizer)(data);
                    header = readHeader(tokenizer).header;
                    return [4 /*yield*/, taskCtx.update('Reading values...')];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, readValuesText(taskCtx, tokenizer, header)];
                case 3:
                    values = _a.sent();
                    return [2 /*return*/, result_1.ReaderResult.success({ header: header, values: values, name: name })];
            }
        });
    });
}
function parseBinary(taskCtx, data, name) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var headerString, tokenizer, _a, header, headerByteCount, size, dv, values, i;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, taskCtx.update('Reading header...')];
                case 1:
                    _b.sent();
                    headerString = (0, utf8_1.utf8Read)(data, 0, 1000);
                    tokenizer = (0, tokenizer_1.Tokenizer)(headerString);
                    _a = readHeader(tokenizer), header = _a.header, headerByteCount = _a.headerByteCount;
                    return [4 /*yield*/, taskCtx.update('Reading values...')];
                case 2:
                    _b.sent();
                    size = header.dim[0] * header.dim[1] * header.dim[2];
                    dv = new DataView(data.buffer, data.byteOffset + headerByteCount);
                    values = new Float64Array(size);
                    for (i = 0; i < size; i++) {
                        values[i] = dv.getFloat64(i * 8, true);
                    }
                    // TODO: why doesnt this work? throw "attempting to construct out-of-bounds TypedArray"
                    // const values = new Float64Array(data.buffer, data.byteOffset + headerByteCount, header.dim[0] * header.dim[1] * header.dim[2]);
                    return [2 /*return*/, result_1.ReaderResult.success({ header: header, values: values, name: name })];
            }
        });
    });
}
function parseDx(data, name) {
    return mol_task_1.Task.create('Parse DX', function (taskCtx) {
        if (typeof data === 'string')
            return parseText(taskCtx, data, name);
        return parseBinary(taskCtx, data, name);
    });
}
exports.parseDx = parseDx;
