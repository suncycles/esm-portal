"use strict";
/**
 * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Fred Ludlow <fred.ludlow@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarchinCubesLinesBuilder = exports.MarchinCubesMeshBuilder = void 0;
var util_1 = require("../../../mol-data/util");
var mol_util_1 = require("../../../mol-util");
var mesh_1 = require("../../geometry/mesh/mesh");
var tables_1 = require("./tables");
var lines_builder_1 = require("../../geometry/lines/lines-builder");
function MarchinCubesMeshBuilder(vertexChunkSize, mesh) {
    var triangleChunkSize = Math.min(1 << 16, vertexChunkSize * 4);
    var vertices = util_1.ChunkedArray.create(Float32Array, 3, vertexChunkSize, mesh && mesh.vertexBuffer.ref.value);
    var normals = util_1.ChunkedArray.create(Float32Array, 3, vertexChunkSize, mesh && mesh.normalBuffer.ref.value);
    var groups = util_1.ChunkedArray.create(Float32Array, 1, vertexChunkSize, mesh && mesh.groupBuffer.ref.value);
    var indices = util_1.ChunkedArray.create(Uint32Array, 3, triangleChunkSize, mesh && mesh.indexBuffer.ref.value);
    var vertexCount = 0;
    var triangleCount = 0;
    return {
        addVertex: function (x, y, z) {
            ++vertexCount;
            return util_1.ChunkedArray.add3(vertices, x, y, z);
        },
        addNormal: function (x, y, z) {
            util_1.ChunkedArray.add3(normals, x, y, z);
        },
        addGroup: function (group) {
            util_1.ChunkedArray.add(groups, group);
        },
        addTriangle: function (vertList, a, b, c) {
            var i = vertList[a], j = vertList[b], k = vertList[c];
            // vertex indices <0 mean that the vertex was ignored and is not available
            // and hence we don't add a triangle when this occurs
            if (i >= 0 && j >= 0 && k >= 0) {
                ++triangleCount;
                util_1.ChunkedArray.add3(indices, i, j, k);
            }
        },
        get: function () {
            var vb = util_1.ChunkedArray.compact(vertices, true);
            var nb = util_1.ChunkedArray.compact(normals, true);
            var ib = util_1.ChunkedArray.compact(indices, true);
            var gb = util_1.ChunkedArray.compact(groups, true);
            return mesh_1.Mesh.create(vb, ib, nb, gb, vertexCount, triangleCount, mesh);
        }
    };
}
exports.MarchinCubesMeshBuilder = MarchinCubesMeshBuilder;
function MarchinCubesLinesBuilder(vertexChunkSize, lines) {
    var vertices = util_1.ChunkedArray.create(Float32Array, 3, vertexChunkSize);
    var groups = util_1.ChunkedArray.create(Float32Array, 1, vertexChunkSize);
    var indices = util_1.ChunkedArray.create(Float32Array, 2, vertexChunkSize);
    var linesCount = 0;
    return {
        addVertex: function (x, y, z) {
            return util_1.ChunkedArray.add3(vertices, x, y, z);
        },
        addNormal: function () { return mol_util_1.noop; },
        addGroup: function (group) {
            util_1.ChunkedArray.add(groups, group);
        },
        addTriangle: function (vertList, a, b, c, edgeFilter) {
            var i = vertList[a], j = vertList[b], k = vertList[c];
            // vertex indices <0 mean that the vertex was ignored and is not available
            // and hence we don't add a triangle when this occurs
            if (i >= 0 && j >= 0 && k >= 0) {
                if (tables_1.AllowedContours[a][b] & edgeFilter) {
                    ++linesCount;
                    util_1.ChunkedArray.add2(indices, vertList[a], vertList[b]);
                }
                if (tables_1.AllowedContours[b][c] & edgeFilter) {
                    ++linesCount;
                    util_1.ChunkedArray.add2(indices, vertList[b], vertList[c]);
                }
                if (tables_1.AllowedContours[a][c] & edgeFilter) {
                    ++linesCount;
                    util_1.ChunkedArray.add2(indices, vertList[a], vertList[c]);
                }
            }
        },
        get: function () {
            var vb = util_1.ChunkedArray.compact(vertices, true);
            var ib = util_1.ChunkedArray.compact(indices, true);
            var gb = util_1.ChunkedArray.compact(groups, true);
            var builder = lines_builder_1.LinesBuilder.create(linesCount, linesCount / 10, lines);
            for (var i = 0; i < linesCount; ++i) {
                var la = ib[i * 2], lb = ib[i * 2 + 1];
                builder.add(vb[la * 3], vb[la * 3 + 1], vb[la * 3 + 2], vb[lb * 3], vb[lb * 3 + 1], vb[lb * 3 + 2], gb[la]);
            }
            return builder.getLines();
        }
    };
}
exports.MarchinCubesLinesBuilder = MarchinCubesLinesBuilder;
