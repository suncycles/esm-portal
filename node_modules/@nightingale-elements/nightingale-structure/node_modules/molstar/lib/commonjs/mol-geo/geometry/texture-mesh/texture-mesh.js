"use strict";
/**
 * Copyright (c) 2019-2023 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextureMesh = void 0;
var tslib_1 = require("tslib");
var mol_util_1 = require("../../../mol-util");
var geometry_1 = require("../../../mol-math/geometry");
var param_definition_1 = require("../../../mol-util/param-definition");
var location_iterator_1 = require("../../../mol-geo/util/location-iterator");
var color_data_1 = require("../color-data");
var marker_data_1 = require("../marker-data");
var base_1 = require("../base");
var overpaint_data_1 = require("../overpaint-data");
var transparency_data_1 = require("../transparency-data");
var util_1 = require("../../../mol-gl/renderable/util");
var texture_1 = require("../../../mol-gl/webgl/texture");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var clipping_data_1 = require("../clipping-data");
var location_1 = require("../../../mol-model/location");
var substance_data_1 = require("../substance-data");
var TextureMesh;
(function (TextureMesh) {
    var DoubleBuffer = /** @class */ (function () {
        function DoubleBuffer() {
            this.index = 0;
            this.textures = [];
        }
        DoubleBuffer.prototype.get = function () {
            return this.textures[this.index];
        };
        DoubleBuffer.prototype.set = function (vertex, group, normal) {
            this.textures[this.index] = Object.assign(this.textures[this.index] || {}, {
                vertex: vertex,
                group: group,
                normal: normal
            });
            this.index = (this.index + 1) % 2;
        };
        DoubleBuffer.prototype.destroy = function () {
            for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {
                var buffer = _a[_i];
                buffer.vertex.destroy();
                buffer.group.destroy();
                buffer.normal.destroy();
            }
        };
        return DoubleBuffer;
    }());
    TextureMesh.DoubleBuffer = DoubleBuffer;
    function create(vertexCount, groupCount, vertexTexture, groupTexture, normalTexture, boundingSphere, textureMesh) {
        var width = vertexTexture.getWidth();
        var height = vertexTexture.getHeight();
        if (textureMesh) {
            textureMesh.vertexCount = vertexCount;
            textureMesh.groupCount = groupCount;
            mol_util_1.ValueCell.update(textureMesh.geoTextureDim, linear_algebra_1.Vec2.set(textureMesh.geoTextureDim.ref.value, width, height));
            mol_util_1.ValueCell.update(textureMesh.vertexTexture, vertexTexture);
            mol_util_1.ValueCell.update(textureMesh.groupTexture, groupTexture);
            mol_util_1.ValueCell.update(textureMesh.normalTexture, normalTexture);
            textureMesh.doubleBuffer.set(vertexTexture, groupTexture, normalTexture);
            geometry_1.Sphere3D.copy(textureMesh.boundingSphere, boundingSphere);
            return textureMesh;
        }
        else {
            return {
                kind: 'texture-mesh',
                vertexCount: vertexCount,
                groupCount: groupCount,
                geoTextureDim: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(width, height)),
                vertexTexture: mol_util_1.ValueCell.create(vertexTexture),
                groupTexture: mol_util_1.ValueCell.create(groupTexture),
                normalTexture: mol_util_1.ValueCell.create(normalTexture),
                varyingGroup: mol_util_1.ValueCell.create(false),
                doubleBuffer: new DoubleBuffer(),
                boundingSphere: geometry_1.Sphere3D.clone(boundingSphere),
                meta: {}
            };
        }
    }
    TextureMesh.create = create;
    function createEmpty(textureMesh) {
        var vt = textureMesh ? textureMesh.vertexTexture.ref.value : (0, texture_1.createNullTexture)();
        var gt = textureMesh ? textureMesh.groupTexture.ref.value : (0, texture_1.createNullTexture)();
        var nt = textureMesh ? textureMesh.normalTexture.ref.value : (0, texture_1.createNullTexture)();
        var bs = textureMesh ? textureMesh.boundingSphere : (0, geometry_1.Sphere3D)();
        return create(0, 0, vt, gt, nt, bs, textureMesh);
    }
    TextureMesh.createEmpty = createEmpty;
    TextureMesh.Params = tslib_1.__assign(tslib_1.__assign({}, base_1.BaseGeometry.Params), { doubleSided: param_definition_1.ParamDefinition.Boolean(false, base_1.BaseGeometry.CustomQualityParamInfo), flipSided: param_definition_1.ParamDefinition.Boolean(false, base_1.BaseGeometry.ShadingCategory), flatShaded: param_definition_1.ParamDefinition.Boolean(false, base_1.BaseGeometry.ShadingCategory), ignoreLight: param_definition_1.ParamDefinition.Boolean(false, base_1.BaseGeometry.ShadingCategory), xrayShaded: param_definition_1.ParamDefinition.Boolean(false, base_1.BaseGeometry.ShadingCategory), transparentBackfaces: param_definition_1.ParamDefinition.Select('off', param_definition_1.ParamDefinition.arrayToOptions(['off', 'on', 'opaque']), base_1.BaseGeometry.ShadingCategory), bumpFrequency: param_definition_1.ParamDefinition.Numeric(0, { min: 0, max: 10, step: 0.1 }, base_1.BaseGeometry.ShadingCategory), bumpAmplitude: param_definition_1.ParamDefinition.Numeric(1, { min: 0, max: 5, step: 0.1 }, base_1.BaseGeometry.ShadingCategory) });
    TextureMesh.Utils = {
        Params: TextureMesh.Params,
        createEmpty: createEmpty,
        createValues: createValues,
        createValuesSimple: createValuesSimple,
        updateValues: updateValues,
        updateBoundingSphere: updateBoundingSphere,
        createRenderableState: createRenderableState,
        updateRenderableState: updateRenderableState,
        createPositionIterator: createPositionIterator,
    };
    var TextureMeshName = 'texture-mesh';
    function createPositionIterator(textureMesh, transform) {
        var webgl = textureMesh.meta.webgl;
        if (!webgl)
            return (0, location_iterator_1.LocationIterator)(1, 1, 1, function () { return location_1.NullLocation; });
        if (!webgl.namedFramebuffers[TextureMeshName]) {
            webgl.namedFramebuffers[TextureMeshName] = webgl.resources.framebuffer();
        }
        var framebuffer = webgl.namedFramebuffers[TextureMeshName];
        var _a = textureMesh.geoTextureDim.ref.value, width = _a[0], height = _a[1];
        var vertices = new Float32Array(width * height * 4);
        framebuffer.bind();
        textureMesh.vertexTexture.ref.value.attachFramebuffer(framebuffer, 0);
        webgl.readPixels(0, 0, width, height, vertices);
        var groupCount = textureMesh.vertexCount;
        var instanceCount = transform.instanceCount.ref.value;
        var location = (0, location_iterator_1.PositionLocation)();
        var p = location.position;
        var v = vertices;
        var m = transform.aTransform.ref.value;
        var getLocation = function (groupIndex, instanceIndex) {
            if (instanceIndex < 0) {
                linear_algebra_1.Vec3.fromArray(p, v, groupIndex * 4);
            }
            else {
                linear_algebra_1.Vec3.transformMat4Offset(p, v, m, 0, groupIndex * 4, instanceIndex * 16);
            }
            return location;
        };
        return (0, location_iterator_1.LocationIterator)(groupCount, instanceCount, 1, getLocation);
    }
    function createValues(textureMesh, transform, locationIt, theme, props) {
        var instanceCount = locationIt.instanceCount, groupCount = locationIt.groupCount;
        var positionIt = TextureMesh.Utils.createPositionIterator(textureMesh, transform);
        var color = (0, color_data_1.createColors)(locationIt, positionIt, theme.color);
        var marker = props.instanceGranularity
            ? (0, marker_data_1.createMarkers)(instanceCount, 'instance')
            : (0, marker_data_1.createMarkers)(instanceCount * groupCount, 'groupInstance');
        var overpaint = (0, overpaint_data_1.createEmptyOverpaint)();
        var transparency = (0, transparency_data_1.createEmptyTransparency)();
        var substance = (0, substance_data_1.createEmptySubstance)();
        var clipping = (0, clipping_data_1.createEmptyClipping)();
        var counts = { drawCount: textureMesh.vertexCount, vertexCount: textureMesh.vertexCount, groupCount: groupCount, instanceCount: instanceCount };
        var invariantBoundingSphere = geometry_1.Sphere3D.clone(textureMesh.boundingSphere);
        var boundingSphere = (0, util_1.calculateTransformBoundingSphere)(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount, 0);
        return tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ dGeometryType: mol_util_1.ValueCell.create('textureMesh'), uGeoTexDim: textureMesh.geoTextureDim, tPosition: textureMesh.vertexTexture, tGroup: textureMesh.groupTexture, tNormal: textureMesh.normalTexture, dVaryingGroup: textureMesh.varyingGroup, boundingSphere: mol_util_1.ValueCell.create(boundingSphere), invariantBoundingSphere: mol_util_1.ValueCell.create(invariantBoundingSphere), uInvariantBoundingSphere: mol_util_1.ValueCell.create(linear_algebra_1.Vec4.ofSphere(invariantBoundingSphere)) }, color), marker), overpaint), transparency), substance), clipping), transform), base_1.BaseGeometry.createValues(props, counts)), { uDoubleSided: mol_util_1.ValueCell.create(props.doubleSided), dFlatShaded: mol_util_1.ValueCell.create(props.flatShaded), dFlipSided: mol_util_1.ValueCell.create(props.flipSided), dIgnoreLight: mol_util_1.ValueCell.create(props.ignoreLight), dXrayShaded: mol_util_1.ValueCell.create(props.xrayShaded), dTransparentBackfaces: mol_util_1.ValueCell.create(props.transparentBackfaces), uBumpFrequency: mol_util_1.ValueCell.create(props.bumpFrequency), uBumpAmplitude: mol_util_1.ValueCell.create(props.bumpAmplitude), meta: mol_util_1.ValueCell.create(textureMesh.meta) });
    }
    function createValuesSimple(textureMesh, props, colorValue, sizeValue, transform) {
        var s = base_1.BaseGeometry.createSimple(colorValue, sizeValue, transform);
        var p = tslib_1.__assign(tslib_1.__assign({}, param_definition_1.ParamDefinition.getDefaultValues(TextureMesh.Params)), props);
        return createValues(textureMesh, s.transform, s.locationIterator, s.theme, p);
    }
    function updateValues(values, props) {
        base_1.BaseGeometry.updateValues(values, props);
        mol_util_1.ValueCell.updateIfChanged(values.uDoubleSided, props.doubleSided);
        mol_util_1.ValueCell.updateIfChanged(values.dFlatShaded, props.flatShaded);
        mol_util_1.ValueCell.updateIfChanged(values.dFlipSided, props.flipSided);
        mol_util_1.ValueCell.updateIfChanged(values.dIgnoreLight, props.ignoreLight);
        mol_util_1.ValueCell.updateIfChanged(values.dXrayShaded, props.xrayShaded);
        mol_util_1.ValueCell.updateIfChanged(values.dTransparentBackfaces, props.transparentBackfaces);
        mol_util_1.ValueCell.updateIfChanged(values.uBumpFrequency, props.bumpFrequency);
        mol_util_1.ValueCell.updateIfChanged(values.uBumpAmplitude, props.bumpAmplitude);
    }
    function updateBoundingSphere(values, textureMesh) {
        var invariantBoundingSphere = geometry_1.Sphere3D.clone(textureMesh.boundingSphere);
        var boundingSphere = (0, util_1.calculateTransformBoundingSphere)(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value, 0);
        if (!geometry_1.Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {
            mol_util_1.ValueCell.update(values.boundingSphere, boundingSphere);
        }
        if (!geometry_1.Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {
            mol_util_1.ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);
            mol_util_1.ValueCell.update(values.uInvariantBoundingSphere, linear_algebra_1.Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));
        }
    }
    function createRenderableState(props) {
        var state = base_1.BaseGeometry.createRenderableState(props);
        updateRenderableState(state, props);
        return state;
    }
    function updateRenderableState(state, props) {
        base_1.BaseGeometry.updateRenderableState(state, props);
        state.opaque = state.opaque && !props.xrayShaded;
        state.writeDepth = state.opaque;
    }
})(TextureMesh = exports.TextureMesh || (exports.TextureMesh = {}));
