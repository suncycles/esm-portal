"use strict";
/**
 * Copyright (c) 2018-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.addOrientedBox = exports.addBoundingBox = void 0;
var linear_algebra_1 = require("../../../../mol-math/linear-algebra");
var geometry_1 = require("../../../../mol-math/geometry");
var mesh_builder_1 = require("../mesh-builder");
var cylinder_1 = require("./cylinder");
var sphere_1 = require("./sphere");
var cage_1 = require("../../../primitive/cage");
var tmpStart = linear_algebra_1.Vec3.zero();
var tmpEnd = linear_algebra_1.Vec3.zero();
var cylinderProps = {};
function addBoundingBox(state, box, radius, detail, radialSegments) {
    var min = box.min, max = box.max;
    cylinderProps.radiusTop = radius;
    cylinderProps.radiusBottom = radius;
    cylinderProps.radialSegments = radialSegments;
    linear_algebra_1.Vec3.set(tmpStart, max[0], max[1], max[2]);
    (0, sphere_1.addSphere)(state, tmpStart, radius, detail);
    linear_algebra_1.Vec3.set(tmpEnd, max[0], max[1], min[2]);
    (0, cylinder_1.addCylinder)(state, tmpStart, tmpEnd, 1, cylinderProps);
    linear_algebra_1.Vec3.set(tmpEnd, max[0], min[1], max[2]);
    (0, cylinder_1.addCylinder)(state, tmpStart, tmpEnd, 1, cylinderProps);
    linear_algebra_1.Vec3.set(tmpEnd, min[0], max[1], max[2]);
    (0, cylinder_1.addCylinder)(state, tmpStart, tmpEnd, 1, cylinderProps);
    linear_algebra_1.Vec3.set(tmpStart, min[0], min[1], min[2]);
    (0, sphere_1.addSphere)(state, tmpStart, radius, detail);
    linear_algebra_1.Vec3.set(tmpEnd, min[0], min[1], max[2]);
    (0, cylinder_1.addCylinder)(state, tmpStart, tmpEnd, 1, cylinderProps);
    linear_algebra_1.Vec3.set(tmpEnd, min[0], max[1], min[2]);
    (0, cylinder_1.addCylinder)(state, tmpStart, tmpEnd, 1, cylinderProps);
    linear_algebra_1.Vec3.set(tmpEnd, max[0], min[1], min[2]);
    (0, cylinder_1.addCylinder)(state, tmpStart, tmpEnd, 1, cylinderProps);
    linear_algebra_1.Vec3.set(tmpStart, max[0], min[1], min[2]);
    (0, sphere_1.addSphere)(state, tmpStart, radius, detail);
    linear_algebra_1.Vec3.set(tmpEnd, max[0], min[1], max[2]);
    (0, cylinder_1.addCylinder)(state, tmpStart, tmpEnd, 1, cylinderProps);
    linear_algebra_1.Vec3.set(tmpEnd, max[0], max[1], min[2]);
    (0, cylinder_1.addCylinder)(state, tmpStart, tmpEnd, 1, cylinderProps);
    linear_algebra_1.Vec3.set(tmpStart, min[0], min[1], max[2]);
    (0, sphere_1.addSphere)(state, tmpStart, radius, detail);
    linear_algebra_1.Vec3.set(tmpEnd, min[0], max[1], max[2]);
    (0, cylinder_1.addCylinder)(state, tmpStart, tmpEnd, 1, cylinderProps);
    linear_algebra_1.Vec3.set(tmpEnd, max[0], min[1], max[2]);
    (0, cylinder_1.addCylinder)(state, tmpStart, tmpEnd, 1, cylinderProps);
    linear_algebra_1.Vec3.set(tmpStart, min[0], max[1], min[2]);
    (0, sphere_1.addSphere)(state, tmpStart, radius, detail);
    linear_algebra_1.Vec3.set(tmpEnd, max[0], max[1], min[2]);
    (0, sphere_1.addSphere)(state, tmpEnd, radius, detail);
    (0, cylinder_1.addCylinder)(state, tmpStart, tmpEnd, 1, cylinderProps);
    linear_algebra_1.Vec3.set(tmpEnd, min[0], max[1], max[2]);
    (0, sphere_1.addSphere)(state, tmpEnd, radius, detail);
    (0, cylinder_1.addCylinder)(state, tmpStart, tmpEnd, 1, cylinderProps);
}
exports.addBoundingBox = addBoundingBox;
//
var tmpBoxVecCorner = (0, linear_algebra_1.Vec3)();
var tmpBoxVecA = (0, linear_algebra_1.Vec3)();
var tmpBoxVecB = (0, linear_algebra_1.Vec3)();
var tmpBoxVecC = (0, linear_algebra_1.Vec3)();
var tmpMatrix = linear_algebra_1.Mat4.identity();
var tmpVertices = new Float32Array(8 * 3);
var tmpEdges = new Uint8Array([
    0, 1, 0, 3, 0, 6, 1, 2, 1, 7, 2, 3,
    2, 4, 3, 5, 4, 5, 4, 7, 5, 6, 6, 7
]);
function addOrientedBox(state, axes, radiusScale, detail, radialSegments) {
    var origin = axes.origin, dirA = axes.dirA, dirB = axes.dirB, dirC = axes.dirC;
    var negDirA = linear_algebra_1.Vec3.negate(tmpBoxVecA, dirA);
    var negDirB = linear_algebra_1.Vec3.negate(tmpBoxVecB, dirB);
    var negDirC = linear_algebra_1.Vec3.negate(tmpBoxVecC, dirC);
    var offset = 0;
    var addCornerHelper = function (v1, v2, v3) {
        linear_algebra_1.Vec3.copy(tmpBoxVecCorner, origin);
        linear_algebra_1.Vec3.add(tmpBoxVecCorner, tmpBoxVecCorner, v1);
        linear_algebra_1.Vec3.add(tmpBoxVecCorner, tmpBoxVecCorner, v2);
        linear_algebra_1.Vec3.add(tmpBoxVecCorner, tmpBoxVecCorner, v3);
        linear_algebra_1.Vec3.toArray(tmpBoxVecCorner, tmpVertices, offset);
        offset += 3;
    };
    addCornerHelper(dirA, dirB, dirC);
    addCornerHelper(dirA, dirB, negDirC);
    addCornerHelper(dirA, negDirB, negDirC);
    addCornerHelper(dirA, negDirB, dirC);
    addCornerHelper(negDirA, negDirB, negDirC);
    addCornerHelper(negDirA, negDirB, dirC);
    addCornerHelper(negDirA, dirB, dirC);
    addCornerHelper(negDirA, dirB, negDirC);
    var cage = (0, cage_1.createCage)(tmpVertices, tmpEdges);
    var volume = geometry_1.Axes3D.volume(axes);
    var radius = (Math.cbrt(volume) / 300) * radiusScale;
    mesh_builder_1.MeshBuilder.addCage(state, tmpMatrix, cage, radius, detail, radialSegments);
}
exports.addOrientedBox = addOrientedBox;
