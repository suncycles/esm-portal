"use strict";
/**
 * Copyright (c) 2018-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGridColor = exports.createTextureColor = exports.createValueColor = exports.createColors = void 0;
var mol_util_1 = require("../../mol-util");
var util_1 = require("../../mol-gl/renderable/util");
var color_1 = require("../../mol-util/color");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var location_1 = require("../../mol-model/location");
var texture_1 = require("../../mol-gl/webgl/texture");
function createColors(locationIt, positionIt, colorTheme, colorData) {
    var data = _createColors(locationIt, positionIt, colorTheme, colorData);
    if (colorTheme.palette) {
        mol_util_1.ValueCell.updateIfChanged(data.dUsePalette, true);
        updatePaletteTexture(colorTheme.palette, data.tPalette);
    }
    else {
        mol_util_1.ValueCell.updateIfChanged(data.dUsePalette, false);
    }
    return data;
}
exports.createColors = createColors;
function _createColors(locationIt, positionIt, colorTheme, colorData) {
    switch (colorTheme.granularity) {
        case 'uniform': return createUniformColor(locationIt, colorTheme.color, colorData);
        case 'instance':
            return locationIt.nonInstanceable
                ? createGroupColor(locationIt, colorTheme.color, colorData)
                : createInstanceColor(locationIt, colorTheme.color, colorData);
        case 'group': return createGroupColor(locationIt, colorTheme.color, colorData);
        case 'groupInstance': return createGroupInstanceColor(locationIt, colorTheme.color, colorData);
        case 'vertex': return createVertexColor(positionIt, colorTheme.color, colorData);
        case 'vertexInstance': return createVertexInstanceColor(positionIt, colorTheme.color, colorData);
        case 'volume': return createGridColor(colorTheme.grid, 'volume', colorData);
        case 'volumeInstance': return createGridColor(colorTheme.grid, 'volumeInstance', colorData);
        case 'direct': return createDirectColor(colorData);
    }
}
function updatePaletteTexture(palette, cell) {
    var isSynced = true;
    var texture = cell.ref.value;
    if (palette.colors.length !== texture.width || texture.filter !== palette.filter) {
        isSynced = false;
    }
    else {
        var data = texture.array;
        var o_1 = 0;
        for (var _i = 0, _a = palette.colors; _i < _a.length; _i++) {
            var c = _a[_i];
            var _b = color_1.Color.toRgb(c), r = _b[0], g = _b[1], b = _b[2];
            if (data[o_1++] !== r || data[o_1++] !== g || data[o_1++] !== b) {
                isSynced = false;
                break;
            }
        }
    }
    if (isSynced)
        return;
    var array = new Uint8Array(palette.colors.length * 3);
    var o = 0;
    for (var _c = 0, _d = palette.colors; _c < _d.length; _c++) {
        var c = _d[_c];
        var _e = color_1.Color.toRgb(c), r = _e[0], g = _e[1], b = _e[2];
        array[o++] = r;
        array[o++] = g;
        array[o++] = b;
    }
    mol_util_1.ValueCell.update(cell, { array: array, height: 1, width: palette.colors.length, filter: palette.filter });
}
//
function createValueColor(value, colorData) {
    if (colorData) {
        mol_util_1.ValueCell.update(colorData.uColor, color_1.Color.toVec3Normalized(colorData.uColor.ref.value, value));
        mol_util_1.ValueCell.updateIfChanged(colorData.dColorType, 'uniform');
        return colorData;
    }
    else {
        return {
            uColor: mol_util_1.ValueCell.create(color_1.Color.toVec3Normalized((0, linear_algebra_1.Vec3)(), value)),
            tColor: mol_util_1.ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
            tColorGrid: mol_util_1.ValueCell.create((0, texture_1.createNullTexture)()),
            tPalette: mol_util_1.ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
            uColorTexDim: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(1, 1)),
            uColorGridDim: mol_util_1.ValueCell.create(linear_algebra_1.Vec3.create(1, 1, 1)),
            uColorGridTransform: mol_util_1.ValueCell.create(linear_algebra_1.Vec4.create(0, 0, 0, 1)),
            dColorType: mol_util_1.ValueCell.create('uniform'),
            dUsePalette: mol_util_1.ValueCell.create(false),
        };
    }
}
exports.createValueColor = createValueColor;
/** Creates color uniform */
function createUniformColor(locationIt, color, colorData) {
    return createValueColor(color(location_1.NullLocation, false), colorData);
}
//
function createTextureColor(colors, type, colorData) {
    if (colorData) {
        mol_util_1.ValueCell.update(colorData.tColor, colors);
        mol_util_1.ValueCell.update(colorData.uColorTexDim, linear_algebra_1.Vec2.create(colors.width, colors.height));
        mol_util_1.ValueCell.updateIfChanged(colorData.dColorType, type);
        return colorData;
    }
    else {
        return {
            uColor: mol_util_1.ValueCell.create((0, linear_algebra_1.Vec3)()),
            tColor: mol_util_1.ValueCell.create(colors),
            tColorGrid: mol_util_1.ValueCell.create((0, texture_1.createNullTexture)()),
            tPalette: mol_util_1.ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
            uColorTexDim: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(colors.width, colors.height)),
            uColorGridDim: mol_util_1.ValueCell.create(linear_algebra_1.Vec3.create(1, 1, 1)),
            uColorGridTransform: mol_util_1.ValueCell.create(linear_algebra_1.Vec4.create(0, 0, 0, 1)),
            dColorType: mol_util_1.ValueCell.create(type),
            dUsePalette: mol_util_1.ValueCell.create(false),
        };
    }
}
exports.createTextureColor = createTextureColor;
/** Creates color texture with color for each instance */
function createInstanceColor(locationIt, color, colorData) {
    var instanceCount = locationIt.instanceCount;
    var colors = (0, util_1.createTextureImage)(Math.max(1, instanceCount), 3, Uint8Array, colorData && colorData.tColor.ref.value.array);
    locationIt.reset();
    while (locationIt.hasNext) {
        var _a = locationIt.move(), location_2 = _a.location, isSecondary = _a.isSecondary, instanceIndex = _a.instanceIndex;
        color_1.Color.toArray(color(location_2, isSecondary), colors.array, instanceIndex * 3);
        locationIt.skipInstance();
    }
    return createTextureColor(colors, 'instance', colorData);
}
/** Creates color texture with color for each group (i.e. shared across instances) */
function createGroupColor(locationIt, color, colorData) {
    var groupCount = locationIt.groupCount;
    var colors = (0, util_1.createTextureImage)(Math.max(1, groupCount), 3, Uint8Array, colorData && colorData.tColor.ref.value.array);
    locationIt.reset();
    while (locationIt.hasNext && !locationIt.isNextNewInstance) {
        var _a = locationIt.move(), location_3 = _a.location, isSecondary = _a.isSecondary, groupIndex = _a.groupIndex;
        color_1.Color.toArray(color(location_3, isSecondary), colors.array, groupIndex * 3);
    }
    return createTextureColor(colors, 'group', colorData);
}
/** Creates color texture with color for each group in each instance */
function createGroupInstanceColor(locationIt, color, colorData) {
    var groupCount = locationIt.groupCount, instanceCount = locationIt.instanceCount;
    var count = instanceCount * groupCount;
    var colors = (0, util_1.createTextureImage)(Math.max(1, count), 3, Uint8Array, colorData && colorData.tColor.ref.value.array);
    locationIt.reset();
    while (locationIt.hasNext) {
        var _a = locationIt.move(), location_4 = _a.location, isSecondary = _a.isSecondary, index = _a.index;
        color_1.Color.toArray(color(location_4, isSecondary), colors.array, index * 3);
    }
    return createTextureColor(colors, 'groupInstance', colorData);
}
/** Creates color texture with color for each vertex (i.e. shared across instances) */
function createVertexColor(locationIt, color, colorData) {
    var groupCount = locationIt.groupCount, stride = locationIt.stride;
    var colors = (0, util_1.createTextureImage)(Math.max(1, groupCount), 3, Uint8Array, colorData && colorData.tColor.ref.value.array);
    locationIt.reset();
    locationIt.voidInstances();
    while (locationIt.hasNext && !locationIt.isNextNewInstance) {
        var _a = locationIt.move(), location_5 = _a.location, isSecondary = _a.isSecondary, groupIndex = _a.groupIndex;
        var c = color(location_5, isSecondary);
        for (var i = 0; i < stride; ++i) {
            color_1.Color.toArray(c, colors.array, (groupIndex + i) * 3);
        }
    }
    return createTextureColor(colors, 'vertex', colorData);
}
/** Creates color texture with color for each vertex in each instance */
function createVertexInstanceColor(locationIt, color, colorData) {
    var groupCount = locationIt.groupCount, instanceCount = locationIt.instanceCount, stride = locationIt.stride;
    var count = instanceCount * groupCount;
    var colors = (0, util_1.createTextureImage)(Math.max(1, count), 3, Uint8Array, colorData && colorData.tColor.ref.value.array);
    locationIt.reset();
    while (locationIt.hasNext) {
        var _a = locationIt.move(), location_6 = _a.location, isSecondary = _a.isSecondary, index = _a.index;
        var c = color(location_6, isSecondary);
        for (var i = 0; i < stride; ++i) {
            color_1.Color.toArray(c, colors.array, (index + i) * 3);
        }
    }
    return createTextureColor(colors, 'vertexInstance', colorData);
}
//
function createGridColor(grid, type, colorData) {
    var colors = grid.colors, dimension = grid.dimension, transform = grid.transform;
    var width = colors.getWidth();
    var height = colors.getHeight();
    if (colorData) {
        mol_util_1.ValueCell.update(colorData.tColorGrid, colors);
        mol_util_1.ValueCell.update(colorData.uColorTexDim, linear_algebra_1.Vec2.create(width, height));
        mol_util_1.ValueCell.update(colorData.uColorGridDim, linear_algebra_1.Vec3.clone(dimension));
        mol_util_1.ValueCell.update(colorData.uColorGridTransform, linear_algebra_1.Vec4.clone(transform));
        mol_util_1.ValueCell.updateIfChanged(colorData.dColorType, type);
        return colorData;
    }
    else {
        return {
            uColor: mol_util_1.ValueCell.create((0, linear_algebra_1.Vec3)()),
            tColor: mol_util_1.ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
            tColorGrid: mol_util_1.ValueCell.create(colors),
            tPalette: mol_util_1.ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
            uColorTexDim: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(width, height)),
            uColorGridDim: mol_util_1.ValueCell.create(linear_algebra_1.Vec3.clone(dimension)),
            uColorGridTransform: mol_util_1.ValueCell.create(linear_algebra_1.Vec4.clone(transform)),
            dColorType: mol_util_1.ValueCell.create(type),
            dUsePalette: mol_util_1.ValueCell.create(false),
        };
    }
}
exports.createGridColor = createGridColor;
//
/** Creates direct color */
function createDirectColor(colorData) {
    if (colorData) {
        mol_util_1.ValueCell.updateIfChanged(colorData.dColorType, 'direct');
        return colorData;
    }
    else {
        return {
            uColor: mol_util_1.ValueCell.create((0, linear_algebra_1.Vec3)()),
            tColor: mol_util_1.ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
            tColorGrid: mol_util_1.ValueCell.create((0, texture_1.createNullTexture)()),
            tPalette: mol_util_1.ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
            uColorTexDim: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(1, 1)),
            uColorGridDim: mol_util_1.ValueCell.create(linear_algebra_1.Vec3.create(1, 1, 1)),
            uColorGridTransform: mol_util_1.ValueCell.create(linear_algebra_1.Vec4.create(0, 0, 0, 1)),
            dColorType: mol_util_1.ValueCell.create('direct'),
            dUsePalette: mol_util_1.ValueCell.create(false),
        };
    }
}
