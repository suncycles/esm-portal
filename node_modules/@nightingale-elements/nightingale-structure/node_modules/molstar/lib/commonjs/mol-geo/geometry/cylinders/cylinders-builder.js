"use strict";
/**
 * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CylindersBuilder = void 0;
var util_1 = require("../../../mol-data/util");
var cylinders_1 = require("./cylinders");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var tmpVecA = (0, linear_algebra_1.Vec3)();
var tmpVecB = (0, linear_algebra_1.Vec3)();
var tmpDir = (0, linear_algebra_1.Vec3)();
// avoiding namespace lookup improved performance in Chrome (Aug 2020)
var caAdd = util_1.ChunkedArray.add;
var caAdd3 = util_1.ChunkedArray.add3;
var CylindersBuilder;
(function (CylindersBuilder) {
    function create(initialCount, chunkSize, cylinders) {
        if (initialCount === void 0) { initialCount = 2048; }
        if (chunkSize === void 0) { chunkSize = 1024; }
        var groups = util_1.ChunkedArray.create(Float32Array, 1, chunkSize, cylinders ? cylinders.groupBuffer.ref.value : initialCount);
        var starts = util_1.ChunkedArray.create(Float32Array, 3, chunkSize, cylinders ? cylinders.startBuffer.ref.value : initialCount);
        var ends = util_1.ChunkedArray.create(Float32Array, 3, chunkSize, cylinders ? cylinders.endBuffer.ref.value : initialCount);
        var scales = util_1.ChunkedArray.create(Float32Array, 1, chunkSize, cylinders ? cylinders.scaleBuffer.ref.value : initialCount);
        var caps = util_1.ChunkedArray.create(Float32Array, 1, chunkSize, cylinders ? cylinders.capBuffer.ref.value : initialCount);
        var add = function (startX, startY, startZ, endX, endY, endZ, radiusScale, topCap, bottomCap, group) {
            for (var i = 0; i < 6; ++i) {
                caAdd3(starts, startX, startY, startZ);
                caAdd3(ends, endX, endY, endZ);
                caAdd(groups, group);
                caAdd(scales, radiusScale);
                caAdd(caps, (topCap ? 1 : 0) + (bottomCap ? 2 : 0));
            }
        };
        var addFixedCountDashes = function (start, end, segmentCount, radiusScale, topCap, bottomCap, group) {
            var d = linear_algebra_1.Vec3.distance(start, end);
            var s = Math.floor(segmentCount / 2);
            var step = 1 / segmentCount;
            linear_algebra_1.Vec3.sub(tmpDir, end, start);
            for (var j = 0; j < s; ++j) {
                var f = step * (j * 2 + 1);
                linear_algebra_1.Vec3.setMagnitude(tmpDir, tmpDir, d * f);
                linear_algebra_1.Vec3.add(tmpVecA, start, tmpDir);
                linear_algebra_1.Vec3.setMagnitude(tmpDir, tmpDir, d * step * ((j + 1) * 2));
                linear_algebra_1.Vec3.add(tmpVecB, start, tmpDir);
                add(tmpVecA[0], tmpVecA[1], tmpVecA[2], tmpVecB[0], tmpVecB[1], tmpVecB[2], radiusScale, topCap, bottomCap, group);
            }
        };
        return {
            add: add,
            addFixedCountDashes: addFixedCountDashes,
            addFixedLengthDashes: function (start, end, segmentLength, radiusScale, topCap, bottomCap, group) {
                var d = linear_algebra_1.Vec3.distance(start, end);
                addFixedCountDashes(start, end, d / segmentLength, radiusScale, topCap, bottomCap, group);
            },
            getCylinders: function () {
                var cylinderCount = groups.elementCount / 6;
                var gb = util_1.ChunkedArray.compact(groups, true);
                var sb = util_1.ChunkedArray.compact(starts, true);
                var eb = util_1.ChunkedArray.compact(ends, true);
                var ab = util_1.ChunkedArray.compact(scales, true);
                var cb = util_1.ChunkedArray.compact(caps, true);
                var mb = cylinders && cylinderCount <= cylinders.cylinderCount ? cylinders.mappingBuffer.ref.value : new Float32Array(cylinderCount * 18);
                var ib = cylinders && cylinderCount <= cylinders.cylinderCount ? cylinders.indexBuffer.ref.value : new Uint32Array(cylinderCount * 12);
                if (!cylinders || cylinderCount > cylinders.cylinderCount)
                    fillMappingAndIndices(cylinderCount, mb, ib);
                return cylinders_1.Cylinders.create(mb, ib, gb, sb, eb, ab, cb, cylinderCount, cylinders);
            }
        };
    }
    CylindersBuilder.create = create;
})(CylindersBuilder = exports.CylindersBuilder || (exports.CylindersBuilder = {}));
function fillMappingAndIndices(n, mb, ib) {
    for (var i = 0; i < n; ++i) {
        var mo = i * 18;
        mb[mo] = -1;
        mb[mo + 1] = 1;
        mb[mo + 2] = -1;
        mb[mo + 3] = -1;
        mb[mo + 4] = -1;
        mb[mo + 5] = -1;
        mb[mo + 6] = 1;
        mb[mo + 7] = 1;
        mb[mo + 8] = -1;
        mb[mo + 9] = 1;
        mb[mo + 10] = 1;
        mb[mo + 11] = 1;
        mb[mo + 12] = 1;
        mb[mo + 13] = -1;
        mb[mo + 14] = -1;
        mb[mo + 15] = 1;
        mb[mo + 16] = -1;
        mb[mo + 17] = 1;
    }
    for (var i = 0; i < n; ++i) {
        var o = i * 6;
        var io = i * 12;
        ib[io] = o;
        ib[io + 1] = o + 1;
        ib[io + 2] = o + 2;
        ib[io + 3] = o + 1;
        ib[io + 4] = o + 4;
        ib[io + 5] = o + 2;
        ib[io + 6] = o + 2;
        ib[io + 7] = o + 4;
        ib[io + 8] = o + 3;
        ib[io + 9] = o + 4;
        ib[io + 10] = o + 5;
        ib[io + 11] = o + 3;
    }
}
