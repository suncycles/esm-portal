"use strict";
/**
 * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateTransformData = exports.fillIdentityTransform = exports.createIdentityTransform = exports.createTransform = void 0;
var mol_util_1 = require("../../mol-util");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var array_1 = require("../../mol-util/array");
var _m3 = (0, linear_algebra_1.Mat3)();
var _m4 = (0, linear_algebra_1.Mat4)();
function checkReflection(transformArray, instanceCount) {
    for (var i = 0; i < instanceCount; i++) {
        linear_algebra_1.Mat3.fromMat4(_m3, linear_algebra_1.Mat4.fromArray(_m4, transformArray, i * 16));
        if (linear_algebra_1.Mat3.determinant(_m3) < 0)
            return true;
    }
    return false;
}
function createTransform(transformArray, instanceCount, transformData) {
    var hasReflection = checkReflection(transformArray, instanceCount);
    if (transformData) {
        mol_util_1.ValueCell.update(transformData.matrix, transformData.matrix.ref.value);
        var transform = transformData.transform.ref.value.length >= instanceCount * 16 ? transformData.transform.ref.value : new Float32Array(instanceCount * 16);
        transform.set(transformArray);
        mol_util_1.ValueCell.update(transformData.transform, transform);
        mol_util_1.ValueCell.updateIfChanged(transformData.uInstanceCount, instanceCount);
        mol_util_1.ValueCell.updateIfChanged(transformData.instanceCount, instanceCount);
        var aTransform = transformData.aTransform.ref.value.length >= instanceCount * 16 ? transformData.aTransform.ref.value : new Float32Array(instanceCount * 16);
        mol_util_1.ValueCell.update(transformData.aTransform, aTransform);
        // Note that this sets `extraTransform` to identity transforms
        var extraTransform = transformData.extraTransform.ref.value.length >= instanceCount * 16 ? transformData.extraTransform.ref.value : new Float32Array(instanceCount * 16);
        mol_util_1.ValueCell.update(transformData.extraTransform, fillIdentityTransform(extraTransform, instanceCount));
        var aInstance = transformData.aInstance.ref.value.length >= instanceCount ? transformData.aInstance.ref.value : new Float32Array(instanceCount);
        mol_util_1.ValueCell.update(transformData.aInstance, (0, array_1.fillSerial)(aInstance, instanceCount));
        mol_util_1.ValueCell.update(transformData.hasReflection, hasReflection);
    }
    else {
        transformData = {
            aTransform: mol_util_1.ValueCell.create(new Float32Array(instanceCount * 16)),
            matrix: mol_util_1.ValueCell.create(linear_algebra_1.Mat4.identity()),
            transform: mol_util_1.ValueCell.create(new Float32Array(transformArray)),
            extraTransform: mol_util_1.ValueCell.create(fillIdentityTransform(new Float32Array(instanceCount * 16), instanceCount)),
            uInstanceCount: mol_util_1.ValueCell.create(instanceCount),
            instanceCount: mol_util_1.ValueCell.create(instanceCount),
            aInstance: mol_util_1.ValueCell.create((0, array_1.fillSerial)(new Float32Array(instanceCount))),
            hasReflection: mol_util_1.ValueCell.create(hasReflection),
        };
    }
    updateTransformData(transformData);
    return transformData;
}
exports.createTransform = createTransform;
var identityTransform = new Float32Array(16);
linear_algebra_1.Mat4.toArray(linear_algebra_1.Mat4.identity(), identityTransform, 0);
function createIdentityTransform(transformData) {
    return createTransform(new Float32Array(identityTransform), 1, transformData);
}
exports.createIdentityTransform = createIdentityTransform;
function fillIdentityTransform(transform, count) {
    for (var i = 0; i < count; i++) {
        transform.set(identityTransform, i * 16);
    }
    return transform;
}
exports.fillIdentityTransform = fillIdentityTransform;
/**
 * updates per-instance transform calculated for instance `i` as
 * `aTransform[i] = matrix * transform[i] * extraTransform[i]`
 */
function updateTransformData(transformData) {
    var aTransform = transformData.aTransform.ref.value;
    var instanceCount = transformData.instanceCount.ref.value;
    var matrix = transformData.matrix.ref.value;
    var transform = transformData.transform.ref.value;
    var extraTransform = transformData.extraTransform.ref.value;
    for (var i = 0; i < instanceCount; i++) {
        var i16 = i * 16;
        linear_algebra_1.Mat4.mulOffset(aTransform, extraTransform, transform, i16, i16, i16);
        linear_algebra_1.Mat4.mulOffset(aTransform, matrix, aTransform, i16, 0, i16);
    }
    mol_util_1.ValueCell.update(transformData.aTransform, aTransform);
}
exports.updateTransformData = updateTransformData;
