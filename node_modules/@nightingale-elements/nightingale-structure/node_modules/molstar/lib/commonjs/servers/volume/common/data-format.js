"use strict";
/**
 * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * Taken/adapted from DensityServer (https://github.com/dsehnal/DensityServer)
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.readHeader = exports.encodeHeader = void 0;
var tslib_1 = require("tslib");
var Schema = tslib_1.__importStar(require("./binary-schema"));
var _schema;
(function (_schema) {
    var array = Schema.array, obj = Schema.obj, int = Schema.int, bool = Schema.bool, float = Schema.float, str = Schema.str;
    _schema.schema = obj([
        ['formatVersion', str],
        ['axisOrder', array(int)],
        ['origin', array(float)],
        ['dimensions', array(float)],
        ['spacegroup', obj([
                ['number', int],
                ['size', array(float)],
                ['angles', array(float)],
                ['isPeriodic', bool],
            ])],
        ['channels', array(str)],
        ['valueType', str],
        ['blockSize', int],
        ['sampling', array(obj([
                ['byteOffset', float],
                ['rate', int],
                ['valuesInfo', array(obj([
                        ['mean', float],
                        ['sigma', float],
                        ['min', float],
                        ['max', float]
                    ]))],
                ['sampleCount', array(int)]
            ]))]
    ]);
})(_schema || (_schema = {}));
var headerSchema = _schema.schema;
function encodeHeader(header) {
    return Schema.encode(headerSchema, header);
}
exports.encodeHeader = encodeHeader;
function readHeader(file) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var buffer, headerSize, header;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, file.readBuffer(0, 4 * 4096)];
                case 1:
                    buffer = (_a.sent()).buffer;
                    headerSize = buffer.readInt32LE(0);
                    if (!(headerSize > buffer.byteLength - 4)) return [3 /*break*/, 3];
                    return [4 /*yield*/, file.readBuffer(0, headerSize + 4)];
                case 2:
                    buffer = (_a.sent()).buffer;
                    _a.label = 3;
                case 3:
                    header = Schema.decode(headerSchema, buffer, 4);
                    return [2 /*return*/, { header: header, dataOffset: headerSize + 4 }];
            }
        });
    });
}
exports.readHeader = readHeader;
