"use strict";
/**
 * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.segments = exports.SegmentIterator = exports.projectValue = exports.getSegment = exports.count = exports.ofOffsets = exports.create = void 0;
var ordered_set_1 = require("../ordered-set");
var interval_1 = require("../interval");
var sorted_array_1 = require("../sorted-array");
function create(values) {
    var offsets = sorted_array_1.SortedArray.ofSortedArray(values);
    var max = sorted_array_1.SortedArray.max(offsets);
    var index = new Int32Array(max);
    for (var i = 0, _i = values.length - 1; i < _i; i++) {
        for (var j = values[i], _j = values[i + 1]; j < _j; j++) {
            index[j] = i;
        }
    }
    return { offsets: offsets, index: index, count: values.length - 1 };
}
exports.create = create;
function ofOffsets(offsets, bounds) {
    var s = interval_1.Interval.start(bounds);
    var segments = new Int32Array(offsets.length + 1);
    for (var i = 0, _i = offsets.length; i < _i; i++) {
        segments[i] = offsets[i] - s;
    }
    segments[offsets.length] = interval_1.Interval.end(bounds) - s;
    return create(segments);
}
exports.ofOffsets = ofOffsets;
/** Get number of segments in a segmentation */
function count(_a) {
    var count = _a.count;
    return count;
}
exports.count = count;
function getSegment(_a, value) {
    var index = _a.index;
    return index[value];
}
exports.getSegment = getSegment;
function projectValue(_a, set, value) {
    var offsets = _a.offsets;
    var last = ordered_set_1.OrderedSet.max(offsets);
    var idx = value >= last ? -1 : ordered_set_1.OrderedSet.findPredecessorIndex(offsets, value - 1);
    return ordered_set_1.OrderedSet.findRange(set, ordered_set_1.OrderedSet.getAt(offsets, idx), ordered_set_1.OrderedSet.getAt(offsets, idx + 1) - 1);
}
exports.projectValue = projectValue;
var SegmentIterator = /** @class */ (function () {
    function SegmentIterator(segments, segmentMap, set, inputRange) {
        this.segments = segments;
        this.segmentMap = segmentMap;
        this.set = set;
        this.segmentMin = 0;
        this.segmentMax = 0;
        this.setRange = interval_1.Interval.Empty;
        this.value = { index: 0, start: 0, end: 0 };
        this.hasNext = false;
        this.setRange = inputRange;
        this.updateSegmentRange();
    }
    SegmentIterator.prototype.move = function () {
        while (this.hasNext) {
            if (this.updateValue()) {
                this.value.index = this.segmentMin++;
                this.hasNext = this.segmentMax >= this.segmentMin && interval_1.Interval.size(this.setRange) > 0;
                break;
            }
            else {
                this.updateSegmentRange();
            }
        }
        return this.value;
    };
    SegmentIterator.prototype.updateValue = function () {
        var segmentEnd = this.segments[this.segmentMin + 1];
        // TODO: add optimized version for interval and array?
        var setEnd = ordered_set_1.OrderedSet.findPredecessorIndexInInterval(this.set, segmentEnd, this.setRange);
        this.value.start = interval_1.Interval.start(this.setRange);
        this.value.end = setEnd;
        this.setRange = interval_1.Interval.ofBounds(setEnd, interval_1.Interval.end(this.setRange));
        return setEnd > this.value.start;
    };
    SegmentIterator.prototype.updateSegmentRange = function () {
        var sMin = interval_1.Interval.min(this.setRange), sMax = interval_1.Interval.max(this.setRange);
        if (sMax < sMin) {
            this.hasNext = false;
            return;
        }
        this.segmentMin = this.segmentMap[ordered_set_1.OrderedSet.getAt(this.set, sMin)];
        this.segmentMax = this.segmentMap[ordered_set_1.OrderedSet.getAt(this.set, sMax)];
        this.hasNext = this.segmentMax >= this.segmentMin;
    };
    SegmentIterator.prototype.setSegment = function (segment) {
        this.setRange = interval_1.Interval.ofBounds(segment.start, segment.end);
        this.updateSegmentRange();
    };
    return SegmentIterator;
}());
exports.SegmentIterator = SegmentIterator;
function segments(segs, set, segment) {
    var int = typeof segment !== 'undefined' ? interval_1.Interval.ofBounds(segment.start, segment.end) : interval_1.Interval.ofBounds(0, ordered_set_1.OrderedSet.size(set));
    return new SegmentIterator(segs.offsets, segs.index, set, int);
}
exports.segments = segments;
